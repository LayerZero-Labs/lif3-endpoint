{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/Initializable.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal initializer {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal initializer {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// solhint-disable-next-line compiler-version\npragma solidity >=0.4.24 <0.8.0;\n\nimport \"../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || _isConstructor() || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /// @dev Returns true if and only if the function is running in the constructor\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\nimport \"../proxy/Initializable.sol\";\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n    }\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"../utils/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 { revert(0, returndatasize()) }\n            default { return(0, returndatasize()) }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback () external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive () external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overriden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/UpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"./Proxy.sol\";\nimport \"../utils/Address.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n *\n * Upgradeability is only provided internally through {_upgradeTo}. For an externally upgradeable proxy see\n * {TransparentUpgradeableProxy}.\n */\ncontract UpgradeableProxy is Proxy {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializating the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n        _setImplementation(_logic);\n        if(_data.length > 0) {\n            Address.functionDelegateCall(_logic, _data);\n        }\n    }\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 private constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        bytes32 slot = _IMPLEMENTATION_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            impl := sload(slot)\n        }\n    }\n\n    /**\n     * @dev Upgrades the proxy to a new implementation.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal virtual {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"UpgradeableProxy: new implementation is not a contract\");\n\n        bytes32 slot = _IMPLEMENTATION_SLOT;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(slot, newImplementation)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"../../utils/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal virtual {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/V1Contracts/contracts/Endpoint.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\n\nimport \"./interfaces/ILayerZeroReceiver.sol\";\nimport \"./interfaces/ILayerZeroEndpoint.sol\";\nimport \"./interfaces/ILayerZeroMessagingLibrary.sol\";\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract Endpoint is Ownable, ILayerZeroEndpoint {\n    uint16 public immutable chainId;\n\n    // installed libraries and reserved versions\n    uint16 public constant BLOCK_VERSION = 65535;\n    uint16 public constant DEFAULT_VERSION = 0;\n    uint16 public latestVersion;\n    mapping(uint16 => ILayerZeroMessagingLibrary) public libraryLookup; // version -> ILayerZeroEndpointLibrary\n\n    // default send/receive libraries\n    uint16 public defaultSendVersion;\n    uint16 public defaultReceiveVersion;\n    ILayerZeroMessagingLibrary public defaultSendLibrary;\n    address public defaultReceiveLibraryAddress;\n\n    struct LibraryConfig {\n        uint16 sendVersion;\n        uint16 receiveVersion;\n        address receiveLibraryAddress;\n        ILayerZeroMessagingLibrary sendLibrary;\n    }\n\n    struct StoredPayload {\n        uint64 payloadLength;\n        address dstAddress;\n        bytes32 payloadHash;\n    }\n\n    // user app config = [uaAddress]\n    mapping(address => LibraryConfig) public uaConfigLookup;\n    // inboundNonce = [srcChainId][srcAddress].\n    mapping(uint16 => mapping(bytes => uint64)) public inboundNonce;\n    // outboundNonce = [dstChainId][srcAddress].\n    mapping(uint16 => mapping(address => uint64)) public outboundNonce;\n    // storedPayload = [srcChainId][srcAddress]\n    mapping(uint16 => mapping(bytes => StoredPayload)) public storedPayload;\n\n    // library versioning events\n    event NewLibraryVersionAdded(uint16 version);\n    event DefaultSendVersionSet(uint16 version);\n    event DefaultReceiveVersionSet(uint16 version);\n    event UaSendVersionSet(address ua, uint16 version);\n    event UaReceiveVersionSet(address ua, uint16 version);\n    event UaForceResumeReceive(uint16 chainId, bytes srcAddress);\n    // payload events\n    event PayloadCleared(uint16 srcChainId, bytes srcAddress, uint64 nonce, address dstAddress);\n    event PayloadStored(\n        uint16 srcChainId,\n        bytes srcAddress,\n        address dstAddress,\n        uint64 nonce,\n        bytes payload,\n        bytes reason\n    );\n\n    constructor(uint16 _chainId) {\n        chainId = _chainId;\n    }\n\n    //---------------------------------------------------------------------------\n    // send and receive nonreentrant lock\n    uint8 internal constant _NOT_ENTERED = 1;\n    uint8 internal constant _ENTERED = 2;\n    uint8 internal _send_entered_state = 1;\n    uint8 internal _receive_entered_state = 1;\n\n    modifier sendNonReentrant() {\n        require(_send_entered_state == _NOT_ENTERED, \"LayerZero: no send reentrancy\");\n        _send_entered_state = _ENTERED;\n        _;\n        _send_entered_state = _NOT_ENTERED;\n    }\n    modifier receiveNonReentrant() {\n        require(_receive_entered_state == _NOT_ENTERED, \"LayerZero: no receive reentrancy\");\n        _receive_entered_state = _ENTERED;\n        _;\n        _receive_entered_state = _NOT_ENTERED;\n    }\n\n    // BLOCK_VERSION is also a valid version\n    modifier validVersion(uint16 _version) {\n        require(_version <= latestVersion || _version == BLOCK_VERSION, \"LayerZero: invalid messaging library version\");\n        _;\n    }\n\n    //---------------------------------------------------------------------------\n    // User Application Calls - Endpoint Interface\n\n    function send(\n        uint16 _dstChainId,\n        bytes calldata _destination,\n        bytes calldata _payload,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes calldata _adapterParams\n    ) external payable override sendNonReentrant {\n        LibraryConfig storage uaConfig = uaConfigLookup[msg.sender];\n        uint64 nonce = ++outboundNonce[_dstChainId][msg.sender];\n        _getSendLibrary(uaConfig).send{value: msg.value}(\n            msg.sender,\n            nonce,\n            _dstChainId,\n            _destination,\n            _payload,\n            _refundAddress,\n            _zroPaymentAddress,\n            _adapterParams\n        );\n    }\n\n    //---------------------------------------------------------------------------\n    // authenticated Library (msg.sender) Calls to pass through Endpoint to UA (dstAddress)\n    function receivePayload(\n        uint16 _srcChainId,\n        bytes calldata _srcAddress,\n        address _dstAddress,\n        uint64 _nonce,\n        uint _gasLimit,\n        bytes calldata _payload\n    ) external override receiveNonReentrant {\n        // assert and increment the nonce. no message shuffling\n        require(_nonce == ++inboundNonce[_srcChainId][_srcAddress], \"LayerZero: wrong nonce\");\n\n        LibraryConfig storage uaConfig = uaConfigLookup[_dstAddress];\n\n        // authentication to prevent cross-version message validation\n        // protects against a malicious library from passing arbitrary data\n        if (uaConfig.receiveVersion == DEFAULT_VERSION) {\n            require(defaultReceiveLibraryAddress == msg.sender, \"LayerZero: invalid default library\");\n        } else {\n            require(uaConfig.receiveLibraryAddress == msg.sender, \"LayerZero: invalid library\");\n        }\n\n        // block if any message blocking\n        StoredPayload storage sp = storedPayload[_srcChainId][_srcAddress];\n        require(sp.payloadHash == bytes32(0), \"LayerZero: in message blocking\");\n\n        try ILayerZeroReceiver(_dstAddress).lzReceive{gas: _gasLimit}(_srcChainId, _srcAddress, _nonce, _payload) {\n            // success, do nothing, end of the message delivery\n        } catch (bytes memory reason) {\n            // revert nonce if any uncaught errors/exceptions if the ua chooses the blocking mode\n            storedPayload[_srcChainId][_srcAddress] = StoredPayload(\n                uint64(_payload.length),\n                _dstAddress,\n                keccak256(_payload)\n            );\n            emit PayloadStored(_srcChainId, _srcAddress, _dstAddress, _nonce, _payload, reason);\n        }\n    }\n\n    function retryPayload(\n        uint16 _srcChainId,\n        bytes calldata _srcAddress,\n        bytes calldata _payload\n    ) external override receiveNonReentrant {\n        StoredPayload storage sp = storedPayload[_srcChainId][_srcAddress];\n        require(sp.payloadHash != bytes32(0), \"LayerZero: no stored payload\");\n        require(\n            _payload.length == sp.payloadLength && keccak256(_payload) == sp.payloadHash,\n            \"LayerZero: invalid payload\"\n        );\n\n        address dstAddress = sp.dstAddress;\n        // empty the storedPayload\n        sp.payloadLength = 0;\n        sp.dstAddress = address(0);\n        sp.payloadHash = bytes32(0);\n\n        uint64 nonce = inboundNonce[_srcChainId][_srcAddress];\n\n        ILayerZeroReceiver(dstAddress).lzReceive(_srcChainId, _srcAddress, nonce, _payload);\n        emit PayloadCleared(_srcChainId, _srcAddress, nonce, dstAddress);\n    }\n\n    //---------------------------------------------------------------------------\n    // Owner Calls, only new library version upgrade (3 steps)\n\n    // note libraryLookup[0] = 0x0, no library implementation\n    // LIBRARY UPGRADE step 1: set _newLayerZeroLibraryAddress be the new version\n    function newVersion(address _newLayerZeroLibraryAddress) external onlyOwner {\n        require(_newLayerZeroLibraryAddress != address(0x0), \"LayerZero: new version cannot be zero address\");\n        require(latestVersion < 65535, \"LayerZero: can not add new messaging library\");\n        latestVersion++;\n        libraryLookup[latestVersion] = ILayerZeroMessagingLibrary(_newLayerZeroLibraryAddress);\n        emit NewLibraryVersionAdded(latestVersion);\n    }\n\n    // LIBRARY UPGRADE step 2: stop sending messages from the old version\n    function setDefaultSendVersion(\n        uint16 _newDefaultSendVersion\n    ) external onlyOwner validVersion(_newDefaultSendVersion) {\n        require(_newDefaultSendVersion != DEFAULT_VERSION, \"LayerZero: default send version must > 0\");\n        defaultSendVersion = _newDefaultSendVersion;\n        defaultSendLibrary = libraryLookup[defaultSendVersion];\n        emit DefaultSendVersionSet(_newDefaultSendVersion);\n    }\n\n    // LIBRARY UPGRADE step 3: stop receiving messages from the old version\n    function setDefaultReceiveVersion(\n        uint16 _newDefaultReceiveVersion\n    ) external onlyOwner validVersion(_newDefaultReceiveVersion) {\n        require(_newDefaultReceiveVersion != DEFAULT_VERSION, \"LayerZero: default receive version must > 0\");\n        defaultReceiveVersion = _newDefaultReceiveVersion;\n        defaultReceiveLibraryAddress = address(libraryLookup[defaultReceiveVersion]);\n        emit DefaultReceiveVersionSet(_newDefaultReceiveVersion);\n    }\n\n    //---------------------------------------------------------------------------\n    // User Application Calls - UA set/get Interface\n\n    function setConfig(\n        uint16 _version,\n        uint16 _chainId,\n        uint _configType,\n        bytes calldata _config\n    ) external override validVersion(_version) {\n        if (_version == DEFAULT_VERSION) {\n            require(\n                defaultSendVersion == defaultReceiveVersion,\n                \"LayerZero: can not set Config during DEFAULT migration\"\n            );\n            _version = defaultSendVersion;\n        }\n        require(_version != BLOCK_VERSION, \"LayerZero: can not set config for BLOCK_VERSION\");\n        libraryLookup[_version].setConfig(_chainId, msg.sender, _configType, _config);\n    }\n\n    // Migration step 1: set the send version\n    // Define what library the UA points too\n    function setSendVersion(uint16 _newVersion) external override validVersion(_newVersion) {\n        // write into config\n        LibraryConfig storage uaConfig = uaConfigLookup[msg.sender];\n        uaConfig.sendVersion = _newVersion;\n        // the libraryLookup[BLOCK_VERSION || DEFAULT_VERSION] = 0x0\n        uaConfig.sendLibrary = libraryLookup[_newVersion];\n        emit UaSendVersionSet(msg.sender, _newVersion);\n    }\n\n    // Migration step 2: set the receive version\n    // after all messages sent from the old version are received\n    // the UA can now safely switch to the new receive version\n    // it is the UA's responsibility make sure all messages from the old version are processed\n    function setReceiveVersion(uint16 _newVersion) external override validVersion(_newVersion) {\n        // write into config\n        LibraryConfig storage uaConfig = uaConfigLookup[msg.sender];\n        uaConfig.receiveVersion = _newVersion;\n        // the libraryLookup[BLOCK_VERSION || DEFAULT_VERSION] = 0x0\n        uaConfig.receiveLibraryAddress = address(libraryLookup[_newVersion]);\n        emit UaReceiveVersionSet(msg.sender, _newVersion);\n    }\n\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override {\n        StoredPayload storage sp = storedPayload[_srcChainId][_srcAddress];\n        // revert if no messages are cached. safeguard malicious UA behaviour\n        require(sp.payloadHash != bytes32(0), \"LayerZero: no stored payload\");\n        require(sp.dstAddress == msg.sender, \"LayerZero: invalid caller\");\n\n        // empty the storedPayload\n        sp.payloadLength = 0;\n        sp.dstAddress = address(0);\n        sp.payloadHash = bytes32(0);\n\n        // emit the event with the new nonce\n        emit UaForceResumeReceive(_srcChainId, _srcAddress);\n    }\n\n    //---------------------------------------------------------------------------\n    // view helper function\n\n    function estimateFees(\n        uint16 _dstChainId,\n        address _userApplication,\n        bytes calldata _payload,\n        bool _payInZRO,\n        bytes calldata _adapterParams\n    ) external view override returns (uint nativeFee, uint zroFee) {\n        LibraryConfig storage uaConfig = uaConfigLookup[_userApplication];\n        ILayerZeroMessagingLibrary lib = uaConfig.sendVersion == DEFAULT_VERSION\n            ? defaultSendLibrary\n            : uaConfig.sendLibrary;\n        return lib.estimateFees(_dstChainId, _userApplication, _payload, _payInZRO, _adapterParams);\n    }\n\n    function _getSendLibrary(LibraryConfig storage uaConfig) internal view returns (ILayerZeroMessagingLibrary) {\n        if (uaConfig.sendVersion == DEFAULT_VERSION) {\n            // check if the in send-blocking upgrade\n            require(defaultSendVersion != BLOCK_VERSION, \"LayerZero: default in BLOCK_VERSION\");\n            return defaultSendLibrary;\n        } else {\n            // check if the in send-blocking upgrade\n            require(uaConfig.sendVersion != BLOCK_VERSION, \"LayerZero: in BLOCK_VERSION\");\n            return uaConfig.sendLibrary;\n        }\n    }\n\n    function getSendLibraryAddress(\n        address _userApplication\n    ) external view override returns (address sendLibraryAddress) {\n        LibraryConfig storage uaConfig = uaConfigLookup[_userApplication];\n        uint16 sendVersion = uaConfig.sendVersion;\n        require(sendVersion != BLOCK_VERSION, \"LayerZero: send version is BLOCK_VERSION\");\n        if (sendVersion == DEFAULT_VERSION) {\n            require(defaultSendVersion != BLOCK_VERSION, \"LayerZero: send version (default) is BLOCK_VERSION\");\n            sendLibraryAddress = address(defaultSendLibrary);\n        } else {\n            sendLibraryAddress = address(uaConfig.sendLibrary);\n        }\n    }\n\n    function getReceiveLibraryAddress(\n        address _userApplication\n    ) external view override returns (address receiveLibraryAddress) {\n        LibraryConfig storage uaConfig = uaConfigLookup[_userApplication];\n        uint16 receiveVersion = uaConfig.receiveVersion;\n        require(receiveVersion != BLOCK_VERSION, \"LayerZero: receive version is BLOCK_VERSION\");\n        if (receiveVersion == DEFAULT_VERSION) {\n            require(defaultReceiveVersion != BLOCK_VERSION, \"LayerZero: receive version (default) is BLOCK_VERSION\");\n            receiveLibraryAddress = defaultReceiveLibraryAddress;\n        } else {\n            receiveLibraryAddress = uaConfig.receiveLibraryAddress;\n        }\n    }\n\n    function isSendingPayload() external view override returns (bool) {\n        return _send_entered_state == _ENTERED;\n    }\n\n    function isReceivingPayload() external view override returns (bool) {\n        return _receive_entered_state == _ENTERED;\n    }\n\n    function getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress) external view override returns (uint64) {\n        return inboundNonce[_srcChainId][_srcAddress];\n    }\n\n    function getOutboundNonce(uint16 _dstChainId, address _srcAddress) external view override returns (uint64) {\n        return outboundNonce[_dstChainId][_srcAddress];\n    }\n\n    function getChainId() external view override returns (uint16) {\n        return chainId;\n    }\n\n    function getSendVersion(address _userApplication) external view override returns (uint16) {\n        LibraryConfig storage uaConfig = uaConfigLookup[_userApplication];\n        return uaConfig.sendVersion == DEFAULT_VERSION ? defaultSendVersion : uaConfig.sendVersion;\n    }\n\n    function getReceiveVersion(address _userApplication) external view override returns (uint16) {\n        LibraryConfig storage uaConfig = uaConfigLookup[_userApplication];\n        return uaConfig.receiveVersion == DEFAULT_VERSION ? defaultReceiveVersion : uaConfig.receiveVersion;\n    }\n\n    function getConfig(\n        uint16 _version,\n        uint16 _chainId,\n        address _userApplication,\n        uint _configType\n    ) external view override validVersion(_version) returns (bytes memory) {\n        if (_version == DEFAULT_VERSION) {\n            require(defaultSendVersion == defaultReceiveVersion, \"LayerZero: no DEFAULT config while migration\");\n            _version = defaultSendVersion;\n        }\n        require(_version != BLOCK_VERSION, \"LayerZero: can not get config for BLOCK_VERSION\");\n        return libraryLookup[_version].getConfig(_chainId, _userApplication, _configType);\n    }\n\n    function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view override returns (bool) {\n        StoredPayload storage sp = storedPayload[_srcChainId][_srcAddress];\n        return sp.payloadHash != bytes32(0);\n    }\n}\n"
    },
    "contracts/V1Contracts/contracts/EndpointLite.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\n\nimport \"./interfaces/ILayerZeroReceiver.sol\";\nimport \"./interfaces/ILayerZeroEndpoint.sol\";\nimport \"./interfaces/ILayerZeroMessagingLibrary.sol\";\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract EndpointLite is Ownable, ILayerZeroEndpoint {\n    uint16 public immutable chainId;\n\n    // installed libraries and reserved versions\n    uint16 public constant BLOCK_VERSION = 65535;\n    uint16 public constant DEFAULT_VERSION = 0;\n    uint16 public latestVersion;\n    mapping(uint16 => ILayerZeroMessagingLibrary) public libraryLookup; // version -> ILayerZeroEndpointLibrary\n\n    // default send/receive libraries\n    uint16 public defaultSendVersion;\n    uint16 public defaultReceiveVersion;\n    ILayerZeroMessagingLibrary public defaultSendLibrary;\n    address public defaultReceiveLibraryAddress;\n\n    struct LibraryConfig {\n        uint16 sendVersion;\n        uint16 receiveVersion;\n        address receiveLibraryAddress;\n        ILayerZeroMessagingLibrary sendLibrary;\n    }\n\n    struct StoredPayload {\n        uint64 payloadLength;\n        address dstAddress;\n        bytes32 payloadHash;\n    }\n\n    // user app config = [uaAddress]\n    mapping(address => LibraryConfig) public uaConfigLookup;\n    // inboundNonce = [srcChainId][srcAddress].\n    mapping(uint16 => mapping(bytes => uint64)) public inboundNonce;\n    // storedPayload = [srcChainId][srcAddress]\n    mapping(uint16 => mapping(bytes => StoredPayload)) public storedPayload;\n\n    // library versioning events\n    event NewLibraryVersionAdded(uint16 version);\n    event DefaultSendVersionSet(uint16 version);\n    event DefaultReceiveVersionSet(uint16 version);\n    event UaSendVersionSet(address ua, uint16 version);\n    event UaReceiveVersionSet(address ua, uint16 version);\n    event UaForceResumeReceive(uint16 chainId, bytes srcAddress);\n    // payload events\n    event PayloadCleared(uint16 srcChainId, bytes srcAddress, uint64 nonce, address dstAddress);\n    event PayloadStored(\n        uint16 srcChainId,\n        bytes srcAddress,\n        address dstAddress,\n        uint64 nonce,\n        bytes payload,\n        bytes reason\n    );\n\n    constructor(uint16 _chainId) {\n        chainId = _chainId;\n    }\n\n    //---------------------------------------------------------------------------\n    // send and receive nonreentrant lock\n    uint8 internal constant _NOT_ENTERED = 1;\n    uint8 internal constant _ENTERED = 2;\n    uint8 internal _send_entered_state = 1;\n    uint8 internal _receive_entered_state = 1;\n\n    modifier sendNonReentrant() {\n        require(_send_entered_state == _NOT_ENTERED, \"LayerZero: no send reentrancy\");\n        _send_entered_state = _ENTERED;\n        _;\n        _send_entered_state = _NOT_ENTERED;\n    }\n    modifier receiveNonReentrant() {\n        require(_receive_entered_state == _NOT_ENTERED, \"LayerZero: no receive reentrancy\");\n        _receive_entered_state = _ENTERED;\n        _;\n        _receive_entered_state = _NOT_ENTERED;\n    }\n\n    // BLOCK_VERSION is also a valid version\n    modifier validVersion(uint16 _version) {\n        require(_version <= latestVersion || _version == BLOCK_VERSION, \"LayerZero: invalid messaging library version\");\n        _;\n    }\n\n    //---------------------------------------------------------------------------\n    // User Application Calls - Endpoint Interface\n\n    function send(\n        uint16 _dstChainId,\n        bytes calldata _destination,\n        bytes calldata _payload,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes calldata _adapterParams\n    ) external payable override sendNonReentrant {\n        LibraryConfig storage uaConfig = uaConfigLookup[msg.sender];\n        _getSendLibrary(uaConfig).send{value: msg.value}(\n            msg.sender,\n            0,\n            _dstChainId,\n            _destination,\n            _payload,\n            _refundAddress,\n            _zroPaymentAddress,\n            _adapterParams\n        );\n    }\n\n    //---------------------------------------------------------------------------\n    // authenticated Library (msg.sender) Calls to pass through Endpoint to UA (dstAddress)\n    function receivePayload(\n        uint16 _srcChainId,\n        bytes calldata _srcAddress,\n        address _dstAddress,\n        uint64 _nonce,\n        uint _gasLimit,\n        bytes calldata _payload\n    ) external override receiveNonReentrant {\n        // assert and increment the nonce. no message shuffling\n        require(_nonce == ++inboundNonce[_srcChainId][_srcAddress], \"LayerZero: wrong nonce\");\n\n        LibraryConfig storage uaConfig = uaConfigLookup[_dstAddress];\n\n        // authentication to prevent cross-version message validation\n        // protects against a malicious library from passing arbitrary data\n        if (uaConfig.receiveVersion == DEFAULT_VERSION) {\n            require(defaultReceiveLibraryAddress == msg.sender, \"LayerZero: invalid default library\");\n        } else {\n            require(uaConfig.receiveLibraryAddress == msg.sender, \"LayerZero: invalid library\");\n        }\n\n        // block if any message blocking\n        StoredPayload storage sp = storedPayload[_srcChainId][_srcAddress];\n        require(sp.payloadHash == bytes32(0), \"LayerZero: in message blocking\");\n\n        try ILayerZeroReceiver(_dstAddress).lzReceive{gas: _gasLimit}(_srcChainId, _srcAddress, _nonce, _payload) {\n            // success, do nothing, end of the message delivery\n        } catch (bytes memory reason) {\n            // revert nonce if any uncaught errors/exceptions if the ua chooses the blocking mode\n            storedPayload[_srcChainId][_srcAddress] = StoredPayload(\n                uint64(_payload.length),\n                _dstAddress,\n                keccak256(_payload)\n            );\n            emit PayloadStored(_srcChainId, _srcAddress, _dstAddress, _nonce, _payload, reason);\n        }\n    }\n\n    function retryPayload(\n        uint16 _srcChainId,\n        bytes calldata _srcAddress,\n        bytes calldata _payload\n    ) external override receiveNonReentrant {\n        StoredPayload storage sp = storedPayload[_srcChainId][_srcAddress];\n        require(sp.payloadHash != bytes32(0), \"LayerZero: no stored payload\");\n        require(\n            _payload.length == sp.payloadLength && keccak256(_payload) == sp.payloadHash,\n            \"LayerZero: invalid payload\"\n        );\n\n        address dstAddress = sp.dstAddress;\n        // empty the storedPayload\n        sp.payloadLength = 0;\n        sp.dstAddress = address(0);\n        sp.payloadHash = bytes32(0);\n\n        uint64 nonce = inboundNonce[_srcChainId][_srcAddress];\n\n        ILayerZeroReceiver(dstAddress).lzReceive(_srcChainId, _srcAddress, nonce, _payload);\n        emit PayloadCleared(_srcChainId, _srcAddress, nonce, dstAddress);\n    }\n\n    //---------------------------------------------------------------------------\n    // Owner Calls, only new library version upgrade (3 steps)\n\n    // note libraryLookup[0] = 0x0, no library implementation\n    // LIBRARY UPGRADE step 1: set _newLayerZeroLibraryAddress be the new version\n    function newVersion(address _newLayerZeroLibraryAddress) external onlyOwner {\n        require(_newLayerZeroLibraryAddress != address(0x0), \"LayerZero: new version cannot be zero address\");\n        require(latestVersion < 65535, \"LayerZero: can not add new messaging library\");\n        latestVersion++;\n        libraryLookup[latestVersion] = ILayerZeroMessagingLibrary(_newLayerZeroLibraryAddress);\n        emit NewLibraryVersionAdded(latestVersion);\n    }\n\n    // LIBRARY UPGRADE step 2: stop sending messages from the old version\n    function setDefaultSendVersion(\n        uint16 _newDefaultSendVersion\n    ) external onlyOwner validVersion(_newDefaultSendVersion) {\n        require(_newDefaultSendVersion != DEFAULT_VERSION, \"LayerZero: default send version must > 0\");\n        defaultSendVersion = _newDefaultSendVersion;\n        defaultSendLibrary = libraryLookup[defaultSendVersion];\n        emit DefaultSendVersionSet(_newDefaultSendVersion);\n    }\n\n    // LIBRARY UPGRADE step 3: stop receiving messages from the old version\n    function setDefaultReceiveVersion(\n        uint16 _newDefaultReceiveVersion\n    ) external onlyOwner validVersion(_newDefaultReceiveVersion) {\n        require(_newDefaultReceiveVersion != DEFAULT_VERSION, \"LayerZero: default receive version must > 0\");\n        defaultReceiveVersion = _newDefaultReceiveVersion;\n        defaultReceiveLibraryAddress = address(libraryLookup[defaultReceiveVersion]);\n        emit DefaultReceiveVersionSet(_newDefaultReceiveVersion);\n    }\n\n    //---------------------------------------------------------------------------\n    // User Application Calls - UA set/get Interface\n\n    function setConfig(\n        uint16 _version,\n        uint16 _chainId,\n        uint _configType,\n        bytes calldata _config\n    ) external override validVersion(_version) {\n        if (_version == DEFAULT_VERSION) {\n            require(\n                defaultSendVersion == defaultReceiveVersion,\n                \"LayerZero: can not set Config during DEFAULT migration\"\n            );\n            _version = defaultSendVersion;\n        }\n        require(_version != BLOCK_VERSION, \"LayerZero: can not set config for BLOCK_VERSION\");\n        libraryLookup[_version].setConfig(_chainId, msg.sender, _configType, _config);\n    }\n\n    // Migration step 1: set the send version\n    // Define what library the UA points too\n    function setSendVersion(uint16 _newVersion) external override validVersion(_newVersion) {\n        // write into config\n        LibraryConfig storage uaConfig = uaConfigLookup[msg.sender];\n        uaConfig.sendVersion = _newVersion;\n        // the libraryLookup[BLOCK_VERSION || DEFAULT_VERSION] = 0x0\n        uaConfig.sendLibrary = libraryLookup[_newVersion];\n        emit UaSendVersionSet(msg.sender, _newVersion);\n    }\n\n    // Migration step 2: set the receive version\n    // after all messages sent from the old version are received\n    // the UA can now safely switch to the new receive version\n    // it is the UA's responsibility make sure all messages from the old version are processed\n    function setReceiveVersion(uint16 _newVersion) external override validVersion(_newVersion) {\n        // write into config\n        LibraryConfig storage uaConfig = uaConfigLookup[msg.sender];\n        uaConfig.receiveVersion = _newVersion;\n        // the libraryLookup[BLOCK_VERSION || DEFAULT_VERSION] = 0x0\n        uaConfig.receiveLibraryAddress = address(libraryLookup[_newVersion]);\n        emit UaReceiveVersionSet(msg.sender, _newVersion);\n    }\n\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override {\n        StoredPayload storage sp = storedPayload[_srcChainId][_srcAddress];\n        // revert if no messages are cached. safeguard malicious UA behaviour\n        require(sp.payloadHash != bytes32(0), \"LayerZero: no stored payload\");\n        require(sp.dstAddress == msg.sender, \"LayerZero: invalid caller\");\n\n        // empty the storedPayload\n        sp.payloadLength = 0;\n        sp.dstAddress = address(0);\n        sp.payloadHash = bytes32(0);\n\n        // emit the event with the new nonce\n        emit UaForceResumeReceive(_srcChainId, _srcAddress);\n    }\n\n    //---------------------------------------------------------------------------\n    // view helper function\n\n    function estimateFees(\n        uint16 _dstChainId,\n        address _userApplication,\n        bytes calldata _payload,\n        bool _payInZRO,\n        bytes calldata _adapterParams\n    ) external view override returns (uint nativeFee, uint zroFee) {\n        LibraryConfig storage uaConfig = uaConfigLookup[_userApplication];\n        ILayerZeroMessagingLibrary lib = uaConfig.sendVersion == DEFAULT_VERSION\n            ? defaultSendLibrary\n            : uaConfig.sendLibrary;\n        return lib.estimateFees(_dstChainId, _userApplication, _payload, _payInZRO, _adapterParams);\n    }\n\n    function _getSendLibrary(LibraryConfig storage uaConfig) internal view returns (ILayerZeroMessagingLibrary) {\n        if (uaConfig.sendVersion == DEFAULT_VERSION) {\n            // check if the in send-blocking upgrade\n            require(defaultSendVersion != BLOCK_VERSION, \"LayerZero: default in BLOCK_VERSION\");\n            return defaultSendLibrary;\n        } else {\n            // check if the in send-blocking upgrade\n            require(uaConfig.sendVersion != BLOCK_VERSION, \"LayerZero: in BLOCK_VERSION\");\n            return uaConfig.sendLibrary;\n        }\n    }\n\n    function getSendLibraryAddress(\n        address _userApplication\n    ) external view override returns (address sendLibraryAddress) {\n        LibraryConfig storage uaConfig = uaConfigLookup[_userApplication];\n        uint16 sendVersion = uaConfig.sendVersion;\n        require(sendVersion != BLOCK_VERSION, \"LayerZero: send version is BLOCK_VERSION\");\n        if (sendVersion == DEFAULT_VERSION) {\n            require(defaultSendVersion != BLOCK_VERSION, \"LayerZero: send version (default) is BLOCK_VERSION\");\n            sendLibraryAddress = address(defaultSendLibrary);\n        } else {\n            sendLibraryAddress = address(uaConfig.sendLibrary);\n        }\n    }\n\n    function getReceiveLibraryAddress(\n        address _userApplication\n    ) external view override returns (address receiveLibraryAddress) {\n        LibraryConfig storage uaConfig = uaConfigLookup[_userApplication];\n        uint16 receiveVersion = uaConfig.receiveVersion;\n        require(receiveVersion != BLOCK_VERSION, \"LayerZero: receive version is BLOCK_VERSION\");\n        if (receiveVersion == DEFAULT_VERSION) {\n            require(defaultReceiveVersion != BLOCK_VERSION, \"LayerZero: receive version (default) is BLOCK_VERSION\");\n            receiveLibraryAddress = defaultReceiveLibraryAddress;\n        } else {\n            receiveLibraryAddress = uaConfig.receiveLibraryAddress;\n        }\n    }\n\n    function isSendingPayload() external view override returns (bool) {\n        return _send_entered_state == _ENTERED;\n    }\n\n    function isReceivingPayload() external view override returns (bool) {\n        return _receive_entered_state == _ENTERED;\n    }\n\n    function getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress) external view override returns (uint64) {\n        return inboundNonce[_srcChainId][_srcAddress];\n    }\n\n    function getOutboundNonce(uint16, address) external pure override returns (uint64) {\n        revert(\"LayerZero: no outbound nonce at endpoint\");\n    }\n\n    function getChainId() external view override returns (uint16) {\n        return chainId;\n    }\n\n    function getSendVersion(address _userApplication) external view override returns (uint16) {\n        LibraryConfig storage uaConfig = uaConfigLookup[_userApplication];\n        return uaConfig.sendVersion == DEFAULT_VERSION ? defaultSendVersion : uaConfig.sendVersion;\n    }\n\n    function getReceiveVersion(address _userApplication) external view override returns (uint16) {\n        LibraryConfig storage uaConfig = uaConfigLookup[_userApplication];\n        return uaConfig.receiveVersion == DEFAULT_VERSION ? defaultReceiveVersion : uaConfig.receiveVersion;\n    }\n\n    function getConfig(\n        uint16 _version,\n        uint16 _chainId,\n        address _userApplication,\n        uint _configType\n    ) external view override validVersion(_version) returns (bytes memory) {\n        if (_version == DEFAULT_VERSION) {\n            require(defaultSendVersion == defaultReceiveVersion, \"LayerZero: no DEFAULT config while migration\");\n            _version = defaultSendVersion;\n        }\n        require(_version != BLOCK_VERSION, \"LayerZero: can not get config for BLOCK_VERSION\");\n        return libraryLookup[_version].getConfig(_chainId, _userApplication, _configType);\n    }\n\n    function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view override returns (bool) {\n        StoredPayload storage sp = storedPayload[_srcChainId][_srcAddress];\n        return sp.payloadHash != bytes32(0);\n    }\n}\n"
    },
    "contracts/V1Contracts/contracts/example/AltTokenUA.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../interfaces/ILayerZeroEndpoint.sol\";\nimport \"../interfaces/ILayerZeroReceiver.sol\";\n\n// An example UA running on Shrapnel using ERC20 as payment token\n// To demonstrate how feeToken payment needs to be atomic with layerzero send\ncontract AltTokenUA is ILayerZeroReceiver {\n    ILayerZeroEndpoint public endpoint;\n    IERC20 public feeToken;\n    address public feeHandler;\n\n    constructor(address _endpoint, address _feeToken, address _feeHandler) {\n        endpoint = ILayerZeroEndpoint(_endpoint);\n        feeToken = IERC20(_feeToken);\n        feeHandler = _feeHandler;\n    }\n\n    function send(\n        uint16 _dstChainId,\n        address _dstAddress,\n        bytes memory _payload,\n        bytes memory _adapterParams,\n        uint _fee\n    ) public payable {\n        feeToken.transferFrom(msg.sender, feeHandler, _fee);\n\n        bytes memory path = abi.encodePacked(_dstAddress, address(this));\n        endpoint.send(_dstChainId, path, _payload, msg.sender, address(0), _adapterParams);\n    }\n\n    function lzReceive(\n        uint16 _srcChainId,\n        bytes memory _fromAddress,\n        uint64 /*_nonce*/,\n        bytes memory _payload\n    ) external virtual override {\n        //do nothing\n    }\n}\n"
    },
    "contracts/V1Contracts/contracts/FeeHandler.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract FeeHandler is Ownable {\n    using SafeERC20 for IERC20;\n\n    IERC20 public feeToken;\n    mapping(address => bool) public approved;\n\n    constructor() {}\n\n    function setFeeToken(address _feeToken) external onlyOwner {\n        require(address(feeToken) == address(0x0), \"FeeHandler: feeToken already set\");\n        feeToken = IERC20(_feeToken);\n    }\n\n    function approve(address _uln) external onlyOwner {\n        approved[_uln] = true;\n    }\n\n    function creditFee(address[] calldata _receivers, uint[] calldata _amounts, address _refundAddress) external {\n        require(_receivers.length == _amounts.length, \"FeeHandler: invalid parameters\");\n        require(approved[msg.sender], \"FeeHandler: not approved\");\n\n        for (uint i = 0; i < _receivers.length; i++) {\n            feeToken.safeTransfer(_receivers[i], _amounts[i]);\n        }\n        uint remaining = feeToken.balanceOf(address(this));\n        if (remaining > 0) {\n            feeToken.safeTransfer(_refundAddress, remaining);\n        }\n    }\n}\n"
    },
    "contracts/V1Contracts/contracts/FPValidator.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\n// import \"./utility/LayerZeroPacket.sol\";\nimport \"../interfaces/ILayerZeroValidationLibrary.sol\";\nimport \"../interfaces/IValidationLibraryHelperV2.sol\";\n\ninterface IStargate {\n    // Stargate objects for abi encoding / decoding\n    struct SwapObj {\n        uint amount;\n        uint eqFee;\n        uint eqReward;\n        uint lpFee;\n        uint protocolFee;\n        uint lkbRemove;\n    }\n\n    struct CreditObj {\n        uint credits;\n        uint idealBalance;\n    }\n}\n\ncontract FPValidator is ILayerZeroValidationLibrary, IValidationLibraryHelperV2 {\n    uint8 public proofType = 2;\n    uint8 public utilsVersion = 1;\n\n    address public immutable stargateBridgeAddress;\n    address public immutable stargateTokenAddress;\n\n    constructor(address _stargateBridgeAddress, address _stargateTokenAddress) {\n        stargateBridgeAddress = _stargateBridgeAddress;\n        stargateTokenAddress = _stargateTokenAddress;\n    }\n\n    function validateProof(\n        bytes32 _packetHash,\n        bytes calldata _transactionProof,\n        uint _remoteAddressSize\n    ) external view override returns (LayerZeroPacket.Packet memory packet) {\n        require(_remoteAddressSize > 0, \"ProofLib: invalid address size\");\n        // _transactionProof = srcUlnAddress (32 bytes) + lzPacket\n        require(\n            _transactionProof.length > 32 && keccak256(_transactionProof) == _packetHash,\n            \"ProofLib: invalid transaction proof\"\n        );\n\n        bytes memory ulnAddressBytes = bytes(_transactionProof[0:32]);\n        bytes32 ulnAddress;\n        assembly {\n            ulnAddress := mload(add(ulnAddressBytes, 32))\n        }\n        packet = LayerZeroPacket.getPacketV3(_transactionProof[32:], _remoteAddressSize, ulnAddress);\n\n        if (packet.dstAddress == stargateBridgeAddress) packet.payload = _secureStgPayload(packet.payload);\n        if (packet.dstAddress == stargateTokenAddress) packet.payload = _secureStgTokenPayload(packet.payload);\n\n        return packet;\n    }\n\n    function _secureStgTokenPayload(bytes memory _payload) internal pure returns (bytes memory) {\n        (bytes memory toAddressBytes, uint qty) = abi.decode(_payload, (bytes, uint));\n\n        address toAddress = address(0);\n        if (toAddressBytes.length > 0) {\n            assembly {\n                toAddress := mload(add(toAddressBytes, 20))\n            }\n        }\n\n        if (toAddress == address(0)) {\n            address deadAddress = address(0x000000000000000000000000000000000000dEaD);\n            bytes memory newToAddressBytes = abi.encodePacked(deadAddress);\n            return abi.encode(newToAddressBytes, qty);\n        }\n\n        // default to return the original payload\n        return _payload;\n    }\n\n    function _secureStgPayload(bytes memory _payload) internal view returns (bytes memory) {\n        // functionType is uint8 even though the encoding will take up the side of uint256\n        uint8 functionType;\n        assembly {\n            functionType := mload(add(_payload, 32))\n        }\n\n        // TYPE_SWAP_REMOTE == 1 && only if the payload has a payload\n        // only swapRemote inside of stargate can call sgReceive on an user supplied to address\n        // thus we do not care about the other type functions even if the toAddress is overly long.\n        if (functionType == 1) {\n            // decode the _payload with its types\n            (\n                ,\n                uint srcPoolId,\n                uint dstPoolId,\n                uint dstGasForCall,\n                IStargate.CreditObj memory c,\n                IStargate.SwapObj memory s,\n                bytes memory toAddressBytes,\n                bytes memory contractCallPayload\n            ) = abi.decode(_payload, (uint8, uint, uint, uint, IStargate.CreditObj, IStargate.SwapObj, bytes, bytes));\n\n            // if contractCallPayload.length > 0 need to check if the to address is a contract or not\n            if (contractCallPayload.length > 0) {\n                // otherwise, need to check if the payload can be delivered to the toAddress\n                address toAddress = address(0);\n                if (toAddressBytes.length > 0) {\n                    assembly {\n                        toAddress := mload(add(toAddressBytes, 20))\n                    }\n                }\n\n                // check if the toAddress is a contract. We are not concerned about addresses that pretend to be wallets. because worst case we just delete their payload if being malicious\n                // we can guarantee that if a size > 0, then the contract is definitely a contract address in this context\n                uint size;\n                assembly {\n                    size := extcodesize(toAddress)\n                }\n\n                if (size == 0) {\n                    // size == 0 indicates its not a contract, payload wont be delivered\n                    // secure the _payload to make sure funds can be delivered to the toAddress\n                    bytes memory newToAddressBytes = abi.encodePacked(toAddress);\n                    bytes memory securePayload = abi.encode(\n                        functionType,\n                        srcPoolId,\n                        dstPoolId,\n                        dstGasForCall,\n                        c,\n                        s,\n                        newToAddressBytes,\n                        bytes(\"\")\n                    );\n                    return securePayload;\n                }\n            }\n        }\n\n        // default to return the original payload\n        return _payload;\n    }\n\n    function secureStgTokenPayload(bytes memory _payload) external pure returns (bytes memory) {\n        return _secureStgTokenPayload(_payload);\n    }\n\n    function secureStgPayload(bytes memory _payload) external view returns (bytes memory) {\n        return _secureStgPayload(_payload);\n    }\n\n    function getUtilsVersion() external view override returns (uint8) {\n        return utilsVersion;\n    }\n\n    function getProofType() external view override returns (uint8) {\n        return proofType;\n    }\n\n    function getVerifyLog(\n        bytes32,\n        uint[] calldata,\n        uint,\n        bytes[] calldata proof\n    ) external pure override returns (ULNLog memory log) {}\n\n    function getPacket(\n        bytes memory data,\n        uint sizeOfSrcAddress,\n        bytes32 ulnAddress\n    ) external pure override returns (LayerZeroPacket.Packet memory) {\n        return LayerZeroPacket.getPacketV3(data, sizeOfSrcAddress, ulnAddress);\n    }\n}\n"
    },
    "contracts/V1Contracts/contracts/interfaces/IContractOne.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.5.0;\n\nimport \"./ILayerZeroUserApplicationConfig.sol\";\n\ninterface IContractOne {\n    function setIt(uint x) external;\n}\n"
    },
    "contracts/V1Contracts/contracts/interfaces/ILayerZeroEndpoint.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.5.0;\n\nimport \"./ILayerZeroUserApplicationConfig.sol\";\n\ninterface ILayerZeroEndpoint is ILayerZeroUserApplicationConfig {\n    // @notice send a LayerZero message to the specified address at a LayerZero endpoint.\n    // @param _dstChainId - the destination chain identifier\n    // @param _destination - the address on destination chain (in bytes). address length/format may vary by chains\n    // @param _payload - a custom bytes payload to send to the destination contract\n    // @param _refundAddress - if the source transaction is cheaper than the amount of value passed, refund the additional amount to this address\n    // @param _zroPaymentAddress - the address of the ZRO token holder who would pay for the transaction\n    // @param _adapterParams - parameters for custom functionality. e.g. receive airdropped native gas from the relayer on destination\n    function send(\n        uint16 _dstChainId,\n        bytes calldata _destination,\n        bytes calldata _payload,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes calldata _adapterParams\n    ) external payable;\n\n    // @notice used by the messaging library to publish verified payload\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source contract (as bytes) at the source chain\n    // @param _dstAddress - the address on destination chain\n    // @param _nonce - the unbound message ordering nonce\n    // @param _gasLimit - the gas limit for external contract execution\n    // @param _payload - verified payload to send to the destination contract\n    function receivePayload(\n        uint16 _srcChainId,\n        bytes calldata _srcAddress,\n        address _dstAddress,\n        uint64 _nonce,\n        uint _gasLimit,\n        bytes calldata _payload\n    ) external;\n\n    // @notice get the inboundNonce of a receiver from a source chain which could be EVM or non-EVM chain\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    function getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (uint64);\n\n    // @notice get the outboundNonce from this source chain which, consequently, is always an EVM\n    // @param _srcAddress - the source chain contract address\n    function getOutboundNonce(uint16 _dstChainId, address _srcAddress) external view returns (uint64);\n\n    // @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\n    // @param _dstChainId - the destination chain identifier\n    // @param _userApplication - the user app address on this EVM chain\n    // @param _payload - the custom message to send over LayerZero\n    // @param _payInZRO - if false, user app pays the protocol fee in native token\n    // @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain\n    function estimateFees(\n        uint16 _dstChainId,\n        address _userApplication,\n        bytes calldata _payload,\n        bool _payInZRO,\n        bytes calldata _adapterParam\n    ) external view returns (uint nativeFee, uint zroFee);\n\n    // @notice get this Endpoint's immutable source identifier\n    function getChainId() external view returns (uint16);\n\n    // @notice the interface to retry failed message on this Endpoint destination\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    // @param _payload - the payload to be retried\n    function retryPayload(uint16 _srcChainId, bytes calldata _srcAddress, bytes calldata _payload) external;\n\n    // @notice query if any STORED payload (message blocking) at the endpoint.\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool);\n\n    // @notice query if the _libraryAddress is valid for sending msgs.\n    // @param _userApplication - the user app address on this EVM chain\n    function getSendLibraryAddress(address _userApplication) external view returns (address);\n\n    // @notice query if the _libraryAddress is valid for receiving msgs.\n    // @param _userApplication - the user app address on this EVM chain\n    function getReceiveLibraryAddress(address _userApplication) external view returns (address);\n\n    // @notice query if the non-reentrancy guard for send() is on\n    // @return true if the guard is on. false otherwise\n    function isSendingPayload() external view returns (bool);\n\n    // @notice query if the non-reentrancy guard for receive() is on\n    // @return true if the guard is on. false otherwise\n    function isReceivingPayload() external view returns (bool);\n\n    // @notice get the configuration of the LayerZero messaging library of the specified version\n    // @param _version - messaging library version\n    // @param _chainId - the chainId for the pending config change\n    // @param _userApplication - the contract address of the user application\n    // @param _configType - type of configuration. every messaging library has its own convention.\n    function getConfig(\n        uint16 _version,\n        uint16 _chainId,\n        address _userApplication,\n        uint _configType\n    ) external view returns (bytes memory);\n\n    // @notice get the send() LayerZero messaging library version\n    // @param _userApplication - the contract address of the user application\n    function getSendVersion(address _userApplication) external view returns (uint16);\n\n    // @notice get the lzReceive() LayerZero messaging library version\n    // @param _userApplication - the contract address of the user application\n    function getReceiveVersion(address _userApplication) external view returns (uint16);\n}\n"
    },
    "contracts/V1Contracts/contracts/interfaces/ILayerZeroMessagingLibrary.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.7.0;\n\nimport \"./ILayerZeroUserApplicationConfig.sol\";\n\ninterface ILayerZeroMessagingLibrary {\n    // send(), messages will be inflight.\n    function send(\n        address _userApplication,\n        uint64 _lastNonce,\n        uint16 _chainId,\n        bytes calldata _destination,\n        bytes calldata _payload,\n        address payable refundAddress,\n        address _zroPaymentAddress,\n        bytes calldata _adapterParams\n    ) external payable;\n\n    // estimate native fee at the send side\n    function estimateFees(\n        uint16 _chainId,\n        address _userApplication,\n        bytes calldata _payload,\n        bool _payInZRO,\n        bytes calldata _adapterParam\n    ) external view returns (uint nativeFee, uint zroFee);\n\n    //---------------------------------------------------------------------------\n    // setConfig / getConfig are User Application (UA) functions to specify Oracle, Relayer, blockConfirmations, libraryVersion\n    function setConfig(uint16 _chainId, address _userApplication, uint _configType, bytes calldata _config) external;\n\n    function getConfig(\n        uint16 _chainId,\n        address _userApplication,\n        uint _configType\n    ) external view returns (bytes memory);\n}\n"
    },
    "contracts/V1Contracts/contracts/interfaces/ILayerZeroMessagingLibraryV2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.7.0;\n\nimport \"./ILayerZeroUserApplicationConfig.sol\";\nimport \"./ILayerZeroMessagingLibrary.sol\";\n\ninterface ILayerZeroMessagingLibraryV2 is ILayerZeroMessagingLibrary {\n    function getOutboundNonce(uint16 _chainId, bytes calldata _path) external view returns (uint64);\n}\n"
    },
    "contracts/V1Contracts/contracts/interfaces/ILayerZeroOracle.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.7.0;\n\ninterface ILayerZeroOracle {\n    // @notice query the oracle price for relaying block information to the destination chain\n    // @param _dstChainId the destination endpoint identifier\n    // @param _outboundProofType the proof type identifier to specify the data to be relayed\n    function getPrice(uint16 _dstChainId, uint16 _outboundProofType) external view returns (uint price);\n\n    // @notice Ultra-Light Node notifies the Oracle of a new block information relaying request\n    // @param _dstChainId the destination endpoint identifier\n    // @param _outboundProofType the proof type identifier to specify the data to be relayed\n    // @param _outboundBlockConfirmations the number of source chain block confirmation needed\n    function notifyOracle(uint16 _dstChainId, uint16 _outboundProofType, uint64 _outboundBlockConfirmations) external;\n\n    // @notice query if the address is an approved actor for privileges like data submission and fee withdrawal etc.\n    // @param _address the address to be checked\n    function isApproved(address _address) external view returns (bool approved);\n}\n"
    },
    "contracts/V1Contracts/contracts/interfaces/ILayerZeroOracleV2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.7.0;\n\ninterface ILayerZeroOracleV2 {\n    // @notice query price and assign jobs at the same time\n    // @param _dstChainId - the destination endpoint identifier\n    // @param _outboundProofType - the proof type identifier to specify proof to be relayed\n    // @param _outboundBlockConfirmation - block confirmation delay before relaying blocks\n    // @param _userApplication - the source sending contract address\n    function assignJob(\n        uint16 _dstChainId,\n        uint16 _outboundProofType,\n        uint64 _outboundBlockConfirmation,\n        address _userApplication\n    ) external returns (uint price);\n\n    // @notice query the oracle price for relaying block information to the destination chain\n    // @param _dstChainId the destination endpoint identifier\n    // @param _outboundProofType the proof type identifier to specify the data to be relayed\n    // @param _outboundBlockConfirmation - block confirmation delay before relaying blocks\n    // @param _userApplication - the source sending contract address\n    function getFee(\n        uint16 _dstChainId,\n        uint16 _outboundProofType,\n        uint64 _outboundBlockConfirmation,\n        address _userApplication\n    ) external view returns (uint price);\n\n    // @notice withdraw the accrued fee in ultra light node\n    // @param _to - the fee receiver\n    // @param _amount - the withdrawal amount\n    function withdrawFee(address payable _to, uint _amount) external;\n}\n"
    },
    "contracts/V1Contracts/contracts/interfaces/ILayerZeroPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.7.0;\npragma abicoder v2;\n\ninterface ILayerZeroPriceFeed {\n    /**\n     * @dev\n     * priceRatio: (USD price of 1 unit of remote native token in unit of local native token) * PRICE_RATIO_DENOMINATOR\n     */\n\n    struct Price {\n        uint128 priceRatio; // float value * 10 ^ 10, decimal awared. for aptos to evm, the basis would be (10^18 / 10^8) * 10 ^10 = 10 ^ 20.\n        uint64 gasPriceInUnit; // for evm, it is in wei, for aptos, it is in octas.\n        uint32 gasPerByte;\n    }\n\n    struct UpdatePrice {\n        uint16 chainId;\n        Price price;\n    }\n\n    /**\n     * @dev\n     *    ArbGasInfo.go:GetPricesInArbGas\n     *\n     */\n    struct ArbitrumPriceExt {\n        uint64 gasPerL2Tx; // L2 overhead\n        uint32 gasPerL1CallDataByte;\n    }\n\n    struct UpdatePriceExt {\n        uint16 chainId;\n        Price price;\n        ArbitrumPriceExt extend;\n    }\n\n    function getPrice(uint16 _dstChainId) external view returns (Price memory);\n\n    function getPriceRatioDenominator() external view returns (uint128);\n\n    function estimateFeeByChain(\n        uint16 _dstChainId,\n        uint _callDataSize,\n        uint _gas\n    ) external view returns (uint fee, uint128 priceRatio);\n\n    function nativeTokenPriceUSD() external view returns (uint128);\n}\n"
    },
    "contracts/V1Contracts/contracts/interfaces/ILayerZeroPriceFeedV2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.7.0;\npragma abicoder v2;\n\n// copy of \"@layerzerolabs/lz-evm-messagelib-v2/contracts/interfaces/ILayerZeroPriceFeed.sol\"\ninterface ILayerZeroPriceFeedV2 {\n    /**\n     * @dev\n     * priceRatio: (USD price of 1 unit of remote native token in unit of local native token) * PRICE_RATIO_DENOMINATOR\n     */\n\n    struct Price {\n        uint128 priceRatio; // float value * 10 ^ 20, decimal awared. for aptos to evm, the basis would be (10^18 / 10^8) * 10 ^20 = 10 ^ 30.\n        uint64 gasPriceInUnit; // for evm, it is in wei, for aptos, it is in octas.\n        uint32 gasPerByte;\n    }\n\n    struct UpdatePrice {\n        uint32 eid;\n        Price price;\n    }\n\n    /**\n     * @dev\n     *    ArbGasInfo.go:GetPricesInArbGas\n     *\n     */\n    struct ArbitrumPriceExt {\n        uint64 gasPerL2Tx; // L2 overhead\n        uint32 gasPerL1CallDataByte;\n    }\n\n    struct UpdatePriceExt {\n        uint32 eid;\n        Price price;\n        ArbitrumPriceExt extend;\n    }\n\n    function getPrice(uint32 _dstEid) external view returns (Price memory);\n\n    function getPriceRatioDenominator() external view returns (uint128);\n\n    function estimateFeeByEid(\n        uint32 _dstEid,\n        uint _callDataSize,\n        uint _gas\n    ) external view returns (uint fee, uint128 priceRatio, uint128 priceRatioDenominator, uint128 nativePriceUSD);\n}\n"
    },
    "contracts/V1Contracts/contracts/interfaces/ILayerZeroReceiver.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.5.0;\n\ninterface ILayerZeroReceiver {\n    // @notice LayerZero endpoint will invoke this function to deliver the message on the destination\n    // @param _srcChainId - the source endpoint identifier\n    // @param _srcAddress - the source sending contract address from the source chain\n    // @param _nonce - the ordered message nonce\n    // @param _payload - the signed payload is the UA bytes has encoded to be sent\n    function lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) external;\n}\n"
    },
    "contracts/V1Contracts/contracts/interfaces/ILayerZeroRelayer.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.7.0;\n\ninterface ILayerZeroRelayer {\n    // @notice query the relayer price for relaying the payload and its proof to the destination chain\n    // @param _dstChainId - the destination endpoint identifier\n    // @param _outboundProofType - the proof type identifier to specify proof to be relayed\n    // @param _userApplication - the source sending contract address. relayers may apply price discrimination to user apps\n    // @param _payloadSize - the length of the payload. it is an indicator of gas usage for relaying cross-chain messages\n    // @param _adapterParams - optional parameters for extra service plugins, e.g. sending dust tokens at the destination chain\n    function getPrice(\n        uint16 _dstChainId,\n        uint16 _outboundProofType,\n        address _userApplication,\n        uint _payloadSize,\n        bytes calldata _adapterParams\n    ) external view returns (uint price);\n\n    // @notice Ultra-Light Node notifies the Oracle of a new block information relaying request\n    // @param _dstChainId - the destination endpoint identifier\n    // @param _outboundProofType - the proof type identifier to specify the data to be relayed\n    // @param _adapterParams - optional parameters for extra service plugins, e.g. sending dust tokens at the destination chain\n    function notifyRelayer(uint16 _dstChainId, uint16 _outboundProofType, bytes calldata _adapterParams) external;\n\n    // @notice query if the address is an approved actor for privileges like data submission and fee withdrawal etc.\n    // @param _address - the address to be checked\n    function isApproved(address _address) external view returns (bool approved);\n}\n"
    },
    "contracts/V1Contracts/contracts/interfaces/ILayerZeroRelayerV2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.7.0;\n\ninterface ILayerZeroRelayerV2 {\n    // @notice query price and assign jobs at the same time\n    // @param _dstChainId - the destination endpoint identifier\n    // @param _outboundProofType - the proof type identifier to specify proof to be relayed\n    // @param _userApplication - the source sending contract address. relayers may apply price discrimination to user apps\n    // @param _payloadSize - the length of the payload. it is an indicator of gas usage for relaying cross-chain messages\n    // @param _adapterParams - optional parameters for extra service plugins, e.g. sending dust tokens at the destination chain\n    function assignJob(\n        uint16 _dstChainId,\n        uint16 _outboundProofType,\n        address _userApplication,\n        uint _payloadSize,\n        bytes calldata _adapterParams\n    ) external returns (uint price);\n\n    // @notice query the relayer price for relaying the payload and its proof to the destination chain\n    // @param _dstChainId - the destination endpoint identifier\n    // @param _outboundProofType - the proof type identifier to specify proof to be relayed\n    // @param _userApplication - the source sending contract address. relayers may apply price discrimination to user apps\n    // @param _payloadSize - the length of the payload. it is an indicator of gas usage for relaying cross-chain messages\n    // @param _adapterParams - optional parameters for extra service plugins, e.g. sending dust tokens at the destination chain\n    function getFee(\n        uint16 _dstChainId,\n        uint16 _outboundProofType,\n        address _userApplication,\n        uint _payloadSize,\n        bytes calldata _adapterParams\n    ) external view returns (uint price);\n\n    // @notice withdraw the accrued fee in ultra light node\n    // @param _to - the fee receiver\n    // @param _amount - the withdrawal amount\n    function withdrawFee(address payable _to, uint _amount) external;\n}\n"
    },
    "contracts/V1Contracts/contracts/interfaces/ILayerZeroRelayerV2PriceData.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.7.0;\n\npragma abicoder v2;\n\ninterface ILayerZeroRelayerV2PriceData {\n    struct DstPrice {\n        uint128 dstPriceRatio; // 10^10\n        uint128 dstGasPriceInWei;\n    }\n\n    struct DstConfig {\n        uint128 dstNativeAmtCap;\n        uint64 baseGas;\n        uint64 gasPerByte;\n    }\n\n    function dstPriceLookup(uint16 _chainId) external view returns (DstPrice memory);\n\n    function dstConfigLookup(uint16 _chainId, uint16 _outboundProofType) external view returns (DstConfig memory);\n}\n"
    },
    "contracts/V1Contracts/contracts/interfaces/ILayerZeroTreasury.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.5.0;\n\ninterface ILayerZeroTreasury {\n    function getFees(bool payInZro, uint relayerFee, uint oracleFee) external view returns (uint);\n}\n"
    },
    "contracts/V1Contracts/contracts/interfaces/ILayerZeroUltraLightNodeV1.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.7.0;\n\ninterface ILayerZeroUltraLightNodeV1 {\n    // a Relayer can execute the validateTransactionProof()\n    function validateTransactionProof(\n        uint16 _srcChainId,\n        address _dstAddress,\n        uint _gasLimit,\n        bytes32 _lookupHash,\n        bytes calldata _transactionProof\n    ) external;\n\n    // an Oracle delivers the block data using updateHash()\n    function updateHash(uint16 _remoteChainId, bytes32 _lookupHash, uint _confirmations, bytes32 _data) external;\n\n    // can only withdraw the receivable of the msg.sender\n    function withdrawNative(uint8 _type, address _owner, address payable _to, uint _amount) external;\n\n    function withdrawZRO(address _to, uint _amount) external;\n\n    // view functions\n    function oracleQuotedAmount(address _oracle) external view returns (uint);\n\n    function relayerQuotedAmount(address _relayer) external view returns (uint);\n}\n"
    },
    "contracts/V1Contracts/contracts/interfaces/ILayerZeroUltraLightNodeV2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.7.0;\npragma abicoder v2;\n\ninterface ILayerZeroUltraLightNodeV2 {\n    // Relayer functions\n    function validateTransactionProof(\n        uint16 _srcChainId,\n        address _dstAddress,\n        uint _gasLimit,\n        bytes32 _lookupHash,\n        bytes32 _blockData,\n        bytes calldata _transactionProof\n    ) external;\n\n    // an Oracle delivers the block data using updateHash()\n    function updateHash(uint16 _srcChainId, bytes32 _lookupHash, uint _confirmations, bytes32 _blockData) external;\n\n    // can only withdraw the receivable of the msg.sender\n    function withdrawNative(address payable _to, uint _amount) external;\n\n    function withdrawZRO(address _to, uint _amount) external;\n\n    // view functions\n    function getAppConfig(\n        uint16 _remoteChainId,\n        address _userApplicationAddress\n    ) external view returns (ApplicationConfiguration memory);\n\n    function accruedNativeFee(address _address) external view returns (uint);\n\n    struct ApplicationConfiguration {\n        uint16 inboundProofLibraryVersion;\n        uint64 inboundBlockConfirmations;\n        address relayer;\n        uint16 outboundProofType;\n        uint64 outboundBlockConfirmations;\n        address oracle;\n    }\n\n    event HashReceived(\n        uint16 indexed srcChainId,\n        address indexed oracle,\n        bytes32 lookupHash,\n        bytes32 blockData,\n        uint confirmations\n    );\n    event RelayerParams(bytes adapterParams, uint16 outboundProofType);\n    event Packet(bytes payload);\n    event InvalidDst(\n        uint16 indexed srcChainId,\n        bytes srcAddress,\n        address indexed dstAddress,\n        uint64 nonce,\n        bytes32 payloadHash\n    );\n    event PacketReceived(\n        uint16 indexed srcChainId,\n        bytes srcAddress,\n        address indexed dstAddress,\n        uint64 nonce,\n        bytes32 payloadHash\n    );\n    event AppConfigUpdated(address indexed userApplication, uint indexed configType, bytes newConfig);\n    event AddInboundProofLibraryForChain(uint16 indexed chainId, address lib);\n    event EnableSupportedOutboundProof(uint16 indexed chainId, uint16 proofType);\n    event SetChainAddressSize(uint16 indexed chainId, uint size);\n    event SetDefaultConfigForChainId(\n        uint16 indexed chainId,\n        uint16 inboundProofLib,\n        uint64 inboundBlockConfirm,\n        address relayer,\n        uint16 outboundProofType,\n        uint64 outboundBlockConfirm,\n        address oracle\n    );\n    event SetDefaultAdapterParamsForChainId(uint16 indexed chainId, uint16 indexed proofType, bytes adapterParams);\n    event SetLayerZeroToken(address indexed tokenAddress);\n    event SetRemoteUln(uint16 indexed chainId, bytes32 uln);\n    event SetTreasury(address indexed treasuryAddress);\n    event WithdrawZRO(address indexed msgSender, address indexed to, uint amount);\n    event WithdrawNative(address indexed msgSender, address indexed to, uint amount);\n}\n"
    },
    "contracts/V1Contracts/contracts/interfaces/ILayerZeroUserApplicationConfig.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.5.0;\n\ninterface ILayerZeroUserApplicationConfig {\n    // @notice set the configuration of the LayerZero messaging library of the specified version\n    // @param _version - messaging library version\n    // @param _chainId - the chainId for the pending config change\n    // @param _configType - type of configuration. every messaging library has its own convention.\n    // @param _config - configuration in the bytes. can encode arbitrary content.\n    function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external;\n\n    // @notice set the send() LayerZero messaging library version to _version\n    // @param _version - new messaging library version\n    function setSendVersion(uint16 _version) external;\n\n    // @notice set the lzReceive() LayerZero messaging library version to _version\n    // @param _version - new messaging library version\n    function setReceiveVersion(uint16 _version) external;\n\n    // @notice Only when the UA needs to resume the message flow in blocking mode and clear the stored payload\n    // @param _srcChainId - the chainId of the source chain\n    // @param _srcAddress - the contract address of the source contract at the source chain\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external;\n}\n"
    },
    "contracts/V1Contracts/contracts/interfaces/ILayerZeroValidationLibrary.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.7.0;\npragma abicoder v2;\n\nimport \"../proof/utility/LayerZeroPacket.sol\";\n\ninterface ILayerZeroValidationLibrary {\n    function validateProof(\n        bytes32 blockData,\n        bytes calldata _data,\n        uint _remoteAddressSize\n    ) external returns (LayerZeroPacket.Packet memory packet);\n}\n"
    },
    "contracts/V1Contracts/contracts/interfaces/IValidationLibraryHelper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.7.0;\npragma abicoder v2;\n\nimport \"../proof/utility/LayerZeroPacket.sol\";\nimport \"./ILayerZeroValidationLibrary.sol\";\n\ninterface IValidationLibraryHelper {\n    struct ULNLog {\n        bytes32 contractAddress;\n        bytes32 topicZeroSig;\n        bytes data;\n    }\n\n    function getVerifyLog(\n        bytes32 hashRoot,\n        uint[] memory receiptSlotIndex,\n        uint logIndex,\n        bytes[] memory proof\n    ) external pure returns (ULNLog memory);\n\n    function getPacket(\n        bytes memory data,\n        uint16 srcChain,\n        uint sizeOfSrcAddress,\n        bytes32 ulnAddress\n    ) external pure returns (LayerZeroPacket.Packet memory);\n\n    function getUtilsVersion() external view returns (uint8);\n}\n"
    },
    "contracts/V1Contracts/contracts/interfaces/IValidationLibraryHelperV2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.7.0;\npragma abicoder v2;\n\nimport \"../proof/utility/LayerZeroPacket.sol\";\n\ninterface IValidationLibraryHelperV2 {\n    struct ULNLog {\n        bytes32 contractAddress;\n        bytes32 topicZeroSig;\n        bytes data;\n    }\n\n    function getVerifyLog(\n        bytes32 hashRoot,\n        uint[] calldata receiptSlotIndex,\n        uint logIndex,\n        bytes[] calldata proof\n    ) external pure returns (ULNLog memory);\n\n    function getPacket(\n        bytes calldata data,\n        uint sizeOfSrcAddress,\n        bytes32 ulnAddress\n    ) external pure returns (LayerZeroPacket.Packet memory);\n\n    function getUtilsVersion() external view returns (uint8);\n\n    function getProofType() external view returns (uint8);\n}\n"
    },
    "contracts/V1Contracts/contracts/libs/RateLimiter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Copyright 2023 LayerZero Labs Ltd.\n// You may obtain a copy of the License at\n// https://github.com/LayerZero-Labs/license/blob/main/LICENSE-LZBL-1.1\n\npragma solidity ^0.7.6;\n\nlibrary RateLimiter {\n    struct Info {\n        // capacity of the token bucket. This is the maximum number of tokens that the bucket can hold at any given time\n        uint64 capacity;\n        // current number of tokens in the bucket\n        uint64 tokens;\n        // number of tokens refilled per second\n        uint64 rate;\n        // timestamp of last refill\n        uint64 lastRefillTime;\n    }\n\n    function setCapacity(Info storage _self, uint64 _capacity) internal {\n        _self.capacity = _capacity;\n        _self.tokens = _capacity;\n        _self.lastRefillTime = uint64(block.timestamp);\n    }\n\n    function setRate(Info storage _self, uint64 _rate) internal {\n        refill(_self, 0);\n        _self.rate = _rate;\n    }\n\n    function tryConsume(Info storage _self, uint64 _amount) internal returns (uint64) {\n        refill(_self, 0);\n\n        uint64 tokens = _self.tokens;\n        require(tokens >= _amount, \"RelayerV2: out of counters - try again later!\");\n\n        uint64 newTokens = tokens - _amount;\n        _self.tokens = newTokens;\n        return newTokens;\n    }\n\n    function refill(Info storage _self, uint64 _extraTokens) internal {\n        uint newTokens = _extraTokens;\n\n        uint64 currentTime = uint64(block.timestamp);\n        if (currentTime > _self.lastRefillTime) {\n            uint timeElapsedInSeconds = currentTime - _self.lastRefillTime;\n            newTokens += timeElapsedInSeconds * _self.rate;\n        }\n\n        if (newTokens > 0) {\n            newTokens += _self.tokens;\n            _self.tokens = newTokens > _self.capacity ? _self.capacity : uint64(newTokens);\n        }\n\n        _self.lastRefillTime = currentTime;\n    }\n}\n"
    },
    "contracts/V1Contracts/contracts/mocks/ContractTwo.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.7.6;\n\nimport \"../interfaces/IContractOne.sol\";\n\ncontract ContractTwo {\n    address contractOne;\n\n    constructor(address _contractOne) {\n        contractOne = _contractOne;\n    }\n\n    function callSetIt(uint _gasLimit) external {\n        IContractOne(contractOne).setIt{gas: _gasLimit}(1);\n    }\n}\n"
    },
    "contracts/V1Contracts/contracts/mocks/GIN.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.7.6;\npragma abicoder v2;\nimport \"../interfaces/ILayerZeroReceiver.sol\";\nimport \"../interfaces/ILayerZeroEndpoint.sol\";\n\ncontract GIN is ILayerZeroReceiver {\n    bool public messageComplete;\n    ILayerZeroEndpoint public endpoint;\n\n    event Message(bytes32 indexed message);\n\n    constructor(address _endpoint) {\n        endpoint = ILayerZeroEndpoint(_endpoint);\n    }\n\n    function lzReceive(uint16, bytes memory /*_fromAddress*/, uint64, bytes memory _payload) external override {\n        require(msg.sender == address(endpoint));\n        bytes32 message;\n        assembly {\n            message := mload(add(_payload, 32))\n        }\n        emit Message(message);\n        messageComplete = true;\n    }\n\n    function sendFirstMessage(\n        uint gasAmountForDst,\n        uint16[] calldata chainIds,\n        bytes[] calldata dstAddresses\n    ) external payable {\n        require(!messageComplete, \"The first message of LayerZero has already been sent\");\n        uint16 version = 1;\n        bytes memory _relayerParams = abi.encodePacked(version, gasAmountForDst);\n\n        bytes32 message = \"GIN\";\n        bytes memory messageString = bytes(abi.encodePacked(message));\n        uint length = chainIds.length;\n        uint fee = msg.value / length;\n        for (uint i = 0; i < length; i++) {\n            endpoint.send{value: fee}(\n                chainIds[i],\n                dstAddresses[i],\n                messageString,\n                msg.sender,\n                address(0x0),\n                _relayerParams\n            );\n        }\n    }\n}\n"
    },
    "contracts/V1Contracts/contracts/mocks/LayerZeroOracleBadMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../interfaces/ILayerZeroOracle.sol\";\nimport \"../interfaces/ILayerZeroUltraLightNodeV1.sol\";\nimport \"../interfaces/ILayerZeroEndpoint.sol\";\n\n// mock is designed to try and send the msg it just received again to trigger a revert\ncontract LayerZeroOracleBadMock is ILayerZeroOracle, Ownable, ReentrancyGuard {\n    mapping(address => bool) public approvedAddresses;\n    mapping(uint16 => mapping(uint16 => uint)) public chainPriceLookup;\n    uint public fee;\n    ILayerZeroUltraLightNodeV1 public uln; // ultraLightNode instance\n    ILayerZeroEndpoint public endpoint; // for bad oracles trying to talk to endpoint\n\n    event OracleNotified(uint16 dstChainId, uint16 _outboundProofType, uint blockConfirmations);\n    event Withdraw(address to, uint amount);\n\n    constructor() {\n        approvedAddresses[msg.sender] = true;\n    }\n\n    function notifyOracle(\n        uint16 _dstChainId,\n        uint16 _outboundProofType,\n        uint64 _outboundBlockConfirmations\n    ) external override {\n        // oracle is set to do bad things and try to call send again, this should revert\n        endpoint.send(_dstChainId, \"0x\", \"0x\", address(0), address(0), \"0x\");\n        emit OracleNotified(_dstChainId, _outboundProofType, _outboundBlockConfirmations);\n    }\n\n    function updateHash(uint16 _remoteChainId, bytes32 _blockHash, uint _confirmations, bytes32 _data) external {\n        require(approvedAddresses[msg.sender], \"LayerZeroOracleMock: caller must be approved\");\n        uln.updateHash(_remoteChainId, _blockHash, _confirmations, _data);\n    }\n\n    function withdraw(address payable _to, uint _amount) public onlyOwner nonReentrant {\n        (bool success, ) = _to.call{value: _amount}(\"\");\n        require(success, \"failed to withdraw\");\n        emit Withdraw(_to, _amount);\n    }\n\n    // owner can set uln\n    function setUln(address ulnAddress) external onlyOwner {\n        uln = ILayerZeroUltraLightNodeV1(ulnAddress);\n    }\n\n    // owner can set uln\n    function setEndpoint(address endpointAddress) external onlyOwner {\n        endpoint = ILayerZeroEndpoint(endpointAddress);\n    }\n\n    // mock, doesnt do anything\n    function setJob(uint16 _chain, address _oracle, bytes32 _id, uint _fee) public onlyOwner {}\n\n    // mocked for now\n    function assignJob(\n        uint16 _dstChainId,\n        uint16 /*_outboundProofType*/,\n        uint64 /*_outboundBlockConfirmation*/,\n        address\n    ) external returns (uint price) {\n        // oracle is set to do bad things and try to call send again, this should revert\n        endpoint.send(_dstChainId, \"0x\", \"0x\", address(0), address(0), \"0x\");\n        return 1;\n    }\n\n    function setDeliveryAddress(uint16 _dstChainId, address _deliveryAddress) public onlyOwner {}\n\n    function setPrice(uint16 _destinationChainId, uint16 _outboundProofType, uint _price) external onlyOwner {\n        chainPriceLookup[_outboundProofType][_destinationChainId] = _price;\n    }\n\n    function setApprovedAddress(address _oracleAddress, bool _approve) external {\n        approvedAddresses[_oracleAddress] = _approve;\n    }\n\n    function isApproved(address _relayerAddress) public view override returns (bool) {\n        return approvedAddresses[_relayerAddress];\n    }\n\n    function getPrice(uint16 _destinationChainId, uint16 _outboundProofType) external view override returns (uint) {\n        return chainPriceLookup[_outboundProofType][_destinationChainId];\n    }\n\n    fallback() external payable {}\n\n    receive() external payable {}\n}\n"
    },
    "contracts/V1Contracts/contracts/mocks/LayerZeroOracleMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../interfaces/ILayerZeroOracle.sol\";\nimport \"../interfaces/ILayerZeroUltraLightNodeV1.sol\";\n\ncontract LayerZeroOracleMock is ILayerZeroOracle, Ownable, ReentrancyGuard {\n    mapping(address => bool) public approvedAddresses;\n    mapping(uint16 => mapping(uint16 => uint)) public chainPriceLookup;\n    uint public fee;\n    ILayerZeroUltraLightNodeV1 public uln; // ultraLightNode instance\n\n    event OracleNotified(uint16 dstChainId, uint16 _outboundProofType, uint blockConfirmations);\n    event Withdraw(address to, uint amount);\n\n    constructor() {\n        approvedAddresses[msg.sender] = true;\n    }\n\n    function notifyOracle(\n        uint16 _dstChainId,\n        uint16 _outboundProofType,\n        uint64 _outboundBlockConfirmations\n    ) external override {\n        emit OracleNotified(_dstChainId, _outboundProofType, _outboundBlockConfirmations);\n    }\n\n    function updateHash(uint16 _remoteChainId, bytes32 _blockHash, uint _confirmations, bytes32 _data) external {\n        require(approvedAddresses[msg.sender], \"LayerZeroOracleMock: caller must be approved\");\n        uln.updateHash(_remoteChainId, _blockHash, _confirmations, _data);\n    }\n\n    function withdraw(address payable _to, uint _amount) public onlyOwner nonReentrant {\n        (bool success, ) = _to.call{value: _amount}(\"\");\n        require(success, \"failed to withdraw\");\n        emit Withdraw(_to, _amount);\n    }\n\n    // owner can set uln\n    function setUln(address ulnAddress) external onlyOwner {\n        uln = ILayerZeroUltraLightNodeV1(ulnAddress);\n    }\n\n    // mock, doesnt do anything\n    function setJob(uint16 _chain, address _oracle, bytes32 _id, uint _fee) public onlyOwner {}\n\n    function setDeliveryAddress(uint16 _dstChainId, address _deliveryAddress) public onlyOwner {}\n\n    function setPrice(uint16 _destinationChainId, uint16 _outboundProofType, uint _price) external onlyOwner {\n        chainPriceLookup[_outboundProofType][_destinationChainId] = _price;\n    }\n\n    function setApprovedAddress(address _oracleAddress, bool _approve) external {\n        approvedAddresses[_oracleAddress] = _approve;\n    }\n\n    function isApproved(address _relayerAddress) public view override returns (bool) {\n        return approvedAddresses[_relayerAddress];\n    }\n\n    function getPrice(uint16 _destinationChainId, uint16 _outboundProofType) external view override returns (uint) {\n        return chainPriceLookup[_outboundProofType][_destinationChainId];\n    }\n\n    fallback() external payable {}\n\n    receive() external payable {}\n}\n"
    },
    "contracts/V1Contracts/contracts/mocks/LayerZeroOracleMockV2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../interfaces/ILayerZeroOracleV2.sol\";\nimport \"../interfaces/ILayerZeroUltraLightNodeV2.sol\";\n\ncontract LayerZeroOracleMockV2 is ILayerZeroOracleV2, Ownable, ReentrancyGuard {\n    mapping(address => bool) public approvedAddresses;\n    mapping(uint16 => mapping(uint16 => uint)) public chainPriceLookup;\n    mapping(uint16 => mapping(uint16 => uint64)) public jobs; // mocked, not used for anything yet\n    uint public fee;\n    ILayerZeroUltraLightNodeV2 public uln; // ultraLightNode instance\n\n    event OracleNotified(uint16 dstChainId, uint16 _outboundProofType, uint blockConfirmations);\n    event Withdraw(address to, uint amount);\n\n    constructor() {\n        approvedAddresses[msg.sender] = true;\n    }\n\n    // mocked for now, will auto accept the job, and return the price at the same time\n    function assignJob(\n        uint16 _dstChainId,\n        uint16 _outboundProofType,\n        uint64 _outboundBlockConfirmation,\n        address\n    ) external override returns (uint price) {\n        jobs[_dstChainId][_outboundProofType] = _outboundBlockConfirmation;\n        return chainPriceLookup[_outboundProofType][_dstChainId];\n    }\n\n    function getFee(\n        uint16 _dstChainId,\n        uint16 _outboundProofType,\n        uint64 /*_outboundBlockConfirmation*/,\n        address\n    ) external view override returns (uint) {\n        return chainPriceLookup[_outboundProofType][_dstChainId];\n    }\n\n    function withdrawFee(address payable _to, uint _amount) public override onlyOwner nonReentrant {\n        (bool success, ) = _to.call{value: _amount}(\"\");\n        require(success, \"failed to withdraw\");\n        emit Withdraw(_to, _amount);\n    }\n\n    function updateHash(uint16 _remoteChainId, bytes32 _blockHash, uint _confirmations, bytes32 _data) external {\n        require(approvedAddresses[msg.sender], \"LayerZeroOracleMock: caller must be approved\");\n        uln.updateHash(_remoteChainId, _blockHash, _confirmations, _data);\n    }\n\n    function setUln(address ulnAddress) external onlyOwner {\n        uln = ILayerZeroUltraLightNodeV2(ulnAddress);\n    }\n\n    function setDeliveryAddress(uint16 _dstChainId, address _deliveryAddress) public onlyOwner {}\n\n    function setPrice(uint16 _destinationChainId, uint16 _outboundProofType, uint _price) external onlyOwner {\n        chainPriceLookup[_outboundProofType][_destinationChainId] = _price;\n    }\n\n    function setApprovedAddress(address _oracleAddress, bool _approve) external {\n        approvedAddresses[_oracleAddress] = _approve;\n    }\n\n    function isApproved(address _relayerAddress) public view returns (bool) {\n        return approvedAddresses[_relayerAddress];\n    }\n\n    fallback() external payable {}\n\n    receive() external payable {}\n}\n"
    },
    "contracts/V1Contracts/contracts/mocks/LayerZeroTokenMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract LayerZeroTokenMock is ERC20 {\n    constructor() ERC20(\"LayerZeroTokenMock\", \"LZTM\") {\n        _mint(msg.sender, 1_000_000 * 10 ** 18);\n    }\n}\n"
    },
    "contracts/V1Contracts/contracts/mocks/MockToken.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n// this is a MOCK\ncontract MockToken is ERC20 {\n    // this is a MOCK\n    constructor(string memory name_, string memory symbol_) ERC20(name_, symbol_) {\n        _mint(msg.sender, 1000000000000000000000);\n    }\n\n    // this is a MOCK\n    function mint(address _to, uint _amount) public {\n        _mint(_to, _amount);\n    }\n\n    //Mocked to imitate what happens if a transfer fails\n    function transfer(address recipient, uint amount) public virtual override returns (bool) {\n        require(recipient != address(0x1));\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n}\n"
    },
    "contracts/V1Contracts/contracts/mocks/OmniCounter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.7.6;\npragma abicoder v2;\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";import \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../interfaces/ILayerZeroReceiver.sol\";\nimport \"../interfaces/ILayerZeroEndpoint.sol\";\nimport \"../interfaces/ILayerZeroUserApplicationConfig.sol\";\nimport \"../Relayer.sol\";\n\ncontract OmniCounter is Ownable, ILayerZeroReceiver, ILayerZeroUserApplicationConfig {\n    using SafeMath for uint;\n\n    // keep track of how many messages have been received from other chains\n    uint public messageCounter;\n    mapping(address => uint) public remoteAddressCounter;\n    // required: the LayerZero endpoint which is passed in the constructor\n    ILayerZeroEndpoint public endpoint;\n    bool public payInZRO;\n\n    mapping(uint16 => bytes) public trustedRemoteLookup;\n\n    constructor(address _endpoint) {\n        endpoint = ILayerZeroEndpoint(_endpoint);\n    }\n\n    function getCounter() public view returns (uint) {\n        return messageCounter;\n    }\n\n    // overrides lzReceive function in ILayerZeroReceiver.\n    // automatically invoked on the receiving chain after the source chain calls endpoint.send(...)\n    function lzReceive(\n        uint16 _srcChainId,\n        bytes memory _fromAddress,\n        uint64 /*_nonce*/,\n        bytes memory _payload\n    ) external virtual override {\n        require(msg.sender == address(endpoint));\n        _verifySourceAddress(_srcChainId, _fromAddress);\n\n        address fromAddress;\n        assembly {\n            fromAddress := mload(add(_fromAddress, 20))\n        }\n\n        // used for testing reentrant, retry sending the payload through the relayer before the initial receive has been resolved\n        // ff == '0x6666' on the payload side\n        if (\n            keccak256(abi.encodePacked((_payload))) == keccak256(abi.encodePacked((bytes2(\"ff\")))) ||\n            keccak256(abi.encodePacked((_payload))) == keccak256(abi.encodePacked((bytes10(\"ff\"))))\n        ) {\n            endpoint.receivePayload(1, bytes(\"\"), address(0x0), 1, 1, bytes(\"\"));\n        }\n\n        remoteAddressCounter[fromAddress] += 1;\n        messageCounter += 1;\n    }\n\n    function incrementCounter(\n        uint16 _dstChainId,\n        bytes calldata _adapterParams,\n        bytes calldata payload\n    ) public payable {\n        address zroPaymentAddress = payInZRO ? address(this) : address(0x0);\n        _incrementCounter(_dstChainId, payload, msg.sender, zroPaymentAddress, _adapterParams);\n    }\n\n    // call send() to multiple destinations in the same transaction!\n    function multiIncrementCounter(\n        uint16[] calldata _dstChainIds,\n        bytes calldata _adapterParams,\n        bytes calldata payload\n    ) public payable {\n        // send() each chainId + dst address pair\n        uint16[] memory dstChainIds = _dstChainIds;\n        bytes memory adapterParams = _adapterParams;\n\n        uint _refund = msg.value;\n        // send() each chainId + dst address pair\n        for (uint i = 0; i < dstChainIds.length; ++i) {\n            (uint valueToSend, ) = endpoint.estimateFees(\n                dstChainIds[i],\n                address(this),\n                payload,\n                payInZRO,\n                adapterParams\n            );\n            _refund = _refund.sub(valueToSend);\n            // a Communicator.sol instance is the 'endpoint'\n            // .send() each payload to the destination chainId + UA destination address\n            address zroPaymentAddress = payInZRO ? address(this) : address(0x0);\n            _incrementCounter(_dstChainIds[i], payload, msg.sender, zroPaymentAddress, adapterParams);\n        }\n        // refund eth if too much was sent into this contract call\n        msg.sender.transfer(_refund);\n    }\n\n    function _incrementCounter(\n        uint16 _dstChainId,\n        bytes memory _payload,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes memory _adapterParams\n    ) public payable {\n        bytes memory trustedRemote = trustedRemoteLookup[_dstChainId];\n        require(trustedRemote.length > 0, \"*** trustedRemote cant be 0x \");\n        endpoint.send{value: msg.value}(\n            _dstChainId,\n            trustedRemote,\n            _payload,\n            _refundAddress,\n            _zroPaymentAddress,\n            _adapterParams\n        );\n    }\n\n    function setConfig(\n        uint16 /*_version*/,\n        uint16 _chainId,\n        uint _configType,\n        bytes calldata _config\n    ) external override {\n        endpoint.setConfig(endpoint.getSendVersion(address(this)), _chainId, _configType, _config);\n    }\n\n    function getConfig(uint16, uint16 _chainId, address, uint _configType) external view returns (bytes memory) {\n        return endpoint.getConfig(endpoint.getSendVersion(address(this)), _chainId, address(this), _configType);\n    }\n\n    function setSendVersion(uint16 version) external override {\n        endpoint.setSendVersion(version);\n    }\n\n    function setReceiveVersion(uint16 version) external override {\n        endpoint.setReceiveVersion(version);\n    }\n\n    function getSendVersion() external view returns (uint16) {\n        return endpoint.getSendVersion(address(this));\n    }\n\n    function getReceiveVersion() external view returns (uint16) {\n        return endpoint.getReceiveVersion(address(this));\n    }\n\n    function setOutboundBlockConfirmations(uint16 dstChainId, uint64 confirmations) external {\n        // should technically be onlyOwner but this is a mock\n        uint TYPE_OUTBOUND_BLOCK_CONFIRMATIONS = 6;\n        endpoint.setConfig(\n            endpoint.getSendVersion(address(this)),\n            dstChainId,\n            TYPE_OUTBOUND_BLOCK_CONFIRMATIONS,\n            abi.encodePacked(confirmations)\n        );\n    }\n\n    function getOutboundBlockConfirmations(uint16 remoteChainId) external view returns (bytes memory _confirmations) {\n        return endpoint.getConfig(endpoint.getSendVersion(address(this)), remoteChainId, address(this), 5);\n    }\n\n    // set the Oracle to be used by this UA for LayerZero messages\n    function setOracle(uint16 dstChainId, address oracle) external {\n        // should technically be onlyOwner but this is a mock\n        uint TYPE_ORACLE = 6; // from UltraLightNode\n        // set the Oracle\n        // uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config\n        endpoint.setConfig(endpoint.getSendVersion(address(this)), dstChainId, TYPE_ORACLE, abi.encode(oracle));\n    }\n\n    // get the configured oracle\n    function getOracle(uint16 remoteChainId) external view returns (address _oracle) {\n        bytes memory bytesOracle = endpoint.getConfig(\n            endpoint.getSendVersion(address(this)),\n            remoteChainId,\n            address(this),\n            6\n        );\n        assembly {\n            _oracle := mload(add(bytesOracle, 32))\n        }\n    }\n\n    // set the Relayer to be used by this UA for LayerZero messages\n    function setRelayer(uint16 dstChainId, address relayer) external {\n        uint TYPE_RELAYER = 3;\n        endpoint.setConfig(endpoint.getSendVersion(address(this)), dstChainId, TYPE_RELAYER, abi.encode(relayer));\n    }\n\n    // set the inbound block confirmations\n    function setInboundConfirmations(uint16 remoteChainId, uint16 confirmations) external {\n        endpoint.setConfig(\n            endpoint.getSendVersion(address(this)),\n            remoteChainId,\n            2, // CONFIG_TYPE_INBOUND_BLOCK_CONFIRMATIONS\n            abi.encode(confirmations)\n        );\n    }\n\n    // set outbound block confirmations\n    function setOutboundConfirmations(uint16 remoteChainId, uint16 confirmations) external {\n        endpoint.setConfig(\n            endpoint.getSendVersion(address(this)),\n            remoteChainId,\n            5, // CONFIG_TYPE_OUTBOUND_BLOCK_CONFIRMATIONS\n            abi.encode(confirmations)\n        );\n    }\n\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override {\n        // ignored for this contract\n    }\n\n    function setPayInZRO(bool _payInZRO) external onlyOwner {\n        payInZRO = _payInZRO;\n    }\n\n    function approveTokenSpender(address token, address spender, uint amount) external onlyOwner {\n        IERC20(token).approve(spender, amount);\n    }\n\n    // allow this contract to receive ether\n    fallback() external payable {}\n\n    receive() external payable {\n        // Mock the ability to reject payments\n        require(\n            msg.value < 1000 && msg.value != 10,\n            \"Did you mean to send a blocked amount - check receive() / fallback()\"\n        );\n    }\n\n    // allow owner to set it multiple times.\n    function setTrustedRemote(uint16 _srcChainId, bytes calldata _srcAddress) external onlyOwner {\n        trustedRemoteLookup[_srcChainId] = _srcAddress;\n    }\n\n    function _verifySourceAddress(uint16 _srcChainId, bytes memory _fromAddress) internal view {\n        bytes memory trustedRemote = trustedRemoteLookup[_srcChainId];\n        require(\n            trustedRemote.length != 0 && keccak256(_fromAddress) == keccak256(trustedRemote),\n            \"source counter is not trusted\"\n        );\n    }\n}\n"
    },
    "contracts/V1Contracts/contracts/mocks/PingPong.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n//\n// Note: you will need to fund each deployed contract with gas\n//\n// PingPong sends a LayerZero message back and forth between chains until stopped!\n//\n// Demonstrates:\n//  1. a recursive feature of calling send() from inside lzReceive()\n//  2. how to `estimateFees` for a send()'ing a LayerZero message\n//  3. the contract pays the message fee\n\npragma solidity ^0.7.6;\npragma abicoder v2;\nimport \"../interfaces/ILayerZeroReceiver.sol\";\nimport \"../interfaces/ILayerZeroEndpoint.sol\";\nimport \"../interfaces/ILayerZeroUserApplicationConfig.sol\";\n\ncontract PingPong is ILayerZeroReceiver, ILayerZeroUserApplicationConfig {\n    // the LayerZero endpoint calls .send() to send a cross chain message\n    ILayerZeroEndpoint public endpoint;\n    // whether PingPong is ping-ponging\n    bool public pingsEnabled;\n    // event emitted every ping() to keep track of consecutive pings count\n    event Ping(uint pings);\n    // the maxPings before ending the loop\n    uint public maxPings;\n    // keep track of the totalPings sent\n    uint public numPings;\n    bool public isUlnV2;\n\n    // constructor requires the LayerZero endpoint for this chain\n    constructor(address _layerZeroEndpoint, bool _isUlnV2) {\n        pingsEnabled = true;\n        endpoint = ILayerZeroEndpoint(_layerZeroEndpoint);\n        maxPings = 5;\n        isUlnV2 = _isUlnV2;\n    }\n\n    // disable ping-ponging\n    function disable() external {\n        pingsEnabled = false;\n    }\n\n    // pings the destination chain, along with the current number of pings sent\n    function ping(\n        uint16 _dstChainId, // send a ping to this destination chainId\n        address _dstPingPongAddr, // destination address of PingPong contract\n        uint pings // the uint to start at. use 0 as a default\n    ) public {\n        require(address(this).balance > 0, \"the balance of this contract is 0. pls send gas for message fees\");\n        require(pingsEnabled, \"pingsEnabled is false. messages stopped\");\n        require(maxPings > pings, \"maxPings has been reached, no more looping\");\n\n        emit Ping(pings);\n\n        // abi.encode() the payload with the number of pings sent\n        bytes memory payload = abi.encode(pings);\n\n        // encode adapterParams to specify more gas for the destination\n        uint16 version = 1;\n        uint gasForDestinationLzReceive = 350000;\n        bytes memory adapterParams = abi.encodePacked(version, gasForDestinationLzReceive);\n\n        // get the fees we need to pay to LayerZero + Relayer to cover message delivery\n        // see Communicator.sol's .estimateNativeFees() function for more details.\n        (uint messageFee, ) = endpoint.estimateFees(_dstChainId, address(this), payload, false, adapterParams);\n        require(\n            address(this).balance >= messageFee,\n            \"address(this).balance < messageFee. pls send gas for message fees\"\n        );\n\n        bytes memory path = isUlnV2\n            ? abi.encodePacked(_dstPingPongAddr, address(this))\n            : abi.encodePacked(_dstPingPongAddr);\n\n        // send LayerZero message\n        endpoint.send{value: messageFee}( // {value: messageFee} will be paid out of this contract!\n            _dstChainId, // destination chainId\n            path,\n            payload, // abi.encode()'ed bytes\n            payable(this), // (msg.sender will be this contract) refund address (LayerZero will refund any extra gas back to caller of send()\n            address(0x0), // 'zroPaymentAddress' unused for this mock/example\n            adapterParams // 'adapterParams' unused for this mock/example\n        );\n    }\n\n    // receive the bytes payload from the source chain via LayerZero\n    // _srcChainId: the chainId that we are receiving the message from.\n    // _fromAddress: the source PingPong address\n    function lzReceive(\n        uint16 _srcChainId,\n        bytes memory _fromAddress,\n        uint64 /*_nonce*/,\n        bytes memory _payload\n    ) external override {\n        require(msg.sender == address(endpoint)); // boilerplate! lzReceive must be called by the endpoint for security\n\n        // use assembly to extract the address from the bytes memory parameter\n        address fromAddress;\n        assembly {\n            fromAddress := mload(add(_fromAddress, 20))\n        }\n\n        // decode the number of pings sent thus far\n        uint pings = abi.decode(_payload, (uint));\n\n        // \"recursively\" call ping in order to *pong*     (and increment pings)\n        ++pings;\n        numPings = pings;\n\n        ping(_srcChainId, fromAddress, pings);\n    }\n\n    function setConfig(\n        uint16 /*_version*/,\n        uint16 _dstChainId,\n        uint _configType,\n        bytes memory _config\n    ) external override {\n        endpoint.setConfig(_dstChainId, endpoint.getSendVersion(address(this)), _configType, _config);\n    }\n\n    function getConfig(\n        uint16 /*_dstChainId*/,\n        uint16 _chainId,\n        address,\n        uint _configType\n    ) external view returns (bytes memory) {\n        return endpoint.getConfig(endpoint.getSendVersion(address(this)), _chainId, address(this), _configType);\n    }\n\n    function setSendVersion(uint16 version) external override {\n        endpoint.setSendVersion(version);\n    }\n\n    function setReceiveVersion(uint16 version) external override {\n        endpoint.setReceiveVersion(version);\n    }\n\n    function getSendVersion() external view returns (uint16) {\n        return endpoint.getSendVersion(address(this));\n    }\n\n    function getReceiveVersion() external view returns (uint16) {\n        return endpoint.getReceiveVersion(address(this));\n    }\n\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override {\n        // do nth\n    }\n\n    // allow this contract to receive ether\n    fallback() external payable {}\n\n    receive() external payable {}\n}\n"
    },
    "contracts/V1Contracts/contracts/mocks/PriceFeedV2Mock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"../interfaces/ILayerZeroPriceFeedV2.sol\";\n\n// copy of \"@layerzerolabs/lz-evm-messagelib-v2/contracts/interfaces/ILayerZeroPriceFeed.sol\"\n// PriceFeed is updated based on v1 eids\n// v2 eids will fall to the convention of v1 eid + 30,000\ncontract PriceFeedV2Mock is ILayerZeroPriceFeedV2, OwnableUpgradeable {\n    uint128 internal PRICE_RATIO_DENOMINATOR;\n\n    // sets pricing\n    mapping(address => bool) public priceUpdater;\n\n    mapping(uint32 => Price) public defaultModelPrice;\n    ArbitrumPriceExt public arbitrumPriceExt;\n\n    uint128 public nativeTokenPriceUSD; // uses PRICE_RATIO_DENOMINATOR\n\n    // upgrade: arbitrum compression - percentage of callDataSize after brotli compression\n    uint128 public ARBITRUM_COMPRESSION_PERCENT;\n\n    // ============================ Constructor ===================================\n\n    function initialize(address _priceUpdater) public initializer {\n        __Ownable_init();\n        priceUpdater[_priceUpdater] = true;\n        PRICE_RATIO_DENOMINATOR = 1e20;\n        ARBITRUM_COMPRESSION_PERCENT = 47;\n    }\n\n    // ============================ Modifier ======================================\n\n    // owner is always approved\n    modifier onlyPriceUpdater() {\n        if (owner() != msg.sender) {\n            require(priceUpdater[msg.sender], \"PriceFeed: not price updater\");\n        }\n        _;\n    }\n\n    // ============================ OnlyOwner =====================================\n\n    function setPriceUpdater(address _addr, bool _active) external onlyOwner {\n        priceUpdater[_addr] = _active;\n    }\n\n    function setPriceRatioDenominator(uint128 _denominator) external onlyOwner {\n        PRICE_RATIO_DENOMINATOR = _denominator;\n    }\n\n    function setArbitrumCompressionPercent(uint128 _compressionPercent) external onlyOwner {\n        ARBITRUM_COMPRESSION_PERCENT = _compressionPercent;\n    }\n\n    // ============================ OnlyPriceUpdater =====================================\n\n    function setPrice(UpdatePrice[] calldata _price) external onlyPriceUpdater {\n        for (uint i = 0; i < _price.length; i++) {\n            UpdatePrice calldata _update = _price[i];\n            _setPrice(_update.eid, _update.price);\n        }\n    }\n\n    function setPriceForArbitrum(UpdatePriceExt calldata _update) external onlyPriceUpdater {\n        _setPrice(_update.eid, _update.price);\n\n        uint64 gasPerL2Tx = _update.extend.gasPerL2Tx;\n        uint32 gasPerL1CalldataByte = _update.extend.gasPerL1CallDataByte;\n\n        arbitrumPriceExt.gasPerL2Tx = gasPerL2Tx;\n        arbitrumPriceExt.gasPerL1CallDataByte = gasPerL1CalldataByte;\n    }\n\n    function setNativeTokenPriceUSD(uint128 _nativeTokenPriceUSD) external onlyPriceUpdater {\n        nativeTokenPriceUSD = _nativeTokenPriceUSD;\n    }\n\n    // ============================ Internal ==========================================\n    function _setPrice(uint32 _dstEid, Price memory _price) internal {\n        uint128 priceRatio = _price.priceRatio;\n        uint64 gasPriceInUnit = _price.gasPriceInUnit;\n        uint32 gasPerByte = _price.gasPerByte;\n        defaultModelPrice[_dstEid] = Price(priceRatio, gasPriceInUnit, gasPerByte);\n    }\n\n    function _getL1LookupId(uint32 _l2Eid) internal pure returns (uint32) {\n        uint32 l2Eid = _l2Eid % 30_000;\n        if (l2Eid == 111) {\n            return 101;\n        } else if (l2Eid == 10132) {\n            return 10121; // ethereum-goerli\n        } else if (l2Eid == 20132) {\n            return 20121; // ethereum-goerli\n        } else {\n            revert(\"PriceFeed: unknown l2 chain id\");\n        }\n    }\n\n    // ============================ View ==========================================\n\n    function getPrice(uint32 _dstEid) external view override returns (Price memory price) {\n        price = defaultModelPrice[_dstEid];\n    }\n\n    function getPriceRatioDenominator() external view override returns (uint128) {\n        return PRICE_RATIO_DENOMINATOR;\n    }\n\n    function estimateFeeByEid(\n        uint32 _dstEid,\n        uint _callDataSize,\n        uint _gas\n    )\n        external\n        view\n        override\n        returns (uint fee, uint128 priceRatio, uint128 priceRatioDenominator, uint128 nativePriceUSD)\n    {\n        uint32 dstEid = _dstEid % 30_000;\n        if (dstEid == 110 || dstEid == 10143 || dstEid == 20143) {\n            (fee, priceRatio) = _estimateFeeWithArbitrumModel(dstEid, _callDataSize, _gas);\n        } else if (dstEid == 111 || dstEid == 10132 || dstEid == 20132) {\n            (fee, priceRatio) = _estimateFeeWithOptimismModel(dstEid, _callDataSize, _gas);\n        } else {\n            (fee, priceRatio) = _estimateFeeWithDefaultModel(dstEid, _callDataSize, _gas);\n        }\n        priceRatioDenominator = PRICE_RATIO_DENOMINATOR;\n        nativePriceUSD = nativeTokenPriceUSD;\n    }\n\n    function _estimateFeeWithDefaultModel(\n        uint32 _dstEid,\n        uint _callDataSize,\n        uint _gas\n    ) internal view returns (uint fee, uint128 priceRatio) {\n        Price storage remotePrice = defaultModelPrice[_dstEid];\n\n        // assuming the _gas includes (1) the 21,000 overhead and (2) not the calldata gas\n        uint gasForCallData = _callDataSize * remotePrice.gasPerByte;\n        uint remoteFee = (gasForCallData + _gas) * remotePrice.gasPriceInUnit;\n        return ((remoteFee * remotePrice.priceRatio) / PRICE_RATIO_DENOMINATOR, remotePrice.priceRatio);\n    }\n\n    function _estimateFeeWithOptimismModel(\n        uint32 _dstEid,\n        uint _callDataSize,\n        uint _gas\n    ) internal view returns (uint fee, uint128 priceRatio) {\n        uint32 ethereumId = _getL1LookupId(_dstEid);\n\n        // L1 fee\n        Price storage ethereumPrice = defaultModelPrice[ethereumId];\n        uint gasForL1CallData = (_callDataSize * ethereumPrice.gasPerByte) + 3188; // 2100 + 68 * 16\n        uint l1Fee = gasForL1CallData * ethereumPrice.gasPriceInUnit;\n\n        // L2 fee\n        Price storage optimismPrice = defaultModelPrice[_dstEid];\n        uint gasForL2CallData = _callDataSize * optimismPrice.gasPerByte;\n        uint l2Fee = (gasForL2CallData + _gas) * optimismPrice.gasPriceInUnit;\n\n        uint l1FeeInSrcPrice = (l1Fee * ethereumPrice.priceRatio) / PRICE_RATIO_DENOMINATOR;\n        uint l2FeeInSrcPrice = (l2Fee * optimismPrice.priceRatio) / PRICE_RATIO_DENOMINATOR;\n        uint gasFee = l1FeeInSrcPrice + l2FeeInSrcPrice;\n        return (gasFee, optimismPrice.priceRatio);\n    }\n\n    function _estimateFeeWithArbitrumModel(\n        uint32 _dstEid,\n        uint _callDataSize,\n        uint _gas\n    ) internal view returns (uint fee, uint128 priceRatio) {\n        Price storage arbitrumPrice = defaultModelPrice[_dstEid];\n\n        // L1 fee\n        uint gasForL1CallData = ((_callDataSize * ARBITRUM_COMPRESSION_PERCENT) / 100) *\n            arbitrumPriceExt.gasPerL1CallDataByte;\n        // L2 Fee\n        uint gasForL2CallData = _callDataSize * arbitrumPrice.gasPerByte;\n        uint gasFee = (_gas + arbitrumPriceExt.gasPerL2Tx + gasForL1CallData + gasForL2CallData) *\n            arbitrumPrice.gasPriceInUnit;\n\n        return ((gasFee * arbitrumPrice.priceRatio) / PRICE_RATIO_DENOMINATOR, arbitrumPrice.priceRatio);\n    }\n}\n"
    },
    "contracts/V1Contracts/contracts/mocks/Token.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract Token is ERC20 {\n    event tried();\n    event caught();\n\n    constructor() ERC20(\"test\", \"test\") {\n        _mint(msg.sender, 10_000_000_000 * 10 ** 18);\n    }\n\n    function selfDestruct() public {\n        selfdestruct(address(0x0));\n    }\n\n    function tryCatch(address _tokenAddress) public {\n        try ERC20(_tokenAddress).totalSupply() {\n            emit tried();\n        } catch {\n            emit caught();\n        }\n    }\n}\n"
    },
    "contracts/V1Contracts/contracts/mocks/UltraLightNodeV2Mock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.7.0;\npragma abicoder v2;\n\nimport \"../interfaces/ILayerZeroUltraLightNodeV2.sol\";\n\ncontract UltraLightNodeV2Mock is ILayerZeroUltraLightNodeV2 {\n    event executed();\n    event paidTo(address _to, uint _amount);\n\n    mapping(address => mapping(uint16 => mapping(bytes32 => mapping(bytes32 => uint)))) public hashLookup; //[oracle][srcChainId][blockhash][datahash] -> confirmation\n\n    constructor() {}\n\n    //Mock version of uln for testing the withdraw fee function. If we need to use this again we can expand on it.\n    // Relayer functions\n    function validateTransactionProof(\n        uint16 _srcChainId,\n        address _dstAddress,\n        uint _gasLimit,\n        bytes32 _lookupHash,\n        bytes32 _blockData,\n        bytes calldata _transactionProof\n    ) external override {\n        emit executed();\n    }\n\n    // an Oracle delivers the block data using updateHash()\n    function updateHash(\n        uint16 _srcChainId,\n        bytes32 _lookupHash,\n        uint _confirmations,\n        bytes32 _blockData\n    ) external override {\n        emit executed();\n    }\n\n    // can only withdraw the receivable of the msg.sender\n    function withdrawNative(address payable _to, uint _amount) external override {\n        (bool success, ) = _to.call{value: _amount}(\"\");\n        emit paidTo(_to, _amount);\n    }\n\n    function withdrawZRO(address _to, uint _amount) external override {\n        emit executed();\n    }\n\n    // view functions\n    function getAppConfig(\n        uint16 _remoteChainId,\n        address _userApplicationAddress\n    ) external view override returns (ApplicationConfiguration memory) {}\n\n    function accruedNativeFee(address _address) external view override returns (uint) {}\n\n    receive() external payable {}\n}\n"
    },
    "contracts/V1Contracts/contracts/NonceContract.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\n\nimport \"./interfaces/ILayerZeroEndpoint.sol\";\n\ncontract NonceContract {\n    ILayerZeroEndpoint public immutable endpoint;\n    // outboundNonce = [dstChainId][remoteAddress + localAddress]\n    mapping(uint16 => mapping(bytes => uint64)) public outboundNonce;\n\n    constructor(address _endpoint) {\n        endpoint = ILayerZeroEndpoint(_endpoint);\n    }\n\n    function increment(uint16 _chainId, address _ua, bytes calldata _path) external returns (uint64) {\n        require(\n            endpoint.getSendLibraryAddress(_ua) == msg.sender,\n            \"NonceContract: msg.sender is not valid sendlibrary\"\n        );\n        return ++outboundNonce[_chainId][_path];\n    }\n}\n"
    },
    "contracts/V1Contracts/contracts/NonceContractRadar.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\n\nimport \"./interfaces/ILayerZeroEndpoint.sol\";\n\ncontract NonceContractRadar {\n    ILayerZeroEndpoint public immutable endpoint;\n    address public immutable ulnv2Radar;\n    // outboundNonce = [dstChainId][remoteAddress + localAddress]\n    mapping(uint16 => mapping(bytes => uint64)) public outboundNonce;\n\n    constructor(address _endpoint, address _ulnv2Radar) {\n        endpoint = ILayerZeroEndpoint(_endpoint);\n        ulnv2Radar = _ulnv2Radar;\n    }\n\n    function increment(uint16 _chainId, address _ua, bytes calldata _path) external returns (uint64) {\n        require(\n            endpoint.getSendLibraryAddress(_ua) == msg.sender,\n            \"NonceContract: msg.sender is not valid sendlibrary\"\n        );\n        return ++outboundNonce[_chainId][_path];\n    }\n\n    // only ulnv2Radar can call this function\n    function initRadarOutboundNonce(uint16 _dstChainId, bytes calldata _path, uint64 _nonce) external {\n        require(msg.sender == ulnv2Radar, \"NonceContract: only ulnv2Radar\");\n        outboundNonce[_dstChainId][_path] = _nonce;\n    }\n}\n"
    },
    "contracts/V1Contracts/contracts/PriceFeed.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"hardhat-deploy/solc_0.7/proxy/Proxied.sol\";\nimport \"./interfaces/ILayerZeroPriceFeed.sol\";\n\ncontract PriceFeed is ILayerZeroPriceFeed, OwnableUpgradeable, Proxied {\n    using SafeMath for uint;\n\n    uint128 public PRICE_RATIO_DENOMINATOR;\n\n    // sets pricing\n    mapping(address => bool) public priceUpdater;\n\n    // [_chainId]\n    mapping(uint16 => Price) public defaultModelPrice;\n    ArbitrumPriceExt public arbitrumPriceExt;\n\n    uint128 public override nativeTokenPriceUSD; // uses PRICE_RATIO_DENOMINATOR\n\n    // upgrade: arbitrum compression - percentage of callDataSize after brotli compression\n    uint128 public ARBITRUM_COMPRESSION_PERCENT;\n\n    // ============================ Constructor ===================================\n\n    function initialize(address _priceUpdater) public proxied initializer {\n        __Ownable_init();\n        priceUpdater[_priceUpdater] = true;\n        PRICE_RATIO_DENOMINATOR = 1e10; // gas optimization: if you change this, you also need to change the RelayerV2\n        ARBITRUM_COMPRESSION_PERCENT = 47;\n    }\n\n    function onUpgrade() public proxied {\n        PRICE_RATIO_DENOMINATOR = 1e10; // gas optimization: if you change this, you also need to change the RelayerV2\n        ARBITRUM_COMPRESSION_PERCENT = 47;\n    }\n\n    // ============================ Modifier ======================================\n\n    // owner is always approved\n    modifier onlyPriceUpdater() {\n        if (owner() != msg.sender) {\n            require(priceUpdater[msg.sender], \"PriceFeed: not price updater\");\n        }\n        _;\n    }\n\n    // ============================ OnlyOwner =====================================\n\n    function setPriceUpdater(address _addr, bool _active) external onlyOwner {\n        priceUpdater[_addr] = _active;\n    }\n\n    function setPriceRatioDenominator(uint128 _denominator) external onlyOwner {\n        PRICE_RATIO_DENOMINATOR = _denominator;\n    }\n\n    function setArbitrumCompressionPercent(uint128 _compressionPercent) external onlyOwner {\n        ARBITRUM_COMPRESSION_PERCENT = _compressionPercent;\n    }\n\n    // ============================ OnlyPriceUpdater =====================================\n\n    function setPrice(UpdatePrice[] calldata _price) external onlyPriceUpdater {\n        for (uint i = 0; i < _price.length; i++) {\n            UpdatePrice calldata _update = _price[i];\n            _setPrice(_update.chainId, _update.price);\n        }\n    }\n\n    function setPriceForArbitrum(UpdatePriceExt[] calldata _price) external onlyPriceUpdater {\n        for (uint i = 0; i < _price.length; i++) {\n            UpdatePriceExt calldata _update = _price[i];\n\n            _setPrice(_update.chainId, _update.price);\n\n            uint64 gasPerL2Tx = _update.extend.gasPerL2Tx;\n            uint32 gasPerL1CalldataByte = _update.extend.gasPerL1CallDataByte;\n\n            arbitrumPriceExt.gasPerL2Tx = gasPerL2Tx;\n            arbitrumPriceExt.gasPerL1CallDataByte = gasPerL1CalldataByte;\n        }\n    }\n\n    function setNativeTokenPriceUSD(uint128 _nativeTokenPriceUSD) external onlyPriceUpdater {\n        nativeTokenPriceUSD = _nativeTokenPriceUSD;\n    }\n\n    // ============================ Internal ==========================================\n    function _setPrice(uint16 chainId, Price memory _price) internal {\n        uint128 priceRatio = _price.priceRatio;\n        uint64 gasPriceInUnit = _price.gasPriceInUnit;\n        uint32 gasPerByte = _price.gasPerByte;\n        defaultModelPrice[chainId] = Price(priceRatio, gasPriceInUnit, gasPerByte);\n    }\n\n    // For optimism l1 gas price lookup\n    function _getL1LookupId(uint16 _l2ChainId) internal pure returns (uint16) {\n        if (_l2ChainId == 111) {\n            return 101;\n        } else if (_l2ChainId == 10132) {\n            return 10121; // ethereum-goerli\n        } else if (_l2ChainId == 20132) {\n            return 20121; // ethereum-goerli\n        } else {\n            revert(\"PriceFeed: unknown l2 chain id\");\n        }\n    }\n\n    // ============================ View ==========================================\n\n    function getPrice(uint16 _dstChainId) external view override returns (Price memory price) {\n        price = defaultModelPrice[_dstChainId];\n    }\n\n    function getPriceRatioDenominator() external view override returns (uint128) {\n        return PRICE_RATIO_DENOMINATOR;\n    }\n\n    function estimateFeeByChain(\n        uint16 _dstChainId,\n        uint _callDataSize,\n        uint _gas\n    ) external view override returns (uint fee, uint128 priceRatio) {\n        if (_dstChainId == 110 || _dstChainId == 10143 || _dstChainId == 20143) {\n            return estimateFeeWithArbitrumModel(_dstChainId, _callDataSize, _gas);\n        } else if (_dstChainId == 111 || _dstChainId == 10132 || _dstChainId == 20132) {\n            return estimateFeeWithOptimismModel(_dstChainId, _callDataSize, _gas);\n        } else {\n            return estimateFeeWithDefaultModel(_dstChainId, _callDataSize, _gas);\n        }\n    }\n\n    function estimateFeeWithDefaultModel(\n        uint16 _dstChainId,\n        uint _callDataSize,\n        uint _gas\n    ) public view returns (uint fee, uint128 priceRatio) {\n        Price storage remotePrice = defaultModelPrice[_dstChainId];\n\n        // assuming the _gas includes (1) the 21,000 overhead and (2) not the calldata gas\n        uint gasForCallData = _callDataSize.mul(remotePrice.gasPerByte);\n        uint remoteFee = (gasForCallData.add(_gas)).mul(remotePrice.gasPriceInUnit);\n        return ((remoteFee.mul(remotePrice.priceRatio)).div(PRICE_RATIO_DENOMINATOR), remotePrice.priceRatio);\n    }\n\n    function estimateFeeWithOptimismModel(\n        uint16 _dstChainId,\n        uint _callDataSize,\n        uint _gas\n    ) public view returns (uint fee, uint128 priceRatio) {\n        uint16 ethereumId = _getL1LookupId(_dstChainId);\n\n        // L1 fee\n        Price storage ethereumPrice = defaultModelPrice[ethereumId];\n        uint gasForL1CallData = _callDataSize.mul(ethereumPrice.gasPerByte).add(3188); // 2100 + 68 * 16\n        uint l1Fee = gasForL1CallData.mul(ethereumPrice.gasPriceInUnit);\n\n        // L2 fee\n        Price storage optimismPrice = defaultModelPrice[_dstChainId];\n        uint gasForL2CallData = _callDataSize.mul(optimismPrice.gasPerByte);\n        uint l2Fee = (gasForL2CallData.add(_gas)).mul(optimismPrice.gasPriceInUnit);\n\n        uint l1FeeInSrcPrice = l1Fee.mul(ethereumPrice.priceRatio).div(PRICE_RATIO_DENOMINATOR);\n        uint l2FeeInSrcPrice = l2Fee.mul(optimismPrice.priceRatio).div(PRICE_RATIO_DENOMINATOR);\n        uint gasFee = l1FeeInSrcPrice.add(l2FeeInSrcPrice);\n        return (gasFee, optimismPrice.priceRatio);\n    }\n\n    function estimateFeeWithArbitrumModel(\n        uint16 _dstChainId,\n        uint _callDataSize,\n        uint _gas\n    ) public view returns (uint fee, uint128 priceRatio) {\n        Price storage arbitrumPrice = defaultModelPrice[_dstChainId];\n\n        // L1 fee\n        uint gasForL1CallData = _callDataSize.mul(ARBITRUM_COMPRESSION_PERCENT).div(100).mul(\n            arbitrumPriceExt.gasPerL1CallDataByte\n        );\n        // L2 Fee\n        uint gasForL2CallData = _callDataSize.mul(arbitrumPrice.gasPerByte);\n        uint gasFee = (_gas.add(arbitrumPriceExt.gasPerL2Tx).add(gasForL1CallData).add(gasForL2CallData)).mul(\n            arbitrumPrice.gasPriceInUnit\n        );\n\n        return ((gasFee.mul(arbitrumPrice.priceRatio)).div(PRICE_RATIO_DENOMINATOR), arbitrumPrice.priceRatio);\n    }\n}\n"
    },
    "contracts/V1Contracts/contracts/proof/FPValidator.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"./utility/LayerZeroPacket.sol\";\nimport \"../interfaces/ILayerZeroValidationLibrary.sol\";\nimport \"../interfaces/IValidationLibraryHelperV2.sol\";\n\ninterface IStargate {\n    // Stargate objects for abi encoding / decoding\n    struct SwapObj {\n        uint amount;\n        uint eqFee;\n        uint eqReward;\n        uint lpFee;\n        uint protocolFee;\n        uint lkbRemove;\n    }\n\n    struct CreditObj {\n        uint credits;\n        uint idealBalance;\n    }\n}\n\ncontract FPValidator is ILayerZeroValidationLibrary, IValidationLibraryHelperV2 {\n    uint8 public proofType = 2;\n    uint8 public utilsVersion = 1;\n\n    address public immutable stargateBridgeAddress;\n    address public immutable stargateTokenAddress;\n\n    constructor(address _stargateBridgeAddress, address _stargateTokenAddress) {\n        stargateBridgeAddress = _stargateBridgeAddress;\n        stargateTokenAddress = _stargateTokenAddress;\n    }\n\n    function validateProof(\n        bytes32 _packetHash,\n        bytes calldata _transactionProof,\n        uint _remoteAddressSize\n    ) external view override returns (LayerZeroPacket.Packet memory packet) {\n        require(_remoteAddressSize > 0, \"ProofLib: invalid address size\");\n        // _transactionProof = srcUlnAddress (32 bytes) + lzPacket\n        require(\n            _transactionProof.length > 32 && keccak256(_transactionProof) == _packetHash,\n            \"ProofLib: invalid transaction proof\"\n        );\n\n        bytes memory ulnAddressBytes = bytes(_transactionProof[0:32]);\n        bytes32 ulnAddress;\n        assembly {\n            ulnAddress := mload(add(ulnAddressBytes, 32))\n        }\n        packet = LayerZeroPacket.getPacketV3(_transactionProof[32:], _remoteAddressSize, ulnAddress);\n\n        if (packet.dstAddress == stargateBridgeAddress) packet.payload = _secureStgPayload(packet.payload);\n        if (packet.dstAddress == stargateTokenAddress) packet.payload = _secureStgTokenPayload(packet.payload);\n\n        return packet;\n    }\n\n    function _secureStgTokenPayload(bytes memory _payload) internal pure returns (bytes memory) {\n        (bytes memory toAddressBytes, uint qty) = abi.decode(_payload, (bytes, uint));\n\n        address toAddress = address(0);\n        if (toAddressBytes.length > 0) {\n            assembly {\n                toAddress := mload(add(toAddressBytes, 20))\n            }\n        }\n\n        if (toAddress == address(0)) {\n            address deadAddress = address(0x000000000000000000000000000000000000dEaD);\n            bytes memory newToAddressBytes = abi.encodePacked(deadAddress);\n            return abi.encode(newToAddressBytes, qty);\n        }\n\n        // default to return the original payload\n        return _payload;\n    }\n\n    function _secureStgPayload(bytes memory _payload) internal view returns (bytes memory) {\n        // functionType is uint8 even though the encoding will take up the side of uint256\n        uint8 functionType;\n        assembly {\n            functionType := mload(add(_payload, 32))\n        }\n\n        // TYPE_SWAP_REMOTE == 1 && only if the payload has a payload\n        // only swapRemote inside of stargate can call sgReceive on an user supplied to address\n        // thus we do not care about the other type functions even if the toAddress is overly long.\n        if (functionType == 1) {\n            // decode the _payload with its types\n            (\n                ,\n                uint srcPoolId,\n                uint dstPoolId,\n                uint dstGasForCall,\n                IStargate.CreditObj memory c,\n                IStargate.SwapObj memory s,\n                bytes memory toAddressBytes,\n                bytes memory contractCallPayload\n            ) = abi.decode(_payload, (uint8, uint, uint, uint, IStargate.CreditObj, IStargate.SwapObj, bytes, bytes));\n\n            // if contractCallPayload.length > 0 need to check if the to address is a contract or not\n            if (contractCallPayload.length > 0) {\n                // otherwise, need to check if the payload can be delivered to the toAddress\n                address toAddress = address(0);\n                if (toAddressBytes.length > 0) {\n                    assembly {\n                        toAddress := mload(add(toAddressBytes, 20))\n                    }\n                }\n\n                // check if the toAddress is a contract. We are not concerned about addresses that pretend to be wallets. because worst case we just delete their payload if being malicious\n                // we can guarantee that if a size > 0, then the contract is definitely a contract address in this context\n                uint size;\n                assembly {\n                    size := extcodesize(toAddress)\n                }\n\n                if (size == 0) {\n                    // size == 0 indicates its not a contract, payload wont be delivered\n                    // secure the _payload to make sure funds can be delivered to the toAddress\n                    bytes memory newToAddressBytes = abi.encodePacked(toAddress);\n                    bytes memory securePayload = abi.encode(\n                        functionType,\n                        srcPoolId,\n                        dstPoolId,\n                        dstGasForCall,\n                        c,\n                        s,\n                        newToAddressBytes,\n                        bytes(\"\")\n                    );\n                    return securePayload;\n                }\n            }\n        }\n\n        // default to return the original payload\n        return _payload;\n    }\n\n    function secureStgTokenPayload(bytes memory _payload) external pure returns (bytes memory) {\n        return _secureStgTokenPayload(_payload);\n    }\n\n    function secureStgPayload(bytes memory _payload) external view returns (bytes memory) {\n        return _secureStgPayload(_payload);\n    }\n\n    function getUtilsVersion() external view override returns (uint8) {\n        return utilsVersion;\n    }\n\n    function getProofType() external view override returns (uint8) {\n        return proofType;\n    }\n\n    function getVerifyLog(\n        bytes32,\n        uint[] calldata,\n        uint,\n        bytes[] calldata proof\n    ) external pure override returns (ULNLog memory log) {}\n\n    function getPacket(\n        bytes memory data,\n        uint sizeOfSrcAddress,\n        bytes32 ulnAddress\n    ) external pure override returns (LayerZeroPacket.Packet memory) {\n        return LayerZeroPacket.getPacketV3(data, sizeOfSrcAddress, ulnAddress);\n    }\n}\n"
    },
    "contracts/V1Contracts/contracts/proof/MPTValidator.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"./utility/LayerZeroPacket.sol\";\nimport \"./utility/Buffer.sol\";\nimport \"../interfaces/ILayerZeroValidationLibrary.sol\";\nimport \"./utility/UltraLightNodeEVMDecoder.sol\";\n\ncontract MPTValidator is ILayerZeroValidationLibrary {\n    using RLPDecode for RLPDecode.RLPItem;\n    using RLPDecode for RLPDecode.Iterator;\n    using Buffer for Buffer.buffer;\n    using SafeMath for uint;\n\n    bytes32 public constant PACKET_SIGNATURE = 0xe8d23d927749ec8e512eb885679c2977d57068839d8cca1a85685dbbea0648f6;\n\n    struct ULNLog {\n        bytes32 contractAddress;\n        bytes32 topicZeroSig;\n        bytes data;\n    }\n\n    function validateProof(\n        bytes32 _receiptsRoot,\n        bytes calldata _transactionProof,\n        uint _remoteAddressSize\n    ) external pure override returns (LayerZeroPacket.Packet memory packet) {\n        (uint16 remoteChainId, bytes[] memory proof, uint[] memory pointers, uint receiptIndex, uint logIndex) = abi\n            .decode(_transactionProof, (uint16, bytes[], uint[], uint, uint));\n\n        ULNLog memory log = _getVerifiedLog(_receiptsRoot, receiptIndex, logIndex, proof, pointers);\n        require(log.topicZeroSig == PACKET_SIGNATURE, \"LayerZero: packet not recognized\"); //data\n\n        return getPacket(log.data, remoteChainId, _remoteAddressSize, log.contractAddress);\n    }\n\n    function _getVerifiedLog(\n        bytes32 hashRoot,\n        uint receiptSlotIndex,\n        uint logIndex,\n        bytes[] memory proof,\n        uint[] memory pointers\n    ) internal pure returns (ULNLog memory) {\n        // walk and assert the hash links of MPT\n        uint pointer;\n        bytes memory proofBytes;\n        for (uint i = 0; i < proof.length; i++) {\n            proofBytes = proof[i];\n            require(hashRoot == keccak256(proofBytes), \"LayerZero: invalid hashlink\");\n            if (i < pointers.length) {\n                pointer = pointers[i];\n                assembly {\n                    hashRoot := mload(add(add(proofBytes, pointer), 32))\n                }\n            }\n        }\n\n        // build the iterator for the proofBytes\n        RLPDecode.Iterator memory it = RLPDecode.toRlpItem(proofBytes).iterator();\n\n        // get the receipt item from either branch or leaf node\n        RLPDecode.RLPItem memory receiptItem = it.item.getItemByIndex(receiptSlotIndex);\n        // it = targetReceiptIter\n        it = receiptItem.typeOffset().iterator();\n        it.next(); // status\n        it.next(); // gasUsed\n        it.next(); // logBloom\n\n        // it = targetLogIter\n        it = it.next().getItemByIndex(logIndex).iterator();\n        ULNLog memory log;\n        log.contractAddress = bytes32(it.next().toUint());\n        log.topicZeroSig = bytes32(it.next().getItemByIndex(0).toUint());\n        log.data = it.next().toBytes();\n\n        return log;\n    }\n\n    // profiling and test\n    function getVerifyLog(\n        bytes32 hashRoot,\n        uint receiptSlotIndex,\n        uint logIndex,\n        bytes[] memory proof,\n        uint[] memory pointers\n    ) external pure returns (ULNLog memory) {\n        return _getVerifiedLog(hashRoot, receiptSlotIndex, logIndex, proof, pointers);\n    }\n\n    function getPacket(\n        bytes memory data,\n        uint16 srcChain,\n        uint sizeOfSrcAddress,\n        bytes32 ulnAddress\n    ) internal pure returns (LayerZeroPacket.Packet memory) {\n        uint16 dstChainId;\n        address dstAddress;\n        uint size;\n        uint64 nonce;\n\n        // The log consists of the destination chain id and then a bytes payload\n        //      0--------------------------------------------31\n        // 0   |  destination chain id\n        // 32  |  defines bytes array\n        // 64  |\n        // 96  |  bytes array size\n        // 128 |  payload\n        assembly {\n            dstChainId := mload(add(data, 32))\n            size := mload(add(data, 96)) /// size of the byte array\n            nonce := mload(add(data, 104)) // offset to convert to uint64  128  is index -24\n            dstAddress := mload(add(data, sub(add(128, sizeOfSrcAddress), 4))) // offset to convert to address 12 -8\n        }\n\n        Buffer.buffer memory srcAddressBuffer;\n        srcAddressBuffer.init(sizeOfSrcAddress);\n        srcAddressBuffer.writeRawBytes(0, data, 136, sizeOfSrcAddress); // 128 + 8\n\n        uint payloadSize = size.sub(20).sub(sizeOfSrcAddress);\n        Buffer.buffer memory payloadBuffer;\n        payloadBuffer.init(payloadSize);\n        payloadBuffer.writeRawBytes(0, data, sizeOfSrcAddress.add(156), payloadSize); // 148 + 8\n        return\n            LayerZeroPacket.Packet(\n                srcChain,\n                dstChainId,\n                nonce,\n                address(dstAddress),\n                srcAddressBuffer.buf,\n                ulnAddress,\n                payloadBuffer.buf\n            );\n    }\n}\n"
    },
    "contracts/V1Contracts/contracts/proof/MPTValidator01.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"./utility/LayerZeroPacket.sol\";\nimport \"./utility/UltraLightNodeEVMDecoder.sol\";\nimport \"../interfaces/IValidationLibraryHelperV2.sol\";\nimport \"../interfaces/ILayerZeroValidationLibrary.sol\";\n\ninterface IStargate {\n    // Stargate objects for abi encoding / decoding\n    struct SwapObj {\n        uint amount;\n        uint eqFee;\n        uint eqReward;\n        uint lpFee;\n        uint protocolFee;\n        uint lkbRemove;\n    }\n\n    struct CreditObj {\n        uint credits;\n        uint idealBalance;\n    }\n}\n\ncontract MPTValidator01 is ILayerZeroValidationLibrary, IValidationLibraryHelperV2 {\n    using RLPDecode for RLPDecode.RLPItem;\n    using RLPDecode for RLPDecode.Iterator;\n\n    uint8 public proofType = 1;\n    uint8 public utilsVersion = 4;\n    bytes32 public constant PACKET_SIGNATURE = 0xe9bded5f24a4168e4f3bf44e00298c993b22376aad8c58c7dda9718a54cbea82;\n\n    address public immutable stargateBridgeAddress;\n    address public immutable stargateTokenAddress;\n\n    constructor(address _stargateBridgeAddress, address _stargateTokenAddress) {\n        stargateBridgeAddress = _stargateBridgeAddress;\n        stargateTokenAddress = _stargateTokenAddress;\n    }\n\n    function validateProof(\n        bytes32 _receiptsRoot,\n        bytes calldata _transactionProof,\n        uint _remoteAddressSize\n    ) external view override returns (LayerZeroPacket.Packet memory packet) {\n        require(_remoteAddressSize > 0, \"ProofLib: invalid address size\");\n        (bytes[] memory proof, uint[] memory receiptSlotIndex, uint logIndex) = abi.decode(\n            _transactionProof,\n            (bytes[], uint[], uint)\n        );\n\n        ULNLog memory log = _getVerifiedLog(_receiptsRoot, receiptSlotIndex, logIndex, proof);\n        require(log.topicZeroSig == PACKET_SIGNATURE, \"ProofLib: packet not recognized\"); //data\n\n        packet = LayerZeroPacket.getPacketV2(log.data, _remoteAddressSize, log.contractAddress);\n\n        if (packet.dstAddress == stargateBridgeAddress) packet.payload = _secureStgPayload(packet.payload);\n\n        if (packet.dstAddress == stargateTokenAddress) packet.payload = _secureStgTokenPayload(packet.payload);\n\n        return packet;\n    }\n\n    function _secureStgTokenPayload(bytes memory _payload) internal pure returns (bytes memory) {\n        (bytes memory toAddressBytes, uint qty) = abi.decode(_payload, (bytes, uint));\n\n        address toAddress = address(0);\n        if (toAddressBytes.length > 0) {\n            assembly {\n                toAddress := mload(add(toAddressBytes, 20))\n            }\n        }\n\n        if (toAddress == address(0)) {\n            address deadAddress = address(0x000000000000000000000000000000000000dEaD);\n            bytes memory newToAddressBytes = abi.encodePacked(deadAddress);\n            return abi.encode(newToAddressBytes, qty);\n        }\n\n        // default to return the original payload\n        return _payload;\n    }\n\n    function _secureStgPayload(bytes memory _payload) internal view returns (bytes memory) {\n        // functionType is uint8 even though the encoding will take up the side of uint256\n        uint8 functionType;\n        assembly {\n            functionType := mload(add(_payload, 32))\n        }\n\n        // TYPE_SWAP_REMOTE == 1 && only if the payload has a payload\n        // only swapRemote inside of stargate can call sgReceive on an user supplied to address\n        // thus we do not care about the other type functions even if the toAddress is overly long.\n        if (functionType == 1) {\n            // decode the _payload with its types\n            (\n                ,\n                uint srcPoolId,\n                uint dstPoolId,\n                uint dstGasForCall,\n                IStargate.CreditObj memory c,\n                IStargate.SwapObj memory s,\n                bytes memory toAddressBytes,\n                bytes memory contractCallPayload\n            ) = abi.decode(_payload, (uint8, uint, uint, uint, IStargate.CreditObj, IStargate.SwapObj, bytes, bytes));\n\n            // if contractCallPayload.length > 0 need to check if the to address is a contract or not\n            if (contractCallPayload.length > 0) {\n                // otherwise, need to check if the payload can be delivered to the toAddress\n                address toAddress = address(0);\n                if (toAddressBytes.length > 0) {\n                    assembly {\n                        toAddress := mload(add(toAddressBytes, 20))\n                    }\n                }\n\n                // check if the toAddress is a contract. We are not concerned about addresses that pretend to be wallets. because worst case we just delete their payload if being malicious\n                // we can guarantee that if a size > 0, then the contract is definitely a contract address in this context\n                uint size;\n                assembly {\n                    size := extcodesize(toAddress)\n                }\n\n                if (size == 0) {\n                    // size == 0 indicates its not a contract, payload wont be delivered\n                    // secure the _payload to make sure funds can be delivered to the toAddress\n                    bytes memory newToAddressBytes = abi.encodePacked(toAddress);\n                    bytes memory securePayload = abi.encode(\n                        functionType,\n                        srcPoolId,\n                        dstPoolId,\n                        dstGasForCall,\n                        c,\n                        s,\n                        newToAddressBytes,\n                        bytes(\"\")\n                    );\n                    return securePayload;\n                }\n            }\n        }\n\n        // default to return the original payload\n        return _payload;\n    }\n\n    function secureStgTokenPayload(bytes memory _payload) external pure returns (bytes memory) {\n        return _secureStgTokenPayload(_payload);\n    }\n\n    function secureStgPayload(bytes memory _payload) external view returns (bytes memory) {\n        return _secureStgPayload(_payload);\n    }\n\n    function _getVerifiedLog(\n        bytes32 hashRoot,\n        uint[] memory paths,\n        uint logIndex,\n        bytes[] memory proof\n    ) internal pure returns (ULNLog memory) {\n        require(paths.length == proof.length, \"ProofLib: invalid proof size\");\n        require(proof.length > 0, \"ProofLib: proof size must > 0\");\n        RLPDecode.RLPItem memory item;\n        bytes memory proofBytes;\n\n        for (uint i = 0; i < proof.length; i++) {\n            proofBytes = proof[i];\n            require(hashRoot == keccak256(proofBytes), \"ProofLib: invalid hashlink\");\n            item = RLPDecode.toRlpItem(proofBytes).safeGetItemByIndex(paths[i]);\n            if (i < proof.length - 1) hashRoot = bytes32(item.toUint());\n        }\n\n        // burning status + gasUsed + logBloom\n        RLPDecode.RLPItem memory logItem = item.typeOffset().safeGetItemByIndex(3);\n        RLPDecode.Iterator memory it = logItem.safeGetItemByIndex(logIndex).iterator();\n        ULNLog memory log;\n        log.contractAddress = bytes32(it.next().toUint());\n        log.topicZeroSig = bytes32(it.next().safeGetItemByIndex(0).toUint());\n        log.data = it.next().toBytes();\n\n        return log;\n    }\n\n    function getUtilsVersion() external view override returns (uint8) {\n        return utilsVersion;\n    }\n\n    function getProofType() external view override returns (uint8) {\n        return proofType;\n    }\n\n    function getVerifyLog(\n        bytes32 hashRoot,\n        uint[] memory receiptSlotIndex,\n        uint logIndex,\n        bytes[] memory proof\n    ) external pure override returns (ULNLog memory) {\n        return _getVerifiedLog(hashRoot, receiptSlotIndex, logIndex, proof);\n    }\n\n    function getPacket(\n        bytes memory data,\n        uint sizeOfSrcAddress,\n        bytes32 ulnAddress\n    ) external pure override returns (LayerZeroPacket.Packet memory) {\n        return LayerZeroPacket.getPacketV2(data, sizeOfSrcAddress, ulnAddress);\n    }\n}\n"
    },
    "contracts/V1Contracts/contracts/proof/MPTValidatorStgV3.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"./utility/LayerZeroPacket.sol\";\nimport \"./utility/Buffer.sol\";\nimport \"../interfaces/ILayerZeroValidationLibrary.sol\";\nimport \"./utility/UltraLightNodeEVMDecoder.sol\";\n\ncontract MPTValidatorStgV3 is ILayerZeroValidationLibrary {\n    using RLPDecode for RLPDecode.RLPItem;\n    using RLPDecode for RLPDecode.Iterator;\n    using Buffer for Buffer.buffer;\n    using SafeMath for uint;\n\n    bytes32 public constant PACKET_SIGNATURE = 0xe8d23d927749ec8e512eb885679c2977d57068839d8cca1a85685dbbea0648f6;\n\n    address public immutable stargateBridgeAddress;\n    address public immutable stgTokenAddress;\n    uint16 public immutable localChainId;\n\n    constructor(address _stargateBridgeAddress, address _stgTokenAddress, uint16 _localChainId) {\n        stargateBridgeAddress = _stargateBridgeAddress;\n        stgTokenAddress = _stgTokenAddress;\n        localChainId = _localChainId;\n    }\n\n    struct ULNLog {\n        bytes32 contractAddress;\n        bytes32 topicZeroSig;\n        bytes data;\n    }\n\n    // Stargate objects for abi encoding / decoding\n    struct SwapObj {\n        uint amount;\n        uint eqFee;\n        uint eqReward;\n        uint lpFee;\n        uint protocolFee;\n        uint lkbRemove;\n    }\n\n    struct CreditObj {\n        uint credits;\n        uint idealBalance;\n    }\n\n    function validateProof(\n        bytes32 _receiptsRoot,\n        bytes calldata _transactionProof,\n        uint _remoteAddressSize\n    ) external view override returns (LayerZeroPacket.Packet memory) {\n        (uint16 remoteChainId, bytes[] memory proof, uint[] memory receiptSlotIndex, uint logIndex) = abi.decode(\n            _transactionProof,\n            (uint16, bytes[], uint[], uint)\n        );\n\n        ULNLog memory log = _getVerifiedLog(_receiptsRoot, receiptSlotIndex, logIndex, proof);\n        require(log.topicZeroSig == PACKET_SIGNATURE, \"ProofLib: packet not recognized\"); //data\n\n        LayerZeroPacket.Packet memory packet = _getPacket(\n            log.data,\n            remoteChainId,\n            _remoteAddressSize,\n            log.contractAddress\n        );\n\n        require(packet.dstChainId == localChainId, \"ProofLib: invalid destination chain ID\");\n\n        if (packet.dstAddress == stargateBridgeAddress) packet.payload = _secureStgPayload(packet.payload);\n\n        if (packet.dstAddress == stgTokenAddress) packet.payload = _secureStgTokenPayload(packet.payload);\n\n        return packet;\n    }\n\n    function _secureStgTokenPayload(bytes memory _payload) internal pure returns (bytes memory) {\n        (bytes memory toAddressBytes, uint qty) = abi.decode(_payload, (bytes, uint));\n\n        address toAddress = address(0);\n        if (toAddressBytes.length > 0) {\n            assembly {\n                toAddress := mload(add(toAddressBytes, 20))\n            }\n        }\n\n        if (toAddress == address(0)) {\n            address deadAddress = address(0x000000000000000000000000000000000000dEaD);\n            bytes memory newToAddressBytes = abi.encodePacked(deadAddress);\n            return abi.encode(newToAddressBytes, qty);\n        }\n\n        // default to return the original payload\n        return _payload;\n    }\n\n    function _secureStgPayload(bytes memory _payload) internal view returns (bytes memory) {\n        // functionType is uint8 even though the encoding will take up the side of uint256\n        uint8 functionType;\n        assembly {\n            functionType := mload(add(_payload, 32))\n        }\n\n        // TYPE_SWAP_REMOTE == 1 && only if the payload has a payload\n        // only swapRemote inside of stargate can call sgReceive on an user supplied to address\n        // thus we do not care about the other type functions even if the toAddress is overly long.\n        if (functionType == 1) {\n            // decode the _payload with its types\n            (\n                ,\n                uint srcPoolId,\n                uint dstPoolId,\n                uint dstGasForCall,\n                CreditObj memory c,\n                SwapObj memory s,\n                bytes memory toAddressBytes,\n                bytes memory contractCallPayload\n            ) = abi.decode(_payload, (uint8, uint, uint, uint, CreditObj, SwapObj, bytes, bytes));\n\n            // if contractCallPayload.length > 0 need to check if the to address is a contract or not\n            if (contractCallPayload.length > 0) {\n                // otherwise, need to check if the payload can be delivered to the toAddress\n                address toAddress = address(0);\n                if (toAddressBytes.length > 0) {\n                    assembly {\n                        toAddress := mload(add(toAddressBytes, 20))\n                    }\n                }\n\n                // check if the toAddress is a contract. We are not concerned about addresses that pretend to be wallets. because worst case we just delete their payload if being malicious\n                // we can guarantee that if a size > 0, then the contract is definitely a contract address in this context\n                uint size;\n                assembly {\n                    size := extcodesize(toAddress)\n                }\n\n                if (size == 0) {\n                    // size == 0 indicates its not a contract, payload wont be delivered\n                    // secure the _payload to make sure funds can be delivered to the toAddress\n                    bytes memory newToAddressBytes = abi.encodePacked(toAddress);\n                    bytes memory securePayload = abi.encode(\n                        functionType,\n                        srcPoolId,\n                        dstPoolId,\n                        dstGasForCall,\n                        c,\n                        s,\n                        newToAddressBytes,\n                        bytes(\"\")\n                    );\n                    return securePayload;\n                }\n            }\n        }\n\n        // default to return the original payload\n        return _payload;\n    }\n\n    function secureStgTokenPayload(bytes memory _payload) external pure returns (bytes memory) {\n        return _secureStgTokenPayload(_payload);\n    }\n\n    function secureStgPayload(bytes memory _payload) external view returns (bytes memory) {\n        return _secureStgPayload(_payload);\n    }\n\n    function _getVerifiedLog(\n        bytes32 hashRoot,\n        uint[] memory paths,\n        uint logIndex,\n        bytes[] memory proof\n    ) internal pure returns (ULNLog memory) {\n        require(paths.length == proof.length, \"ProofLib: invalid proof size\");\n\n        RLPDecode.RLPItem memory item;\n        bytes memory proofBytes;\n\n        for (uint i = 0; i < proof.length; i++) {\n            proofBytes = proof[i];\n            require(hashRoot == keccak256(proofBytes), \"ProofLib: invalid hashlink\");\n            item = RLPDecode.toRlpItem(proofBytes).safeGetItemByIndex(paths[i]);\n            if (i < proof.length - 1) hashRoot = bytes32(item.toUint());\n        }\n\n        // burning status + gasUsed + logBloom\n        RLPDecode.RLPItem memory logItem = item.typeOffset().safeGetItemByIndex(3);\n        RLPDecode.Iterator memory it = logItem.safeGetItemByIndex(logIndex).iterator();\n        ULNLog memory log;\n        log.contractAddress = bytes32(it.next().toUint());\n        log.topicZeroSig = bytes32(it.next().getItemByIndex(0).toUint());\n        log.data = it.next().toBytes();\n\n        return log;\n    }\n\n    // profiling and test\n    function getVerifyLog(\n        bytes32 hashRoot,\n        uint[] memory receiptSlotIndex,\n        uint logIndex,\n        bytes[] memory proof\n    ) external pure returns (ULNLog memory) {\n        return _getVerifiedLog(hashRoot, receiptSlotIndex, logIndex, proof);\n    }\n\n    function getPacket(\n        bytes memory data,\n        uint16 srcChain,\n        uint sizeOfSrcAddress,\n        bytes32 ulnAddress\n    ) external pure returns (LayerZeroPacket.Packet memory) {\n        return _getPacket(data, srcChain, sizeOfSrcAddress, ulnAddress);\n    }\n\n    function _getPacket(\n        bytes memory data,\n        uint16 srcChain,\n        uint sizeOfSrcAddress,\n        bytes32 ulnAddress\n    ) internal pure returns (LayerZeroPacket.Packet memory) {\n        uint16 dstChainId;\n        address dstAddress;\n        uint size;\n        uint64 nonce;\n\n        // The log consists of the destination chain id and then a bytes payload\n        //      0--------------------------------------------31\n        // 0   |  destination chain id\n        // 32  |  defines bytes array\n        // 64  |\n        // 96  |  bytes array size\n        // 128 |  payload\n        assembly {\n            dstChainId := mload(add(data, 32))\n            size := mload(add(data, 96)) /// size of the byte array\n            nonce := mload(add(data, 104)) // offset to convert to uint64  128  is index -24\n            dstAddress := mload(add(data, sub(add(128, sizeOfSrcAddress), 4))) // offset to convert to address 12 -8\n        }\n\n        Buffer.buffer memory srcAddressBuffer;\n        srcAddressBuffer.init(sizeOfSrcAddress);\n        srcAddressBuffer.writeRawBytes(0, data, 136, sizeOfSrcAddress); // 128 + 8\n\n        uint payloadSize = size.sub(20).sub(sizeOfSrcAddress);\n        Buffer.buffer memory payloadBuffer;\n        payloadBuffer.init(payloadSize);\n        payloadBuffer.writeRawBytes(0, data, sizeOfSrcAddress.add(156), payloadSize); // 148 + 8\n        return\n            LayerZeroPacket.Packet(\n                srcChain,\n                dstChainId,\n                nonce,\n                dstAddress,\n                srcAddressBuffer.buf,\n                ulnAddress,\n                payloadBuffer.buf\n            );\n    }\n}\n"
    },
    "contracts/V1Contracts/contracts/proof/MPTValidatorV2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"./utility/LayerZeroPacket.sol\";\nimport \"./utility/Buffer.sol\";\nimport \"../interfaces/ILayerZeroValidationLibrary.sol\";\nimport \"./utility/UltraLightNodeEVMDecoder.sol\";\n\ncontract MPTValidatorV2 is ILayerZeroValidationLibrary {\n    using RLPDecode for RLPDecode.RLPItem;\n    using RLPDecode for RLPDecode.Iterator;\n    using Buffer for Buffer.buffer;\n    using SafeMath for uint;\n\n    bytes32 public constant PACKET_SIGNATURE = 0xe8d23d927749ec8e512eb885679c2977d57068839d8cca1a85685dbbea0648f6;\n\n    struct ULNLog {\n        bytes32 contractAddress;\n        bytes32 topicZeroSig;\n        bytes data;\n    }\n\n    function validateProof(\n        bytes32 _receiptsRoot,\n        bytes calldata _transactionProof,\n        uint _remoteAddressSize\n    ) external pure override returns (LayerZeroPacket.Packet memory packet) {\n        (uint16 remoteChainId, bytes[] memory proof, uint[] memory receiptSlotIndex, uint logIndex) = abi.decode(\n            _transactionProof,\n            (uint16, bytes[], uint[], uint)\n        );\n\n        ULNLog memory log = _getVerifiedLog(_receiptsRoot, receiptSlotIndex, logIndex, proof);\n        require(log.topicZeroSig == PACKET_SIGNATURE, \"ProofLib: packet not recognized\"); //data\n\n        return _getPacket(log.data, remoteChainId, _remoteAddressSize, log.contractAddress);\n    }\n\n    function _getVerifiedLog(\n        bytes32 hashRoot,\n        uint[] memory paths,\n        uint logIndex,\n        bytes[] memory proof\n    ) internal pure returns (ULNLog memory) {\n        require(paths.length == proof.length, \"ProofLib: invalid proof size\");\n\n        RLPDecode.RLPItem memory item;\n        bytes memory proofBytes;\n\n        for (uint i = 0; i < proof.length; i++) {\n            proofBytes = proof[i];\n            require(hashRoot == keccak256(proofBytes), \"ProofLib: invalid hashlink\");\n            item = RLPDecode.toRlpItem(proofBytes).safeGetItemByIndex(paths[i]);\n            if (i < proof.length - 1) hashRoot = bytes32(item.toUint());\n        }\n\n        // burning status + gasUsed + logBloom\n        RLPDecode.RLPItem memory logItem = item.typeOffset().safeGetItemByIndex(3);\n        RLPDecode.Iterator memory it = logItem.safeGetItemByIndex(logIndex).iterator();\n        ULNLog memory log;\n        log.contractAddress = bytes32(it.next().toUint());\n        log.topicZeroSig = bytes32(it.next().getItemByIndex(0).toUint());\n        log.data = it.next().toBytes();\n\n        return log;\n    }\n\n    // profiling and test\n    function getVerifyLog(\n        bytes32 hashRoot,\n        uint[] memory receiptSlotIndex,\n        uint logIndex,\n        bytes[] memory proof\n    ) external pure returns (ULNLog memory) {\n        return _getVerifiedLog(hashRoot, receiptSlotIndex, logIndex, proof);\n    }\n\n    function getPacket(\n        bytes memory data,\n        uint16 srcChain,\n        uint sizeOfSrcAddress,\n        bytes32 ulnAddress\n    ) external pure returns (LayerZeroPacket.Packet memory) {\n        return _getPacket(data, srcChain, sizeOfSrcAddress, ulnAddress);\n    }\n\n    function _getPacket(\n        bytes memory data,\n        uint16 srcChain,\n        uint sizeOfSrcAddress,\n        bytes32 ulnAddress\n    ) internal pure returns (LayerZeroPacket.Packet memory) {\n        uint16 dstChainId;\n        address dstAddress;\n        uint size;\n        uint64 nonce;\n\n        // The log consists of the destination chain id and then a bytes payload\n        //      0--------------------------------------------31\n        // 0   |  destination chain id\n        // 32  |  defines bytes array\n        // 64  |\n        // 96  |  bytes array size\n        // 128 |  payload\n        assembly {\n            dstChainId := mload(add(data, 32))\n            size := mload(add(data, 96)) /// size of the byte array\n            nonce := mload(add(data, 104)) // offset to convert to uint64  128  is index -24\n            dstAddress := mload(add(data, sub(add(128, sizeOfSrcAddress), 4))) // offset to convert to address 12 -8\n        }\n\n        Buffer.buffer memory srcAddressBuffer;\n        srcAddressBuffer.init(sizeOfSrcAddress);\n        srcAddressBuffer.writeRawBytes(0, data, 136, sizeOfSrcAddress); // 128 + 8\n\n        uint payloadSize = size.sub(20).sub(sizeOfSrcAddress);\n        Buffer.buffer memory payloadBuffer;\n        payloadBuffer.init(payloadSize);\n        payloadBuffer.writeRawBytes(0, data, sizeOfSrcAddress.add(156), payloadSize); // 148 + 8\n        return\n            LayerZeroPacket.Packet(\n                srcChain,\n                dstChainId,\n                nonce,\n                dstAddress,\n                srcAddressBuffer.buf,\n                ulnAddress,\n                payloadBuffer.buf\n            );\n    }\n}\n"
    },
    "contracts/V1Contracts/contracts/proof/MPTValidatorV4.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"../interfaces/IValidationLibraryHelper.sol\";\nimport \"./utility/LayerZeroPacket.sol\";\nimport \"./utility/UltraLightNodeEVMDecoder.sol\";\n\ninterface IUltraLightNode {\n    struct BlockData {\n        uint confirmations;\n        bytes32 data;\n    }\n\n    struct ApplicationConfiguration {\n        uint16 inboundProofLibraryVersion;\n        uint64 inboundBlockConfirmations;\n        address relayer;\n        uint16 outboundProofType;\n        uint64 outboundBlockConfirmations;\n        address oracle;\n    }\n\n    function getAppConfig(\n        uint16 _chainId,\n        address userApplicationAddress\n    ) external view returns (ApplicationConfiguration memory);\n\n    function getBlockHeaderData(\n        address _oracle,\n        uint16 _remoteChainId,\n        bytes32 _lookupHash\n    ) external view returns (BlockData memory blockData);\n}\n\ninterface IStargate {\n    // Stargate objects for abi encoding / decoding\n    struct SwapObj {\n        uint amount;\n        uint eqFee;\n        uint eqReward;\n        uint lpFee;\n        uint protocolFee;\n        uint lkbRemove;\n    }\n\n    struct CreditObj {\n        uint credits;\n        uint idealBalance;\n    }\n}\n\ncontract MPTValidatorV4 is ILayerZeroValidationLibrary, IValidationLibraryHelper {\n    using RLPDecode for RLPDecode.RLPItem;\n    using RLPDecode for RLPDecode.Iterator;\n    using LayerZeroPacket for bytes;\n\n    uint8 public utilsVersion = 3;\n    bytes32 public constant PACKET_SIGNATURE = 0xe8d23d927749ec8e512eb885679c2977d57068839d8cca1a85685dbbea0648f6;\n\n    address public immutable stargateBridgeAddress;\n    address public immutable stgTokenAddress;\n    uint16 public immutable localChainId;\n    IUltraLightNode public immutable uln;\n\n    constructor(address _stargateBridgeAddress, address _stgTokenAddress, uint16 _localChainId, address _ulnAddress) {\n        stargateBridgeAddress = _stargateBridgeAddress;\n        stgTokenAddress = _stgTokenAddress;\n        localChainId = _localChainId;\n        uln = IUltraLightNode(_ulnAddress);\n    }\n\n    function validateProof(\n        bytes32 _receiptsRoot,\n        bytes calldata _transactionProof,\n        uint _remoteAddressSize\n    ) external view override returns (LayerZeroPacket.Packet memory) {\n        require(_remoteAddressSize > 0, \"ProofLib: invalid address size\");\n\n        (\n            uint16 remoteChainId,\n            bytes32 blockHash,\n            bytes[] memory proof,\n            uint[] memory receiptSlotIndex,\n            uint logIndex\n        ) = abi.decode(_transactionProof, (uint16, bytes32, bytes[], uint[], uint));\n\n        ULNLog memory log = _getVerifiedLog(_receiptsRoot, receiptSlotIndex, logIndex, proof);\n        require(log.topicZeroSig == PACKET_SIGNATURE, \"ProofLib: packet not recognized\"); //data\n\n        LayerZeroPacket.Packet memory packet = log.data.getPacket(\n            remoteChainId,\n            _remoteAddressSize,\n            log.contractAddress\n        );\n\n        _assertMessagePath(packet, blockHash, _receiptsRoot);\n\n        if (packet.dstAddress == stargateBridgeAddress) packet.payload = _secureStgPayload(packet.payload);\n\n        if (packet.dstAddress == stgTokenAddress) packet.payload = _secureStgTokenPayload(packet.payload);\n\n        return packet;\n    }\n\n    function _assertMessagePath(\n        LayerZeroPacket.Packet memory packet,\n        bytes32 blockHash,\n        bytes32 receiptsRoot\n    ) internal view {\n        require(packet.dstChainId == localChainId, \"ProofLib: invalid destination chain ID\");\n\n        IUltraLightNode.ApplicationConfiguration memory appConfig = uln.getAppConfig(\n            packet.srcChainId,\n            packet.dstAddress\n        );\n        IUltraLightNode.BlockData memory blockData = uln.getBlockHeaderData(\n            appConfig.oracle,\n            packet.srcChainId,\n            blockHash\n        );\n\n        require(blockData.data == receiptsRoot, \"ProofLib: invalid receipt root\");\n\n        require(\n            blockData.confirmations >= appConfig.inboundBlockConfirmations,\n            \"ProofLib: not enough block confirmations\"\n        );\n    }\n\n    function _secureStgTokenPayload(bytes memory _payload) internal pure returns (bytes memory) {\n        (bytes memory toAddressBytes, uint qty) = abi.decode(_payload, (bytes, uint));\n\n        address toAddress = address(0);\n        if (toAddressBytes.length > 0) {\n            assembly {\n                toAddress := mload(add(toAddressBytes, 20))\n            }\n        }\n\n        if (toAddress == address(0)) {\n            address deadAddress = address(0x000000000000000000000000000000000000dEaD);\n            bytes memory newToAddressBytes = abi.encodePacked(deadAddress);\n            return abi.encode(newToAddressBytes, qty);\n        }\n\n        // default to return the original payload\n        return _payload;\n    }\n\n    function _secureStgPayload(bytes memory _payload) internal view returns (bytes memory) {\n        // functionType is uint8 even though the encoding will take up the side of uint256\n        uint8 functionType;\n        assembly {\n            functionType := mload(add(_payload, 32))\n        }\n\n        // TYPE_SWAP_REMOTE == 1 && only if the payload has a payload\n        // only swapRemote inside of stargate can call sgReceive on an user supplied to address\n        // thus we do not care about the other type functions even if the toAddress is overly long.\n        if (functionType == 1) {\n            // decode the _payload with its types\n            (\n                ,\n                uint srcPoolId,\n                uint dstPoolId,\n                uint dstGasForCall,\n                IStargate.CreditObj memory c,\n                IStargate.SwapObj memory s,\n                bytes memory toAddressBytes,\n                bytes memory contractCallPayload\n            ) = abi.decode(_payload, (uint8, uint, uint, uint, IStargate.CreditObj, IStargate.SwapObj, bytes, bytes));\n\n            // if contractCallPayload.length > 0 need to check if the to address is a contract or not\n            if (contractCallPayload.length > 0) {\n                // otherwise, need to check if the payload can be delivered to the toAddress\n                address toAddress = address(0);\n                if (toAddressBytes.length > 0) {\n                    assembly {\n                        toAddress := mload(add(toAddressBytes, 20))\n                    }\n                }\n\n                // check if the toAddress is a contract. We are not concerned about addresses that pretend to be wallets. because worst case we just delete their payload if being malicious\n                // we can guarantee that if a size > 0, then the contract is definitely a contract address in this context\n                uint size;\n                assembly {\n                    size := extcodesize(toAddress)\n                }\n\n                if (size == 0) {\n                    // size == 0 indicates its not a contract, payload wont be delivered\n                    // secure the _payload to make sure funds can be delivered to the toAddress\n                    bytes memory newToAddressBytes = abi.encodePacked(toAddress);\n                    bytes memory securePayload = abi.encode(\n                        functionType,\n                        srcPoolId,\n                        dstPoolId,\n                        dstGasForCall,\n                        c,\n                        s,\n                        newToAddressBytes,\n                        bytes(\"\")\n                    );\n                    return securePayload;\n                }\n            }\n        }\n\n        // default to return the original payload\n        return _payload;\n    }\n\n    function secureStgTokenPayload(bytes memory _payload) external pure returns (bytes memory) {\n        return _secureStgTokenPayload(_payload);\n    }\n\n    function secureStgPayload(bytes memory _payload) external view returns (bytes memory) {\n        return _secureStgPayload(_payload);\n    }\n\n    function _getVerifiedLog(\n        bytes32 hashRoot,\n        uint[] memory paths,\n        uint logIndex,\n        bytes[] memory proof\n    ) internal pure returns (ULNLog memory) {\n        require(paths.length == proof.length, \"ProofLib: invalid proof size\");\n        require(proof.length > 0, \"ProofLib: proof size must > 0\");\n        RLPDecode.RLPItem memory item;\n        bytes memory proofBytes;\n\n        for (uint i = 0; i < proof.length; i++) {\n            proofBytes = proof[i];\n            require(hashRoot == keccak256(proofBytes), \"ProofLib: invalid hashlink\");\n            item = RLPDecode.toRlpItem(proofBytes).safeGetItemByIndex(paths[i]);\n            if (i < proof.length - 1) hashRoot = bytes32(item.toUint());\n        }\n\n        // burning status + gasUsed + logBloom\n        RLPDecode.RLPItem memory logItem = item.typeOffset().safeGetItemByIndex(3);\n        RLPDecode.Iterator memory it = logItem.safeGetItemByIndex(logIndex).iterator();\n        ULNLog memory log;\n        log.contractAddress = bytes32(it.next().toUint());\n        log.topicZeroSig = bytes32(it.next().safeGetItemByIndex(0).toUint());\n        log.data = it.next().toBytes();\n\n        return log;\n    }\n\n    function getUtilsVersion() external view override returns (uint8) {\n        return utilsVersion;\n    }\n\n    function getVerifyLog(\n        bytes32 hashRoot,\n        uint[] memory receiptSlotIndex,\n        uint logIndex,\n        bytes[] memory proof\n    ) external pure override returns (ULNLog memory) {\n        return _getVerifiedLog(hashRoot, receiptSlotIndex, logIndex, proof);\n    }\n\n    function getPacket(\n        bytes memory data,\n        uint16 srcChain,\n        uint sizeOfSrcAddress,\n        bytes32 ulnAddress\n    ) external pure override returns (LayerZeroPacket.Packet memory) {\n        return data.getPacket(srcChain, sizeOfSrcAddress, ulnAddress);\n    }\n\n    // profiling and test\n    function assertMessagePath(\n        LayerZeroPacket.Packet memory packet,\n        bytes32 blockHash,\n        bytes32 receiptsRoot\n    ) external view {\n        _assertMessagePath(packet, blockHash, receiptsRoot);\n    }\n}\n"
    },
    "contracts/V1Contracts/contracts/proof/MPTValidatorV5.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"../interfaces/IValidationLibraryHelper.sol\";\nimport \"./utility/LayerZeroPacket.sol\";\nimport \"./utility/UltraLightNodeEVMDecoder.sol\";\n\ninterface IUltraLightNode {\n    struct BlockData {\n        uint confirmations;\n        bytes32 data;\n    }\n\n    struct ApplicationConfiguration {\n        uint16 inboundProofLibraryVersion;\n        uint64 inboundBlockConfirmations;\n        address relayer;\n        uint16 outboundProofType;\n        uint64 outboundBlockConfirmations;\n        address oracle;\n    }\n\n    function getAppConfig(\n        uint16 _chainId,\n        address userApplicationAddress\n    ) external view returns (ApplicationConfiguration memory);\n\n    function getBlockHeaderData(\n        address _oracle,\n        uint16 _remoteChainId,\n        bytes32 _lookupHash\n    ) external view returns (BlockData memory blockData);\n}\n\ninterface IStargate {\n    // Stargate objects for abi encoding / decoding\n    struct SwapObj {\n        uint amount;\n        uint eqFee;\n        uint eqReward;\n        uint lpFee;\n        uint protocolFee;\n        uint lkbRemove;\n    }\n\n    struct CreditObj {\n        uint credits;\n        uint idealBalance;\n    }\n}\n\ncontract MPTValidatorV5 is ILayerZeroValidationLibrary, IValidationLibraryHelper {\n    using RLPDecode for RLPDecode.RLPItem;\n    using RLPDecode for RLPDecode.Iterator;\n    using LayerZeroPacket for bytes;\n\n    uint8 public utilsVersion = 3;\n    bytes32 public constant PACKET_SIGNATURE = 0xe8d23d927749ec8e512eb885679c2977d57068839d8cca1a85685dbbea0648f6;\n\n    address public immutable stargateBridgeAddress;\n    address public immutable stgTokenAddress;\n    address public immutable relayerAddress;\n    uint16 public immutable localChainId;\n    IUltraLightNode public immutable uln;\n\n    constructor(\n        address _stargateBridgeAddress,\n        address _stgTokenAddress,\n        uint16 _localChainId,\n        address _ulnAddress,\n        address _relayerAddress\n    ) {\n        stargateBridgeAddress = _stargateBridgeAddress;\n        stgTokenAddress = _stgTokenAddress;\n        localChainId = _localChainId;\n        uln = IUltraLightNode(_ulnAddress);\n        relayerAddress = _relayerAddress;\n    }\n\n    function validateProof(\n        bytes32 _receiptsRoot,\n        bytes calldata _transactionProof,\n        uint _remoteAddressSize\n    ) external view override returns (LayerZeroPacket.Packet memory) {\n        require(_remoteAddressSize > 0, \"ProofLib: invalid address size\");\n\n        (\n            uint16 remoteChainId,\n            bytes32 blockHash,\n            bytes[] memory proof,\n            uint[] memory receiptSlotIndex,\n            uint logIndex\n        ) = abi.decode(_transactionProof, (uint16, bytes32, bytes[], uint[], uint));\n\n        ULNLog memory log = _getVerifiedLog(_receiptsRoot, receiptSlotIndex, logIndex, proof);\n        require(log.topicZeroSig == PACKET_SIGNATURE, \"ProofLib: packet not recognized\"); //data\n\n        LayerZeroPacket.Packet memory packet = log.data.getPacket(\n            remoteChainId,\n            _remoteAddressSize,\n            log.contractAddress\n        );\n\n        _assertMessagePath(packet, blockHash, _receiptsRoot);\n\n        if (packet.dstAddress == stargateBridgeAddress) packet.payload = _secureStgPayload(packet.payload);\n\n        if (packet.dstAddress == stgTokenAddress) packet.payload = _secureStgTokenPayload(packet.payload);\n\n        return packet;\n    }\n\n    function _assertMessagePath(\n        LayerZeroPacket.Packet memory packet,\n        bytes32 blockHash,\n        bytes32 receiptsRoot\n    ) internal view {\n        require(packet.dstChainId == localChainId, \"ProofLib: invalid destination chain ID\");\n\n        IUltraLightNode.ApplicationConfiguration memory appConfig = uln.getAppConfig(\n            packet.srcChainId,\n            packet.dstAddress\n        );\n        IUltraLightNode.BlockData memory blockData = uln.getBlockHeaderData(\n            appConfig.oracle,\n            packet.srcChainId,\n            blockHash\n        );\n        require(appConfig.relayer == relayerAddress, \"ProofLib: invalid relayer\");\n\n        require(blockData.data == receiptsRoot, \"ProofLib: invalid receipt root\");\n\n        require(\n            blockData.confirmations >= appConfig.inboundBlockConfirmations,\n            \"ProofLib: not enough block confirmations\"\n        );\n    }\n\n    function _secureStgTokenPayload(bytes memory _payload) internal pure returns (bytes memory) {\n        (bytes memory toAddressBytes, uint qty) = abi.decode(_payload, (bytes, uint));\n\n        address toAddress = address(0);\n        if (toAddressBytes.length > 0) {\n            assembly {\n                toAddress := mload(add(toAddressBytes, 20))\n            }\n        }\n\n        if (toAddress == address(0)) {\n            address deadAddress = address(0x000000000000000000000000000000000000dEaD);\n            bytes memory newToAddressBytes = abi.encodePacked(deadAddress);\n            return abi.encode(newToAddressBytes, qty);\n        }\n\n        // default to return the original payload\n        return _payload;\n    }\n\n    function _secureStgPayload(bytes memory _payload) internal view returns (bytes memory) {\n        // functionType is uint8 even though the encoding will take up the side of uint256\n        uint8 functionType;\n        assembly {\n            functionType := mload(add(_payload, 32))\n        }\n\n        // TYPE_SWAP_REMOTE == 1 && only if the payload has a payload\n        // only swapRemote inside of stargate can call sgReceive on an user supplied to address\n        // thus we do not care about the other type functions even if the toAddress is overly long.\n        if (functionType == 1) {\n            // decode the _payload with its types\n            (\n                ,\n                uint srcPoolId,\n                uint dstPoolId,\n                uint dstGasForCall,\n                IStargate.CreditObj memory c,\n                IStargate.SwapObj memory s,\n                bytes memory toAddressBytes,\n                bytes memory contractCallPayload\n            ) = abi.decode(_payload, (uint8, uint, uint, uint, IStargate.CreditObj, IStargate.SwapObj, bytes, bytes));\n\n            // if contractCallPayload.length > 0 need to check if the to address is a contract or not\n            if (contractCallPayload.length > 0) {\n                // otherwise, need to check if the payload can be delivered to the toAddress\n                address toAddress = address(0);\n                if (toAddressBytes.length > 0) {\n                    assembly {\n                        toAddress := mload(add(toAddressBytes, 20))\n                    }\n                }\n\n                // check if the toAddress is a contract. We are not concerned about addresses that pretend to be wallets. because worst case we just delete their payload if being malicious\n                // we can guarantee that if a size > 0, then the contract is definitely a contract address in this context\n                uint size;\n                assembly {\n                    size := extcodesize(toAddress)\n                }\n\n                if (size == 0) {\n                    // size == 0 indicates its not a contract, payload wont be delivered\n                    // secure the _payload to make sure funds can be delivered to the toAddress\n                    bytes memory newToAddressBytes = abi.encodePacked(toAddress);\n                    bytes memory securePayload = abi.encode(\n                        functionType,\n                        srcPoolId,\n                        dstPoolId,\n                        dstGasForCall,\n                        c,\n                        s,\n                        newToAddressBytes,\n                        bytes(\"\")\n                    );\n                    return securePayload;\n                }\n            }\n        }\n\n        // default to return the original payload\n        return _payload;\n    }\n\n    function secureStgTokenPayload(bytes memory _payload) external pure returns (bytes memory) {\n        return _secureStgTokenPayload(_payload);\n    }\n\n    function secureStgPayload(bytes memory _payload) external view returns (bytes memory) {\n        return _secureStgPayload(_payload);\n    }\n\n    function _getVerifiedLog(\n        bytes32 hashRoot,\n        uint[] memory paths,\n        uint logIndex,\n        bytes[] memory proof\n    ) internal pure returns (ULNLog memory) {\n        require(paths.length == proof.length, \"ProofLib: invalid proof size\");\n        require(proof.length > 0, \"ProofLib: proof size must > 0\");\n        RLPDecode.RLPItem memory item;\n        bytes memory proofBytes;\n\n        for (uint i = 0; i < proof.length; i++) {\n            proofBytes = proof[i];\n            require(hashRoot == keccak256(proofBytes), \"ProofLib: invalid hashlink\");\n            item = RLPDecode.toRlpItem(proofBytes).safeGetItemByIndex(paths[i]);\n            if (i < proof.length - 1) hashRoot = bytes32(item.toUint());\n        }\n\n        // burning status + gasUsed + logBloom\n        RLPDecode.RLPItem memory logItem = item.typeOffset().safeGetItemByIndex(3);\n        RLPDecode.Iterator memory it = logItem.safeGetItemByIndex(logIndex).iterator();\n        ULNLog memory log;\n        log.contractAddress = bytes32(it.next().toUint());\n        log.topicZeroSig = bytes32(it.next().safeGetItemByIndex(0).toUint());\n        log.data = it.next().toBytes();\n\n        return log;\n    }\n\n    function getUtilsVersion() external view override returns (uint8) {\n        return utilsVersion;\n    }\n\n    function getVerifyLog(\n        bytes32 hashRoot,\n        uint[] memory receiptSlotIndex,\n        uint logIndex,\n        bytes[] memory proof\n    ) external pure override returns (ULNLog memory) {\n        return _getVerifiedLog(hashRoot, receiptSlotIndex, logIndex, proof);\n    }\n\n    function getPacket(\n        bytes memory data,\n        uint16 srcChain,\n        uint sizeOfSrcAddress,\n        bytes32 ulnAddress\n    ) external pure override returns (LayerZeroPacket.Packet memory) {\n        return data.getPacket(srcChain, sizeOfSrcAddress, ulnAddress);\n    }\n\n    // profiling and test\n    function assertMessagePath(\n        LayerZeroPacket.Packet memory packet,\n        bytes32 blockHash,\n        bytes32 receiptsRoot\n    ) external view {\n        _assertMessagePath(packet, blockHash, receiptsRoot);\n    }\n}\n"
    },
    "contracts/V1Contracts/contracts/proof/utility/Buffer.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n// https://github.com/ensdomains/buffer\n\npragma solidity ^0.7.0;\n\n/**\n * @dev A library for working with mutable byte buffers in Solidity.\n *\n * Byte buffers are mutable and expandable, and provide a variety of primitives\n * for writing to them. At any time you can fetch a bytes object containing the\n * current contents of the buffer. The bytes object should not be stored between\n * operations, as it may change due to resizing of the buffer.\n */\nlibrary Buffer {\n    /**\n     * @dev Represents a mutable buffer. Buffers have a current value (buf) and\n     *      a capacity. The capacity may be longer than the current value, in\n     *      which case it can be extended without the need to allocate more memory.\n     */\n    struct buffer {\n        bytes buf;\n        uint capacity;\n    }\n\n    /**\n     * @dev Initializes a buffer with an initial capacity.a co\n     * @param buf The buffer to initialize.\n     * @param capacity The number of bytes of space to allocate the buffer.\n     * @return The buffer, for chaining.\n     */\n    function init(buffer memory buf, uint capacity) internal pure returns (buffer memory) {\n        if (capacity % 32 != 0) {\n            capacity += 32 - (capacity % 32);\n        }\n        // Allocate space for the buffer data\n        buf.capacity = capacity;\n        assembly {\n            let ptr := mload(0x40)\n            mstore(buf, ptr)\n            mstore(ptr, 0)\n            mstore(0x40, add(32, add(ptr, capacity)))\n        }\n        return buf;\n    }\n\n    /**\n     * @dev Writes a byte string to a buffer. Resizes if doing so would exceed\n     *      the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param off The start offset to write to.\n     * @param rawData The data to append.\n     * @param len The number of bytes to copy.\n     * @return The original buffer, for chaining.\n     */\n    function writeRawBytes(\n        buffer memory buf,\n        uint off,\n        bytes memory rawData,\n        uint offData,\n        uint len\n    ) internal pure returns (buffer memory) {\n        if (off + len > buf.capacity) {\n            resize(buf, max(buf.capacity, len + off) * 2);\n        }\n\n        uint dest;\n        uint src;\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Length of existing buffer data\n            let buflen := mload(bufptr)\n            // Start address = buffer address + offset + sizeof(buffer length)\n            dest := add(add(bufptr, 32), off)\n            // Update buffer length if we're extending it\n            if gt(add(len, off), buflen) {\n                mstore(bufptr, add(len, off))\n            }\n            src := add(rawData, offData)\n        }\n\n        // Copy word-length chunks while possible\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        uint mask = 256 ** (32 - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n\n        return buf;\n    }\n\n    /**\n     * @dev Writes a byte string to a buffer. Resizes if doing so would exceed\n     *      the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param off The start offset to write to.\n     * @param data The data to append.\n     * @param len The number of bytes to copy.\n     * @return The original buffer, for chaining.\n     */\n    function write(buffer memory buf, uint off, bytes memory data, uint len) internal pure returns (buffer memory) {\n        require(len <= data.length);\n\n        if (off + len > buf.capacity) {\n            resize(buf, max(buf.capacity, len + off) * 2);\n        }\n\n        uint dest;\n        uint src;\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Length of existing buffer data\n            let buflen := mload(bufptr)\n            // Start address = buffer address + offset + sizeof(buffer length)\n            dest := add(add(bufptr, 32), off)\n            // Update buffer length if we're extending it\n            if gt(add(len, off), buflen) {\n                mstore(bufptr, add(len, off))\n            }\n            src := add(data, 32)\n        }\n\n        // Copy word-length chunks while possible\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        uint mask = 256 ** (32 - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n\n        return buf;\n    }\n\n    function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\n        return write(buf, buf.buf.length, data, data.length);\n    }\n\n    function resize(buffer memory buf, uint capacity) private pure {\n        bytes memory oldbuf = buf.buf;\n        init(buf, capacity);\n        append(buf, oldbuf);\n    }\n\n    function max(uint a, uint b) private pure returns (uint) {\n        if (a > b) {\n            return a;\n        }\n        return b;\n    }\n}\n"
    },
    "contracts/V1Contracts/contracts/proof/utility/LayerZeroPacket.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\n\nimport \"./Buffer.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nlibrary LayerZeroPacket {\n    using Buffer for Buffer.buffer;\n    using SafeMath for uint;\n\n    struct Packet {\n        uint16 srcChainId;\n        uint16 dstChainId;\n        uint64 nonce;\n        address dstAddress;\n        bytes srcAddress;\n        bytes32 ulnAddress;\n        bytes payload;\n    }\n\n    function getPacket(\n        bytes memory data,\n        uint16 srcChain,\n        uint sizeOfSrcAddress,\n        bytes32 ulnAddress\n    ) internal pure returns (LayerZeroPacket.Packet memory) {\n        uint16 dstChainId;\n        address dstAddress;\n        uint size;\n        uint64 nonce;\n\n        // The log consists of the destination chain id and then a bytes payload\n        //      0--------------------------------------------31\n        // 0   |  total bytes size\n        // 32  |  destination chain id\n        // 64  |  bytes offset\n        // 96  |  bytes array size\n        // 128 |  payload\n        assembly {\n            dstChainId := mload(add(data, 32))\n            size := mload(add(data, 96)) /// size of the byte array\n            nonce := mload(add(data, 104)) // offset to convert to uint64  128  is index -24\n            dstAddress := mload(add(data, sub(add(128, sizeOfSrcAddress), 4))) // offset to convert to address 12 -8\n        }\n\n        Buffer.buffer memory srcAddressBuffer;\n        srcAddressBuffer.init(sizeOfSrcAddress);\n        srcAddressBuffer.writeRawBytes(0, data, 136, sizeOfSrcAddress); // 128 + 8\n\n        uint payloadSize = size.sub(28).sub(sizeOfSrcAddress);\n        Buffer.buffer memory payloadBuffer;\n        payloadBuffer.init(payloadSize);\n        payloadBuffer.writeRawBytes(0, data, sizeOfSrcAddress.add(156), payloadSize); // 148 + 8\n        return\n            LayerZeroPacket.Packet(\n                srcChain,\n                dstChainId,\n                nonce,\n                dstAddress,\n                srcAddressBuffer.buf,\n                ulnAddress,\n                payloadBuffer.buf\n            );\n    }\n\n    function getPacketV2(\n        bytes memory data,\n        uint sizeOfSrcAddress,\n        bytes32 ulnAddress\n    ) internal pure returns (LayerZeroPacket.Packet memory) {\n        // packet def: abi.encodePacked(nonce, srcChain, srcAddress, dstChain, dstAddress, payload);\n        // data def: abi.encode(packet) = offset(32) + length(32) + packet\n        //              if from EVM\n        // 0 - 31       0 - 31          |  total bytes size\n        // 32 - 63      32 - 63         |  location\n        // 64 - 95      64 - 95         |  size of the packet\n        // 96 - 103     96 - 103        |  nonce\n        // 104 - 105    104 - 105       |  srcChainId\n        // 106 - P      106 - 125       |  srcAddress, where P = 106 + sizeOfSrcAddress - 1,\n        // P+1 - P+2    126 - 127       |  dstChainId\n        // P+3 - P+22   128 - 147       |  dstAddress\n        // P+23 - END   148 - END       |  payload\n\n        // decode the packet\n        uint256 realSize;\n        uint64 nonce;\n        uint16 srcChain;\n        uint16 dstChain;\n        address dstAddress;\n        assembly {\n            realSize := mload(add(data, 64))\n            nonce := mload(add(data, 72)) // 104 - 32\n            srcChain := mload(add(data, 74)) // 106 - 32\n            dstChain := mload(add(data, add(76, sizeOfSrcAddress))) // P + 3 - 32 = 105 + size + 3 - 32 = 76 + size\n            dstAddress := mload(add(data, add(96, sizeOfSrcAddress))) // P + 23 - 32 = 105 + size + 23 - 32 = 96 + size\n        }\n\n        require(srcChain != 0, \"LayerZeroPacket: invalid packet\");\n\n        Buffer.buffer memory srcAddressBuffer;\n        srcAddressBuffer.init(sizeOfSrcAddress);\n        srcAddressBuffer.writeRawBytes(0, data, 106, sizeOfSrcAddress);\n\n        uint nonPayloadSize = sizeOfSrcAddress.add(32); // 2 + 2 + 8 + 20, 32 + 20 = 52 if sizeOfSrcAddress == 20\n        uint payloadSize = realSize.sub(nonPayloadSize);\n        Buffer.buffer memory payloadBuffer;\n        payloadBuffer.init(payloadSize);\n        payloadBuffer.writeRawBytes(0, data, nonPayloadSize.add(96), payloadSize);\n\n        return\n            LayerZeroPacket.Packet(\n                srcChain,\n                dstChain,\n                nonce,\n                dstAddress,\n                srcAddressBuffer.buf,\n                ulnAddress,\n                payloadBuffer.buf\n            );\n    }\n\n    function getPacketV3(\n        bytes memory data,\n        uint sizeOfSrcAddress,\n        bytes32 ulnAddress\n    ) internal pure returns (LayerZeroPacket.Packet memory) {\n        // data def: abi.encodePacked(nonce, srcChain, srcAddress, dstChain, dstAddress, payload);\n        //              if from EVM\n        // 0 - 31       0 - 31          |  total bytes size\n        // 32 - 39      32 - 39         |  nonce\n        // 40 - 41      40 - 41         |  srcChainId\n        // 42 - P       42 - 61         |  srcAddress, where P = 41 + sizeOfSrcAddress,\n        // P+1 - P+2    62 - 63         |  dstChainId\n        // P+3 - P+22   64 - 83         |  dstAddress\n        // P+23 - END   84 - END        |  payload\n\n        // decode the packet\n        uint256 realSize = data.length;\n        uint nonPayloadSize = sizeOfSrcAddress.add(32); // 2 + 2 + 8 + 20, 32 + 20 = 52 if sizeOfSrcAddress == 20\n        require(realSize >= nonPayloadSize, \"LayerZeroPacket: invalid packet\");\n        uint payloadSize = realSize - nonPayloadSize;\n\n        uint64 nonce;\n        uint16 srcChain;\n        uint16 dstChain;\n        address dstAddress;\n        assembly {\n            nonce := mload(add(data, 8)) // 40 - 32\n            srcChain := mload(add(data, 10)) // 42 - 32\n            dstChain := mload(add(data, add(12, sizeOfSrcAddress))) // P + 3 - 32 = 41 + size + 3 - 32 = 12 + size\n            dstAddress := mload(add(data, add(32, sizeOfSrcAddress))) // P + 23 - 32 = 41 + size + 23 - 32 = 32 + size\n        }\n\n        require(srcChain != 0, \"LayerZeroPacket: invalid packet\");\n\n        Buffer.buffer memory srcAddressBuffer;\n        srcAddressBuffer.init(sizeOfSrcAddress);\n        srcAddressBuffer.writeRawBytes(0, data, 42, sizeOfSrcAddress);\n\n        Buffer.buffer memory payloadBuffer;\n        if (payloadSize > 0) {\n            payloadBuffer.init(payloadSize);\n            payloadBuffer.writeRawBytes(0, data, nonPayloadSize.add(32), payloadSize);\n        }\n\n        return\n            LayerZeroPacket.Packet(\n                srcChain,\n                dstChain,\n                nonce,\n                dstAddress,\n                srcAddressBuffer.buf,\n                ulnAddress,\n                payloadBuffer.buf\n            );\n    }\n}\n"
    },
    "contracts/V1Contracts/contracts/proof/utility/RLPDecode.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n// https://github.com/hamdiallam/solidity-rlp\n\npragma solidity ^0.7.0;\n\nlibrary RLPDecode {\n    uint8 constant STRING_SHORT_START = 0x80;\n    uint8 constant STRING_LONG_START = 0xb8;\n    uint8 constant LIST_SHORT_START = 0xc0;\n    uint8 constant LIST_LONG_START = 0xf8;\n    uint8 constant WORD_SIZE = 32;\n\n    struct RLPItem {\n        uint len;\n        uint memPtr;\n    }\n\n    struct Iterator {\n        RLPItem item; // Item that's being iterated over.\n        uint nextPtr; // Position of the next item in the list.\n    }\n\n    /*\n     * @dev Returns the next element in the iteration. Reverts if it has not next element.\n     * @param self The iterator.\n     * @return The next element in the iteration.\n     */\n    function next(Iterator memory self) internal pure returns (RLPItem memory) {\n        require(hasNext(self), \"RLPDecoder iterator has no next\");\n\n        uint ptr = self.nextPtr;\n        uint itemLength = _itemLength(ptr);\n        self.nextPtr = ptr + itemLength;\n\n        return RLPItem(itemLength, ptr);\n    }\n\n    /*\n     * @dev Returns true if the iteration has more elements.\n     * @param self The iterator.\n     * @return true if the iteration has more elements.\n     */\n    function hasNext(Iterator memory self) internal pure returns (bool) {\n        RLPItem memory item = self.item;\n        return self.nextPtr < item.memPtr + item.len;\n    }\n\n    /*\n     * @param item RLP encoded bytes\n     */\n\n    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\n        uint memPtr;\n        assembly {\n            memPtr := add(item, 0x20)\n        }\n        // offset the pointer if the first byte\n\n        uint8 byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n        uint len = item.length;\n        if (len > 0 && byte0 < LIST_SHORT_START) {\n            assembly {\n                memPtr := add(memPtr, 0x01)\n            }\n            len -= 1;\n        }\n        return RLPItem(len, memPtr);\n    }\n\n    /*\n     * @dev Create an iterator. Reverts if item is not a list.\n     * @param self The RLP item.\n     * @return An 'Iterator' over the item.\n     */\n    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {\n        require(isList(self), \"RLPDecoder iterator is not list\");\n\n        uint ptr = self.memPtr + _payloadOffset(self.memPtr);\n        return Iterator(self, ptr);\n    }\n\n    /*\n     * @param item RLP encoded bytes\n     */\n    function rlpLen(RLPItem memory item) internal pure returns (uint) {\n        return item.len;\n    }\n\n    /*\n     * @param item RLP encoded bytes\n     */\n    function payloadLen(RLPItem memory item) internal pure returns (uint) {\n        uint offset = _payloadOffset(item.memPtr);\n        require(item.len >= offset, \"RLPDecoder: invalid uint RLP item offset size\");\n        return item.len - offset;\n    }\n\n    /*\n     * @param item RLP encoded list in bytes\n     */\n    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {\n        require(isList(item), \"RLPDecoder iterator is not a list\");\n\n        uint items = numItems(item);\n        RLPItem[] memory result = new RLPItem[](items);\n\n        uint memPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint dataLen;\n        for (uint i = 0; i < items; i++) {\n            dataLen = _itemLength(memPtr);\n            result[i] = RLPItem(dataLen, memPtr);\n            memPtr = memPtr + dataLen;\n        }\n\n        return result;\n    }\n\n    /*\n     * @param get the RLP item by index. save gas.\n     */\n    function getItemByIndex(RLPItem memory item, uint idx) internal pure returns (RLPItem memory) {\n        require(isList(item), \"RLPDecoder iterator is not a list\");\n\n        uint memPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint dataLen;\n        for (uint i = 0; i < idx; i++) {\n            dataLen = _itemLength(memPtr);\n            memPtr = memPtr + dataLen;\n        }\n        dataLen = _itemLength(memPtr);\n        return RLPItem(dataLen, memPtr);\n    }\n\n    /*\n     * @param get the RLP item by index. save gas.\n     */\n    function safeGetItemByIndex(RLPItem memory item, uint idx) internal pure returns (RLPItem memory) {\n        require(isList(item), \"RLPDecoder iterator is not a list\");\n        require(idx < numItems(item), \"RLP item out of bounds\");\n        uint endPtr = item.memPtr + item.len;\n\n        uint memPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint dataLen;\n        for (uint i = 0; i < idx; i++) {\n            dataLen = _itemLength(memPtr);\n            memPtr = memPtr + dataLen;\n        }\n        dataLen = _itemLength(memPtr);\n\n        require(memPtr + dataLen <= endPtr, \"RLP item overflow\");\n        return RLPItem(dataLen, memPtr);\n    }\n\n    /*\n     * @param offset the receipt bytes item\n     */\n    function typeOffset(RLPItem memory item) internal pure returns (RLPItem memory) {\n        uint offset = _payloadOffset(item.memPtr);\n        uint8 byte0;\n        uint memPtr = item.memPtr;\n        uint len = item.len;\n        assembly {\n            memPtr := add(memPtr, offset)\n            byte0 := byte(0, mload(memPtr))\n        }\n        if (len > 0 && byte0 < LIST_SHORT_START) {\n            assembly {\n                memPtr := add(memPtr, 0x01)\n            }\n            len -= 1;\n        }\n        return RLPItem(len, memPtr);\n    }\n\n    // @return indicator whether encoded payload is a list. negate this function call for isData.\n    function isList(RLPItem memory item) internal pure returns (bool) {\n        if (item.len == 0) return false;\n\n        uint8 byte0;\n        uint memPtr = item.memPtr;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < LIST_SHORT_START) return false;\n        return true;\n    }\n\n    /** RLPItem conversions into data types **/\n\n    // @returns raw rlp encoding in bytes\n    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {\n        bytes memory result = new bytes(item.len);\n        if (result.length == 0) return result;\n\n        uint ptr;\n        assembly {\n            ptr := add(0x20, result)\n        }\n\n        copy(item.memPtr, ptr, item.len);\n        return result;\n    }\n\n    // any non-zero byte except \"0x80\" is considered true\n    function toBoolean(RLPItem memory item) internal pure returns (bool) {\n        require(item.len == 1, \"RLPDecoder toBoolean invalid length\");\n        uint result;\n        uint memPtr = item.memPtr;\n        assembly {\n            result := byte(0, mload(memPtr))\n        }\n\n        // SEE Github Issue #5.\n        // Summary: Most commonly used RLP libraries (i.e Geth) will encode\n        // \"0\" as \"0x80\" instead of as \"0\". We handle this edge case explicitly\n        // here.\n        if (result == 0 || result == STRING_SHORT_START) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    function toAddress(RLPItem memory item) internal pure returns (address) {\n        // 1 byte for the length prefix\n        require(item.len == 21, \"RLPDecoder toAddress invalid length\");\n\n        return address(toUint(item));\n    }\n\n    function toUint(RLPItem memory item) internal pure returns (uint) {\n        require(item.len > 0 && item.len <= 33, \"RLPDecoder toUint invalid length\");\n\n        uint offset = _payloadOffset(item.memPtr);\n        require(item.len >= offset, \"RLPDecoder: invalid RLP item offset size\");\n        uint len = item.len - offset;\n\n        uint result;\n        uint memPtr = item.memPtr + offset;\n        assembly {\n            result := mload(memPtr)\n\n            // shift to the correct location if necessary\n            if lt(len, 32) {\n                result := div(result, exp(256, sub(32, len)))\n            }\n        }\n\n        return result;\n    }\n\n    // enforces 32 byte length\n    function toUintStrict(RLPItem memory item) internal pure returns (uint) {\n        // one byte prefix\n        require(item.len == 33, \"RLPDecoder toUintStrict invalid length\");\n\n        uint result;\n        uint memPtr = item.memPtr + 1;\n        assembly {\n            result := mload(memPtr)\n        }\n\n        return result;\n    }\n\n    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\n        require(item.len > 0, \"RLPDecoder toBytes invalid length\");\n\n        uint offset = _payloadOffset(item.memPtr);\n        require(item.len >= offset, \"RLPDecoder: invalid RLP item offset size\");\n        uint len = item.len - offset; // data length\n        bytes memory result = new bytes(len);\n\n        uint destPtr;\n        assembly {\n            destPtr := add(0x20, result)\n        }\n\n        copy(item.memPtr + offset, destPtr, len);\n        return result;\n    }\n\n    /*\n     * Private Helpers\n     */\n\n    // @return number of payload items inside an encoded list.\n    function numItems(RLPItem memory item) internal pure returns (uint) {\n        if (item.len == 0) return 0;\n\n        uint count = 0;\n        uint currPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint endPtr = item.memPtr + item.len;\n        while (currPtr < endPtr) {\n            currPtr = currPtr + _itemLength(currPtr); // skip over an item\n            count++;\n        }\n\n        return count;\n    }\n\n    // @return entire rlp item byte length\n    function _itemLength(uint memPtr) private pure returns (uint) {\n        uint itemLen;\n        uint byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < STRING_SHORT_START) itemLen = 1;\n        else if (byte0 < STRING_LONG_START) itemLen = byte0 - STRING_SHORT_START + 1;\n        else if (byte0 < LIST_SHORT_START) {\n            assembly {\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\n                memPtr := add(memPtr, 1) // skip over the first byte\n\n                /* 32 byte word size */\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\n                itemLen := add(dataLen, add(byteLen, 1))\n            }\n        } else if (byte0 < LIST_LONG_START) {\n            itemLen = byte0 - LIST_SHORT_START + 1;\n        } else {\n            assembly {\n                let byteLen := sub(byte0, 0xf7)\n                memPtr := add(memPtr, 1)\n\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\n                itemLen := add(dataLen, add(byteLen, 1))\n            }\n        }\n\n        return itemLen;\n    }\n\n    // @return number of bytes until the data\n    function _payloadOffset(uint memPtr) private pure returns (uint) {\n        uint byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < STRING_SHORT_START) return 0;\n        else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START)) return 1;\n        else if (byte0 < LIST_SHORT_START)\n            // being explicit\n            return byte0 - (STRING_LONG_START - 1) + 1;\n        else return byte0 - (LIST_LONG_START - 1) + 1;\n    }\n\n    /*\n     * @param src Pointer to source\n     * @param dest Pointer to destination\n     * @param len Amount of memory to copy from the source\n     */\n    function copy(uint src, uint dest, uint len) private pure {\n        if (len == 0) return;\n\n        // copy as many word sizes as possible\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n\n            src += WORD_SIZE;\n            dest += WORD_SIZE;\n        }\n\n        // left over bytes. Mask is used to remove unwanted bytes from the word\n        uint mask = 256 ** (WORD_SIZE - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask)) // zero out src\n            let destpart := and(mload(dest), mask) // retrieve the bytes\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n}\n"
    },
    "contracts/V1Contracts/contracts/proof/utility/UltraLightNodeEVMDecoder.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.7.0;\npragma abicoder v2;\n\nimport \"./RLPDecode.sol\";\n\nlibrary UltraLightNodeEVMDecoder {\n    using RLPDecode for RLPDecode.RLPItem;\n    using RLPDecode for RLPDecode.Iterator;\n\n    struct Log {\n        address contractAddress;\n        bytes32 topicZero;\n        bytes data;\n    }\n\n    function getReceiptLog(bytes memory data, uint logIndex) internal pure returns (Log memory) {\n        RLPDecode.Iterator memory it = RLPDecode.toRlpItem(data).iterator();\n        uint idx;\n        while (it.hasNext()) {\n            if (idx == 3) {\n                return toReceiptLog(it.next().getItemByIndex(logIndex).toRlpBytes());\n            } else it.next();\n            idx++;\n        }\n        revert(\"no log index in receipt\");\n    }\n\n    function toReceiptLog(bytes memory data) internal pure returns (Log memory) {\n        RLPDecode.Iterator memory it = RLPDecode.toRlpItem(data).iterator();\n        Log memory log;\n\n        uint idx;\n        while (it.hasNext()) {\n            if (idx == 0) {\n                log.contractAddress = it.next().toAddress();\n            } else if (idx == 1) {\n                RLPDecode.RLPItem memory item = it.next().getItemByIndex(0);\n                log.topicZero = bytes32(item.toUint());\n            } else if (idx == 2) log.data = it.next().toBytes();\n            else it.next();\n            idx++;\n        }\n        return log;\n    }\n}\n"
    },
    "contracts/V1Contracts/contracts/proxy/DefaultProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.7.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./TransparentUpgradeableProxy.sol\";\n\n/**\n * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an\n * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.\n */\ncontract DefaultProxyAdmin is Ownable {\n    constructor(address initialOwner) {\n        transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Returns the current implementation of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyImplementation(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"implementation()\")) == 0x5c60da1b\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"5c60da1b\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Returns the current admin of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyAdmin(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"admin()\")) == 0xf851a440\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"f851a440\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Changes the admin of `proxy` to `newAdmin`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the current admin of `proxy`.\n     */\n    function changeProxyAdmin(TransparentUpgradeableProxy proxy, address newAdmin) public virtual onlyOwner {\n        proxy.changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgrade(TransparentUpgradeableProxy proxy, address implementation) public virtual onlyOwner {\n        proxy.upgradeTo(implementation);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See\n     * {TransparentUpgradeableProxy-upgradeToAndCall}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgradeAndCall(\n        TransparentUpgradeableProxy proxy,\n        address implementation,\n        bytes memory data\n    ) public payable virtual onlyOwner {\n        proxy.upgradeToAndCall{value: msg.value}(implementation, data);\n    }\n}\n"
    },
    "contracts/V1Contracts/contracts/proxy/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.7.0;\n\nimport \"@openzeppelin/contracts/proxy/UpgradeableProxy.sol\";\n\n/**\n * @dev This contract implements a proxy that is upgradeable by an admin.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n * \"admin cannot fallback to proxy target\".\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n */\ncontract TransparentUpgradeableProxy is UpgradeableProxy {\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {UpgradeableProxy-constructor}.\n     */\n    constructor(address _logic, address admin_, bytes memory _data) payable UpgradeableProxy(_logic, _data) {\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n        _setAdmin(admin_);\n    }\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 private constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _admin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function admin() external ifAdmin returns (address admin_) {\n        admin_ = _admin();\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function implementation() external ifAdmin returns (address implementation_) {\n        implementation_ = _implementation();\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\n     */\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\n        require(newAdmin != address(0), \"TransparentUpgradeableProxy: new admin is the zero address\");\n        emit AdminChanged(_admin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\n     */\n    function upgradeTo(address newImplementation) external virtual ifAdmin {\n        _upgradeTo(newImplementation);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable virtual ifAdmin {\n        _upgradeTo(newImplementation);\n        Address.functionDelegateCall(newImplementation, data);\n    }\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _admin() internal view virtual returns (address adm) {\n        bytes32 slot = _ADMIN_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            adm := sload(slot)\n        }\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        bytes32 slot = _ADMIN_SLOT;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(slot, newAdmin)\n        }\n    }\n\n    /**\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\n     */\n    function _beforeFallback() internal virtual override {\n        require(msg.sender != _admin(), \"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");\n        super._beforeFallback();\n    }\n}\n"
    },
    "contracts/V1Contracts/contracts/Relayer.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.7.6;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";import \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"hardhat-deploy/solc_0.7/proxy/Proxied.sol\";\n\nimport \"./interfaces/ILayerZeroRelayer.sol\";\nimport \"./interfaces/ILayerZeroUltraLightNodeV1.sol\";\n\ncontract Relayer is ILayerZeroRelayer, ReentrancyGuard, OwnableUpgradeable, Proxied {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint;\n    using SafeMath for uint128;\n    using SafeMath for uint64;\n\n    ILayerZeroUltraLightNodeV1 public uln;\n\n    struct DstPrice {\n        uint128 dstPriceRatio; // 10^10\n        uint128 dstGasPriceInWei;\n    }\n\n    struct DstConfig {\n        uint128 dstNativeAmtCap;\n        uint64 baseGas;\n        uint64 gasPerByte;\n    }\n\n    // [_chainId] => DstPriceData. change often\n    mapping(uint16 => DstPrice) public dstPriceLookup;\n    // [_chainId][_outboundProofType] => DstConfig. change much less often\n    mapping(uint16 => mapping(uint16 => DstConfig)) public dstConfigLookup;\n    mapping(address => bool) public approvedAddresses;\n\n    event WithdrawTokens(address token, address to, uint amount);\n    event Withdraw(address to, uint amount);\n    event ApproveAddress(address addr, bool approved);\n\n    address public stargateBridgeAddress;\n\n    event InvalidPayloadSize(uint indexed payloadSize);\n    event ValueTransferFailed(address indexed to, uint indexed quantity);\n\n    //----------------------------------------------------------------------------------\n    // Relayer Interface V2 Change\n\n    event AssignJob(uint16 dstChainId, uint16 outboundProofType, address userApplication, uint totalFee);\n    event Ulnv2Set(address ulnv2);\n\n    // new pauseable relayer\n    bool public paused;\n\n    // owner is always approved\n    modifier onlyApproved() {\n        if (owner() != msg.sender) {\n            require(isApproved(msg.sender), \"Relayer: not approved \");\n        }\n        _;\n    }\n\n    function initialize(address _uln) public proxied initializer {\n        __Ownable_init();\n        uln = ILayerZeroUltraLightNodeV1(_uln);\n        setApprovedAddress(address(this), true);\n    }\n\n    //----------------------------------------------------------------------------------\n    // onlyApproved\n    function validateTransactionProofV2(\n        uint16 _srcChainId,\n        address _dstAddress,\n        uint _gasLimit,\n        bytes32 _blockHash,\n        bytes calldata _transactionProof,\n        address payable _to\n    ) external payable onlyApproved nonReentrant {\n        (bool sent, ) = _to.call{value: msg.value}(\"\");\n        //require(sent, \"Relayer: failed to send ether\");\n        if (!sent) {\n            emit ValueTransferFailed(_to, msg.value);\n        }\n        uln.validateTransactionProof(_srcChainId, _dstAddress, _gasLimit, _blockHash, _transactionProof);\n    }\n\n    function validateTransactionProofV1(\n        uint16 _srcChainId,\n        address _dstAddress,\n        uint _gasLimit,\n        bytes32 _blockHash,\n        bytes calldata _transactionProof\n    ) external onlyApproved nonReentrant {\n        uln.validateTransactionProof(_srcChainId, _dstAddress, _gasLimit, _blockHash, _transactionProof);\n    }\n\n    function setDstPrice(uint16 _chainId, uint128 _dstPriceRatio, uint128 _dstGasPriceInWei) external onlyApproved {\n        dstPriceLookup[_chainId] = DstPrice(_dstPriceRatio, _dstGasPriceInWei);\n    }\n\n    function setDstConfig(\n        uint16 _chainId,\n        uint16 _outboundProofType,\n        uint128 _dstNativeAmtCap,\n        uint64 _baseGas,\n        uint64 _gasPerByte\n    ) external onlyApproved {\n        dstConfigLookup[_chainId][_outboundProofType] = DstConfig(_dstNativeAmtCap, _baseGas, _gasPerByte);\n    }\n\n    // other relayer fees are withdrawn through the RelayerFee interface\n    // uint8 public constant WITHDRAW_TYPE_RELAYER_QUOTED_FEES = 2;\n    function withdrawQuotedFromULN(address payable _to, uint _amount) external onlyApproved {\n        uln.withdrawNative(2, address(0x0), _to, _amount);\n    }\n\n    //----------------------------------------------------------------------------------\n    // onlyOwner\n\n    function setApprovedAddress(address _relayerAddress, bool _approve) public onlyOwner {\n        approvedAddresses[_relayerAddress] = _approve;\n        emit ApproveAddress(_relayerAddress, _approve);\n    }\n\n    function setPause(bool _paused) public onlyOwner {\n        paused = _paused;\n    }\n\n    //----------------------------------------------------------------------------------\n    // view functions\n\n    // txType 1\n    // bytes  [2       32      ]\n    // fields [txType  extraGas]\n    // txType 2\n    // bytes  [2       32        32            bytes[]         ]\n    // fields [txType  extraGas  dstNativeAmt  dstNativeAddress]\n    // User App Address is not used in this version\n    function _getPrices(\n        uint16 _dstChainId,\n        uint16 _outboundProofType,\n        address,\n        bytes memory _adapterParameters\n    ) internal view returns (uint basePrice, uint pricePerByte) {\n        require(!paused, \"Admin: paused\");\n        // decoding the _adapterParameters - reverts if type 2 and there is no dstNativeAddress\n        require(\n            _adapterParameters.length == 34 || _adapterParameters.length > 66,\n            \"Relayer: wrong _adapterParameters size\"\n        );\n        uint16 txType;\n        uint extraGas;\n        assembly {\n            txType := mload(add(_adapterParameters, 2))\n            extraGas := mload(add(_adapterParameters, 34))\n        }\n        require(extraGas > 0, \"Relayer: gas too low\");\n        require(txType == 1 || txType == 2, \"Relayer: unsupported txType\");\n\n        DstPrice storage dstPrice = dstPriceLookup[_dstChainId];\n        DstConfig storage dstConfig = dstConfigLookup[_dstChainId][_outboundProofType];\n\n        uint totalRemoteToken; // = baseGas + extraGas + requiredNativeAmount\n        if (txType == 2) {\n            uint dstNativeAmt;\n            assembly {\n                dstNativeAmt := mload(add(_adapterParameters, 66))\n            }\n            require(dstConfig.dstNativeAmtCap >= dstNativeAmt, \"Relayer: dstNativeAmt too large \");\n            totalRemoteToken = totalRemoteToken.add(dstNativeAmt);\n        }\n        // remoteGasTotal = dstGasPriceInWei * (baseGas + extraGas)\n        uint remoteGasTotal = dstPrice.dstGasPriceInWei.mul(dstConfig.baseGas.add(extraGas));\n\n        totalRemoteToken = totalRemoteToken.add(remoteGasTotal);\n\n        // tokenConversionRate = dstPrice / localPrice\n        // basePrice = totalRemoteToken * tokenConversionRate\n        basePrice = totalRemoteToken.mul(dstPrice.dstPriceRatio).div(10 ** 10);\n\n        // pricePerByte = (dstGasPriceInWei * gasPerBytes) * tokenConversionRate\n        pricePerByte = dstPrice.dstGasPriceInWei.mul(dstConfig.gasPerByte).mul(dstPrice.dstPriceRatio).div(10 ** 10);\n    }\n\n    function notifyRelayer(\n        uint16 _dstChainId,\n        uint16 _outboundProofType,\n        bytes calldata _adapterParams\n    ) external override {\n        //do nothing\n    }\n\n    function getPrice(\n        uint16 _dstChainId,\n        uint16 _outboundProofType,\n        address _userApplication,\n        uint payloadSize,\n        bytes calldata _adapterParams\n    ) external view override returns (uint) {\n        (uint basePrice, uint pricePerByte) = _getPrices(\n            _dstChainId,\n            _outboundProofType,\n            _userApplication,\n            _adapterParams\n        );\n        return basePrice.add(payloadSize.mul(pricePerByte));\n    }\n\n    function isApproved(address _relayerAddress) public view override returns (bool) {\n        return approvedAddresses[_relayerAddress];\n    }\n}\n"
    },
    "contracts/V1Contracts/contracts/RelayerV2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.7.6;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";import \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"hardhat-deploy/solc_0.7/proxy/Proxied.sol\";\n\nimport \"./interfaces/ILayerZeroRelayerV2.sol\";\nimport \"./interfaces/ILayerZeroUltraLightNodeV2.sol\";\nimport \"./interfaces/ILayerZeroPriceFeedV2.sol\";\nimport \"./libs/RateLimiter.sol\";\n\ninterface IStargateComposer {\n    function isSending() external view returns (bool);\n}\n\ncontract RelayerV2 is ReentrancyGuard, OwnableUpgradeable, Proxied, ILayerZeroRelayerV2 {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint;\n    using SafeMath for uint128;\n    using SafeMath for uint64;\n    using RateLimiter for RateLimiter.Info;\n\n    ILayerZeroUltraLightNodeV2 public uln;\n    address public stargateBridgeAddress;\n    uint public constant AIRDROP_GAS_LIMIT = 10000;\n\n    struct DstPrice {\n        uint128 dstPriceRatio; // 10^10\n        uint128 dstGasPriceInWei;\n    }\n\n    struct DstConfig {\n        uint128 dstNativeAmtCap;\n        uint64 baseGas;\n        uint64 gasPerByte;\n    }\n\n    struct DstMultiplier {\n        uint16 chainId;\n        uint128 multiplier;\n    }\n\n    struct DstFloorMargin {\n        uint16 chainId;\n        uint128 floorMargin;\n    }\n\n    // [_chainId] => DstPriceData. change often\n    mapping(uint16 => DstPrice) public dstPriceLookupOld;\n    // [_chainId][_outboundProofType] => DstConfig. change much less often\n    mapping(uint16 => mapping(uint16 => DstConfig)) public dstConfigLookup;\n    mapping(address => bool) public approvedAddresses;\n\n    event Withdraw(address to, uint amount);\n    event ApproveAddress(address addr, bool approved);\n    event SetPriceConfigUpdater(address priceConfigUpdater, bool allow);\n    event AssignJob(uint totalFee);\n    event ValueTransferFailed(address indexed to, uint indexed quantity);\n    event SetDstPrice(uint16 chainId, uint128 dstPriceRatio, uint128 dstGasPriceInWei);\n    event SetDstConfig(\n        uint16 chainId,\n        uint16 outboundProofType,\n        uint128 dstNativeAmtCap,\n        uint64 baseGas,\n        uint64 gasPerByte\n    );\n\n    // new pauseable relayer\n    bool public paused;\n\n    // Update for Price Feed\n    ILayerZeroPriceFeedV2 public priceFeed;\n    // multipler for airdrop\n    uint128 public multiplierBps;\n\n    // PriceFeedContract Upgrade\n    // all encoded param bytes except for proof for validateTransactionProofV1\n    uint16 public validateProofBytes;\n    uint16 public fpBytes;\n    uint16 public mptOverhead;\n\n    // [chainId] => [multiplier]\n    mapping(uint16 => uint128) public dstMultipliers;\n    // [chainId] => [floor margin in USD]\n    mapping(uint16 => uint128) public dstFloorMarginsUSD;\n    mapping(address => bool) public priceConfigUpdaters;\n\n    // stargate guard\n    IStargateComposer public stargateComposer;\n    address public stargateBridgeAddr;\n\n    uint256 public nativeDecimalsRate;\n\n    RateLimiter.Info public limiter; // deprecated\n\n    event RateLimiterSet(uint64 capacity, uint64 rate); // deprecated\n\n    mapping(address => bool) public limiterWhitelist; // if true, sender bypasses rate limits\n    mapping(uint16 => RateLimiter.Info) public limiters;\n    event DstRateLimiterSet(uint16 dstChain, uint64 capacity, uint64 rate);\n\n    // owner is always approved\n    modifier onlyApproved() {\n        if (owner() != msg.sender) {\n            require(isApproved(msg.sender), \"Relayer: not approved\");\n        }\n        _;\n    }\n\n    modifier onlyPriceConfigUpdater() {\n        if (owner() != msg.sender && !approvedAddresses[msg.sender]) {\n            require(priceConfigUpdaters[msg.sender], \"Relayer: not updater\");\n        }\n        _;\n    }\n\n    function initialize(\n        address _uln,\n        address _priceFeed,\n        address _stargateBridgeAddr,\n        address _stargateComposer,\n        uint256 _nativeDecimalsRate\n    ) public proxied initializer {\n        __Ownable_init();\n        uln = ILayerZeroUltraLightNodeV2(_uln);\n        setApprovedAddress(address(this), true);\n        multiplierBps = 12000;\n        priceFeed = ILayerZeroPriceFeedV2(_priceFeed);\n        validateProofBytes = 164;\n        fpBytes = 160;\n        mptOverhead = 500;\n        stargateBridgeAddr = _stargateBridgeAddr;\n        stargateComposer = IStargateComposer(_stargateComposer);\n        nativeDecimalsRate = _nativeDecimalsRate;\n    }\n\n    function onUpgrade(\n        address _stargateBridgeAddr,\n        address _stargateComposer,\n        uint256 _nativeDecimalsRate\n    ) public proxied {\n        stargateBridgeAddr = _stargateBridgeAddr;\n        stargateComposer = IStargateComposer(_stargateComposer);\n        nativeDecimalsRate = _nativeDecimalsRate;\n    }\n\n    //----------------------------------------------------------------------------------\n    // onlyApproved\n    function setLimiterWhitelist(address _addr, bool _skipRateLimits) external onlyApproved {\n        limiterWhitelist[_addr] = _skipRateLimits;\n    }\n\n    function setDstPrice(uint16 _chainId, uint128 _dstPriceRatio, uint128 _dstGasPriceInWei) external onlyApproved {\n        // No longer used: Write prices in PriceFeed.\n    }\n\n    function setPriceFeed(address _priceFeed) external onlyApproved {\n        priceFeed = ILayerZeroPriceFeedV2(_priceFeed);\n    }\n\n    function setPriceMultiplierBps(uint128 _multiplierBps) external onlyApproved {\n        multiplierBps = _multiplierBps;\n    }\n\n    function setDstPriceMultipliers(DstMultiplier[] calldata _multipliers) external onlyPriceConfigUpdater {\n        for (uint i = 0; i < _multipliers.length; i++) {\n            DstMultiplier calldata _data = _multipliers[i];\n            dstMultipliers[_data.chainId] = _data.multiplier;\n        }\n    }\n\n    function setDstFloorMarginsUSD(DstFloorMargin[] calldata _margins) external onlyPriceConfigUpdater {\n        for (uint i = 0; i < _margins.length; i++) {\n            DstFloorMargin calldata _data = _margins[i];\n            dstFloorMarginsUSD[_data.chainId] = _data.floorMargin;\n        }\n    }\n\n    function setDstConfig(\n        uint16 _chainId,\n        uint16 _outboundProofType,\n        uint128 _dstNativeAmtCap,\n        uint64 _baseGas,\n        uint64 _gasPerByte\n    ) external onlyApproved {\n        dstConfigLookup[_chainId][_outboundProofType] = DstConfig(_dstNativeAmtCap, _baseGas, _gasPerByte);\n        emit SetDstConfig(_chainId, _outboundProofType, _dstNativeAmtCap, _baseGas, _gasPerByte);\n    }\n\n    function setStargateAddress(address _stargateAddress) external onlyApproved {\n        stargateBridgeAddress = _stargateAddress;\n    }\n\n    //----------------------------------------------------------------------------------\n    // onlyOwner\n    function configRateLimiter(uint16 _dstChainId, uint64 _capacity, uint64 _rate) external onlyOwner {\n        RateLimiter.Info storage dstLimiter = limiters[_dstChainId];\n        dstLimiter.setCapacity(_capacity);\n        dstLimiter.setRate(_rate);\n        emit DstRateLimiterSet(_dstChainId, _capacity, _rate);\n    }\n\n    function setApprovedAddress(address _relayerAddress, bool _approve) public onlyOwner {\n        approvedAddresses[_relayerAddress] = _approve;\n        emit ApproveAddress(_relayerAddress, _approve);\n    }\n\n    function setPriceConfigUpdater(address _priceConfigUpdater, bool _allow) public onlyOwner {\n        priceConfigUpdaters[_priceConfigUpdater] = _allow;\n        emit SetPriceConfigUpdater(_priceConfigUpdater, _allow);\n    }\n\n    function setPause(bool _paused) public onlyOwner {\n        paused = _paused;\n    }\n\n    // txType 1\n    // bytes  [2       32      ]\n    // fields [txType  extraGas]\n    // txType 2\n    // bytes  [2       32        32            bytes[]         ]\n    // fields [txType  extraGas  dstNativeAmt  dstNativeAddress]\n    // User App Address is not used in this version\n    function _getPrices(\n        uint16 _dstChainId,\n        uint16 _outboundProofType,\n        address,\n        uint _payloadSize,\n        bytes memory _adapterParameters\n    ) internal view returns (uint) {\n        require(!paused, \"Admin: paused\");\n        // decoding the _adapterParameters - reverts if type 2 and there is no dstNativeAddress\n        require(\n            _adapterParameters.length == 34 || _adapterParameters.length > 66,\n            \"Relayer: wrong _adapterParameters size\"\n        );\n        uint16 txType;\n        uint extraGas;\n        assembly {\n            txType := mload(add(_adapterParameters, 2))\n            extraGas := mload(add(_adapterParameters, 34))\n        }\n        require(extraGas > 0, \"Relayer: gas too low\");\n        require(txType == 1 || txType == 2, \"Relayer: unsupported txType\");\n\n        DstConfig storage dstConfig = dstConfigLookup[_dstChainId][_outboundProofType];\n\n        // validateTransactionProof bytes = fixedBytes + proofBytes\n        // V2 has an extra 32 bytes for payable address\n        uint totalFixedBytes = txType == 2 ? uint(validateProofBytes).add(32) : validateProofBytes;\n        uint proofBytes = _outboundProofType == 2 ? _payloadSize.add(fpBytes) : _payloadSize.add(mptOverhead);\n\n        uint16 dstChainId = _dstChainId; // stack too deep\n        (uint fee, uint128 priceRatio, uint128 priceRatioDenominator, uint128 nativePriceUSD) = priceFeed\n            .estimateFeeByEid(dstChainId, totalFixedBytes.add(proofBytes), dstConfig.baseGas.add(extraGas));\n\n        uint dstNativeAmt = 0;\n        if (txType == 2) {\n            assembly {\n                dstNativeAmt := mload(add(_adapterParameters, 66))\n            }\n            require(dstConfig.dstNativeAmtCap >= dstNativeAmt, \"Relayer: dstNativeAmt too large\");\n        }\n        uint airdropAmount = 0;\n        if (dstNativeAmt > 0) {\n            // gas saver if no airdrop\n            airdropAmount = dstNativeAmt.mul(priceRatio).div(priceRatioDenominator).mul(multiplierBps).div(10000); // cheaper than priceFeed.getPriceRatioDenominator()\n        }\n        return _getDstTxCost(dstChainId, fee, nativePriceUSD).add(airdropAmount);\n    }\n\n    function _getDstTxCost(uint16 _dstChainId, uint _fee, uint128 nativeTokenPriceUSD) private view returns (uint) {\n        uint128 _dstMultiplier = dstMultipliers[_dstChainId];\n        if (_dstMultiplier == 0) {\n            _dstMultiplier = multiplierBps;\n        }\n        uint dstTxCostWithMultiplier = _fee.mul(_dstMultiplier).div(10000);\n\n        if (nativeTokenPriceUSD == 0) {\n            return dstTxCostWithMultiplier;\n        }\n\n        uint dstTxCostWithMargin = _fee.add(\n            dstFloorMarginsUSD[_dstChainId].mul(nativeDecimalsRate).div(nativeTokenPriceUSD)\n        );\n\n        return dstTxCostWithMargin > dstTxCostWithMultiplier ? dstTxCostWithMargin : dstTxCostWithMultiplier;\n    }\n\n    function getFee(\n        uint16 _dstChainId,\n        uint16 _outboundProofType,\n        address _userApplication,\n        uint _payloadSize,\n        bytes calldata _adapterParams\n    ) external view override returns (uint) {\n        require(_payloadSize <= 10000, \"Relayer: _payloadSize tooooo big\");\n        return _getPrices(_dstChainId, _outboundProofType, _userApplication, _payloadSize, _adapterParams);\n    }\n\n    // view function to convert pricefeed price to current price (for backwards compatibility)\n    function dstPriceLookup(uint16 _dstChainId) public view returns (DstPrice memory) {\n        ILayerZeroPriceFeedV2.Price memory price = priceFeed.getPrice(_dstChainId);\n        return DstPrice(price.priceRatio, price.gasPriceInUnit);\n    }\n\n    function isApproved(address _relayerAddress) public view returns (bool) {\n        return approvedAddresses[_relayerAddress];\n    }\n\n    function assignJob(\n        uint16 _dstChainId,\n        uint16 _outboundProofType,\n        address _userApplication,\n        uint _payloadSize,\n        bytes calldata _adapterParams\n    ) external override returns (uint fee) {\n        if (_dstChainId >= 10000) {\n            RateLimiter.Info storage dstLimiter = limiters[_dstChainId];\n            // sandbox or testnet\n            if (!limiterWhitelist[_userApplication] && dstLimiter.capacity > 0) {\n                dstLimiter.tryConsume(10000);\n            }\n        }\n\n        require(msg.sender == address(uln), \"Relayer: invalid uln\");\n        require(_payloadSize <= 10000, \"Relayer: _payloadSize > 10000\");\n\n        if (_userApplication == stargateBridgeAddr) {\n            // following way also prevents user from inputting to address greater than 32 bytes\n            bool validPayload = (_payloadSize == 544 || // swap with no payload\n                _payloadSize == 320 || // redeem local callback\n                _payloadSize == 288 || // redeem local\n                _payloadSize == 160); // send credits\n\n            if (!validPayload) {\n                require(stargateComposer.isSending(), \"Relayer: stargate composer is not sending\");\n            }\n        }\n\n        fee = _getPrices(_dstChainId, _outboundProofType, _userApplication, _payloadSize, _adapterParams);\n        emit AssignJob(fee);\n    }\n\n    function withdrawFee(address payable _to, uint _amount) external override onlyApproved {\n        uint totalFee = uln.accruedNativeFee(address(this));\n        require(_amount <= totalFee, \"Relayer: not enough fee for withdrawal\");\n        uln.withdrawNative(_to, _amount);\n    }\n\n    function withdrawToken(address _token, address _to, uint _amount) external onlyApproved {\n        if (_token == address(0)) {\n            uint total = address(this).balance;\n            require(_amount <= total, \"Relayer: not enough native fee for withdrawal\");\n            (bool sent, ) = payable(_to).call{ value: _amount }(\"\");\n            require(sent, \"Relayer: failed to send ether\");\n        } else {\n            uint total = IERC20(_token).balanceOf(address(this));\n            require(_amount <= total, \"Relayer: not enough fee for withdrawal\");\n            IERC20(_token).safeTransfer(_to, _amount);\n        }\n    }\n\n    function validateTransactionProofV2(\n        uint16 _srcChainId,\n        address _dstAddress,\n        uint _gasLimit,\n        bytes32 _blockHash,\n        bytes32 _data,\n        bytes calldata _transactionProof,\n        address payable _to\n    ) external payable onlyApproved nonReentrant {\n        (bool sent, ) = _to.call{ gas: AIRDROP_GAS_LIMIT, value: msg.value }(\"\");\n        //require(sent, \"Relayer: failed to send ether\");\n        if (!sent) {\n            emit ValueTransferFailed(_to, msg.value);\n        }\n        uln.validateTransactionProof(_srcChainId, _dstAddress, _gasLimit, _blockHash, _data, _transactionProof);\n    }\n\n    function validateTransactionProofV1(\n        uint16 _srcChainId,\n        address _dstAddress,\n        uint _gasLimit,\n        bytes32 _blockHash,\n        bytes32 _data,\n        bytes calldata _transactionProof\n    ) external onlyApproved nonReentrant {\n        uln.validateTransactionProof(_srcChainId, _dstAddress, _gasLimit, _blockHash, _data, _transactionProof);\n    }\n}\n"
    },
    "contracts/V1Contracts/contracts/RelayerV2Radar.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.7.6;\n\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";import \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"hardhat-deploy/solc_0.7/proxy/Proxied.sol\";\n\nimport \"./interfaces/ILayerZeroRelayerV2.sol\";\nimport \"./interfaces/ILayerZeroRelayerV2PriceData.sol\";\nimport \"./interfaces/ILayerZeroUltraLightNodeV2.sol\";\nimport \"./interfaces/ILayerZeroPriceFeed.sol\";\n\n// RelayerV2Radar has an instance of RelayerV2.\n// It does not need to set prices.\n// it has view functions that use the internal RelayerV2 price data.\ncontract RelayerV2Radar is\n    ReentrancyGuard,\n    OwnableUpgradeable,\n    Proxied,\n    ILayerZeroRelayerV2,\n    ILayerZeroRelayerV2PriceData\n{\n    using SafeERC20 for IERC20;\n    using SafeMath for uint;\n    using SafeMath for uint128;\n    using SafeMath for uint64;\n\n    ILayerZeroUltraLightNodeV2 public uln; // UltraLightNodeV2Radar\n    ILayerZeroRelayerV2PriceData public relayerV2;\n\n    address public stargateBridgeAddress;\n\n    //    struct DstPrice {\n    //        uint128 dstPriceRatio; // 10^10\n    //        uint128 dstGasPriceInWei;\n    //    }\n    //\n    //    struct DstConfig {\n    //        uint128 dstNativeAmtCap;\n    //        uint64 baseGas;\n    //        uint64 gasPerByte;\n    //    }\n\n    //    // [_chainId] => DstPriceData. change often\n    //    mapping(uint16 => RelayerV2.DstPrice) public dstPriceLookup;\n    //    // [_chainId][_outboundProofType] => DstConfig. change much less often\n    //    mapping(uint16 => mapping(uint16 => RelayerV2.DstConfig)) public dstConfigLookup;\n    mapping(address => bool) public approvedAddresses;\n\n    event Withdraw(address to, uint amount);\n    event ApproveAddress(address addr, bool approved);\n    event AssignJob(uint totalFee);\n    event ValueTransferFailed(address indexed to, uint indexed quantity);\n    event SetDstPrice(uint16 chainId, uint128 dstPriceRatio, uint128 dstGasPriceInWei);\n    event SetDstConfig(\n        uint16 chainId,\n        uint16 outboundProofType,\n        uint128 dstNativeAmtCap,\n        uint64 baseGas,\n        uint64 gasPerByte\n    );\n\n    // new pauseable relayer\n    bool public paused;\n\n    // map of legacyChainid => v2 chainId. allows lookup thru to RelayerV2 contract (which is updated frequently)\n    mapping(uint16 => uint16) public legacyToV2ChainId; // legacy ChainId => v2 chainId\n\n    // Upgrade\n    ILayerZeroPriceFeed public priceFeed;\n    // all encoded param bytes except for proof for validateTransactionProofV1\n    uint128 public multiplierBps;\n    uint16 public validateProofBytes;\n    uint16 public fpBytes;\n    uint16 public mptOverhead; // average overhead for mpt\n\n    // owner is always approved\n    modifier onlyApproved() {\n        if (owner() != msg.sender) {\n            require(isApproved(msg.sender), \"Relayer: not approved\");\n        }\n        _;\n    }\n\n    function initialize(address _ulnRadar, address _relayerV2, address _priceFeed) public proxied initializer {\n        __Ownable_init();\n        uln = ILayerZeroUltraLightNodeV2(_ulnRadar);\n        setApprovedAddress(address(this), true);\n\n        relayerV2 = ILayerZeroRelayerV2PriceData(_relayerV2);\n\n        legacyToV2ChainId[1] = 101; // ethereum\n        legacyToV2ChainId[2] = 102; // bsc\n        legacyToV2ChainId[12] = 112; // fantom\n\n        priceFeed = ILayerZeroPriceFeed(_priceFeed);\n        validateProofBytes = 164;\n        fpBytes = 160;\n        mptOverhead = 500;\n    }\n\n    function onUpgrade(address _priceFeed) public proxied {\n        multiplierBps = 12000;\n        priceFeed = ILayerZeroPriceFeed(_priceFeed);\n        validateProofBytes = 164;\n        fpBytes = 160;\n        mptOverhead = 500;\n    }\n\n    function getV2ChainId(uint16 _legacyChainId) public view returns (uint16) {\n        require(legacyToV2ChainId[_legacyChainId] != 0, \"getLegacyChainId(): lookup not found\");\n        return legacyToV2ChainId[_legacyChainId];\n    }\n\n    //----------------------------------------------------------------------------------\n    // onlyApproved\n\n    function setDstPrice(uint16 _chainId, uint128 _dstPriceRatio, uint128 _dstGasPriceInWei) external onlyApproved {\n        //        dstPriceLookup[_chainId] = DstPrice(_dstPriceRatio, _dstGasPriceInWei);\n        //        emit SetDstPrice(_chainId, _dstPriceRatio, _dstGasPriceInWei);\n    }\n\n    function setPriceFeed(address _priceFeed) external onlyApproved {\n        priceFeed = ILayerZeroPriceFeed(_priceFeed);\n    }\n\n    function setPriceMultiplierBps(uint128 _multiplierBps) external onlyApproved {\n        multiplierBps = _multiplierBps;\n    }\n\n    function setDstConfig(\n        uint16 _chainId,\n        uint16 _outboundProofType,\n        uint128 _dstNativeAmtCap,\n        uint64 _baseGas,\n        uint64 _gasPerByte\n    ) external onlyApproved {\n        //        dstConfigLookup[_chainId][_outboundProofType] = DstConfig(_dstNativeAmtCap, _baseGas, _gasPerByte);\n        //        emit SetDstConfig(_chainId, _outboundProofType, _dstNativeAmtCap, _baseGas, _gasPerByte);\n    }\n\n    function dstPriceLookup(\n        uint16 _legacyChainId\n    ) public view override returns (ILayerZeroRelayerV2PriceData.DstPrice memory) {\n        return relayerV2.dstPriceLookup(getV2ChainId(_legacyChainId));\n    }\n\n    function dstConfigLookup(\n        uint16 _legacyChainId,\n        uint16 _outboundProofType\n    ) public view override returns (ILayerZeroRelayerV2PriceData.DstConfig memory) {\n        return relayerV2.dstConfigLookup(getV2ChainId(_legacyChainId), _outboundProofType);\n    }\n\n    function setStargateAddress(address _stargateAddress) external onlyApproved {\n        stargateBridgeAddress = _stargateAddress;\n    }\n\n    //----------------------------------------------------------------------------------\n    // onlyOwner\n\n    function setApprovedAddress(address _relayerAddress, bool _approve) public onlyOwner {\n        approvedAddresses[_relayerAddress] = _approve;\n        emit ApproveAddress(_relayerAddress, _approve);\n    }\n\n    function setPause(bool _paused) public onlyOwner {\n        paused = _paused;\n    }\n\n    // txType 1\n    // bytes  [2       32      ]\n    // fields [txType  extraGas]\n    // txType 2\n    // bytes  [2       32        32            bytes[]         ]\n    // fields [txType  extraGas  dstNativeAmt  dstNativeAddress]\n    // User App Address is not used in this version\n    function _getPrices(\n        uint16 _dstChainId,\n        uint16 _outboundProofType,\n        address,\n        uint _payloadSize,\n        bytes memory _adapterParameters\n    ) internal view returns (uint) {\n        require(!paused, \"Admin: paused\");\n        // decoding the _adapterParameters - reverts if type 2 and there is no dstNativeAddress\n        require(\n            _adapterParameters.length == 34 || _adapterParameters.length > 66,\n            \"Relayer: wrong _adapterParameters size\"\n        );\n        uint16 txType;\n        uint extraGas;\n        assembly {\n            txType := mload(add(_adapterParameters, 2))\n            extraGas := mload(add(_adapterParameters, 34))\n        }\n        require(extraGas > 0, \"Relayer: gas too low\");\n        require(txType == 1 || txType == 2, \"Relayer: unsupported txType\");\n\n        DstConfig memory dstConfig = dstConfigLookup(_dstChainId, _outboundProofType);\n\n        uint dstNativeAmt = 0;\n        if (txType == 2) {\n            assembly {\n                dstNativeAmt := mload(add(_adapterParameters, 66))\n            }\n            require(dstConfig.dstNativeAmtCap >= dstNativeAmt, \"Relayer: dstNativeAmt too large\");\n        }\n\n        // validateTransactionProof bytes = fixedBytes + proofBytes\n        // V2 has an extra 32 bytes for payable address\n        uint totalFixedBytes = txType == 2 ? uint(validateProofBytes).add(32) : validateProofBytes;\n        uint proofBytes = _outboundProofType == 2 ? fpBytes : _payloadSize.add(mptOverhead);\n        uint totalCallDataBytes = totalFixedBytes.add(proofBytes);\n\n        uint16 dstChainId = _dstChainId; // stack too deep\n        (uint fee, uint128 priceRatio) = priceFeed.estimateFeeByChain(\n            getV2ChainId(dstChainId),\n            totalCallDataBytes,\n            dstConfig.baseGas.add(extraGas)\n        );\n        uint airdropAmount = dstNativeAmt.mul(priceRatio).div(10 ** 10);\n        return fee.add(airdropAmount).mul(multiplierBps).div(10000);\n    }\n\n    function getFee(\n        uint16 _dstChainId,\n        uint16 _outboundProofType,\n        address _userApplication,\n        uint _payloadSize,\n        bytes calldata _adapterParams\n    ) external view override returns (uint) {\n        require(_payloadSize <= 10000, \"Relayer: _payloadSize tooooo big\");\n        return _getPrices(_dstChainId, _outboundProofType, _userApplication, _payloadSize, _adapterParams);\n    }\n\n    function isApproved(address _relayerAddress) public view returns (bool) {\n        return approvedAddresses[_relayerAddress];\n    }\n\n    function assignJob(\n        uint16 _dstChainId,\n        uint16 _outboundProofType,\n        address _userApplication,\n        uint _payloadSize,\n        bytes calldata _adapterParams\n    ) external override returns (uint) {\n        require(msg.sender == address(uln), \"Relayer: invalid uln\");\n        require(_payloadSize <= 10000, \"Relayer: _payloadSize tooooo big\");\n        uint fee = _getPrices(_dstChainId, _outboundProofType, _userApplication, _payloadSize, _adapterParams);\n        emit AssignJob(fee);\n        return fee;\n    }\n\n    function withdrawFee(address payable _to, uint _amount) external override onlyApproved {\n        uint totalFee = uln.accruedNativeFee(address(this));\n        require(_amount <= totalFee, \"Relayer: not enough fee for withdrawal\");\n        uln.withdrawNative(_to, _amount);\n    }\n\n    function validateTransactionProofV2(\n        uint16 _srcChainId,\n        address _dstAddress,\n        uint _gasLimit,\n        bytes32 _blockHash,\n        bytes32 _data,\n        bytes calldata _transactionProof,\n        address payable _to\n    ) external payable onlyApproved nonReentrant {\n        (bool sent, ) = _to.call{value: msg.value}(\"\");\n        //require(sent, \"Relayer: failed to send ether\");\n        if (!sent) {\n            emit ValueTransferFailed(_to, msg.value);\n        }\n        uln.validateTransactionProof(_srcChainId, _dstAddress, _gasLimit, _blockHash, _data, _transactionProof);\n    }\n\n    function validateTransactionProofV1(\n        uint16 _srcChainId,\n        address _dstAddress,\n        uint _gasLimit,\n        bytes32 _blockHash,\n        bytes32 _data,\n        bytes calldata _transactionProof\n    ) external onlyApproved nonReentrant {\n        uln.validateTransactionProof(_srcChainId, _dstAddress, _gasLimit, _blockHash, _data, _transactionProof);\n    }\n}\n"
    },
    "contracts/V1Contracts/contracts/Treasury.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\n\nimport \"./interfaces/ILayerZeroTreasury.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";import \"./interfaces/ILayerZeroUltraLightNodeV1.sol\";\n\ncontract Treasury is ILayerZeroTreasury, Ownable {\n    using SafeMath for uint;\n\n    uint public nativeBP;\n    uint public zroFee;\n    bool public feeEnabled;\n    bool public zroEnabled;\n\n    ILayerZeroUltraLightNodeV1 public immutable uln;\n\n    event NativeBP(uint bp);\n    event ZroFee(uint zroFee);\n    event FeeEnabled(bool feeEnabled);\n    event ZroEnabled(bool zroEnabled);\n\n    constructor(address _uln) {\n        uln = ILayerZeroUltraLightNodeV1(_uln);\n    }\n\n    function getFees(bool payInZro, uint relayerFee, uint oracleFee) external view override returns (uint) {\n        if (feeEnabled) {\n            if (payInZro) {\n                require(zroEnabled, \"LayerZero: ZRO is not enabled\");\n                return zroFee;\n            } else {\n                return relayerFee.add(oracleFee).mul(nativeBP).div(10000);\n            }\n        }\n        return 0;\n    }\n\n    function setFeeEnabled(bool _feeEnabled) external onlyOwner {\n        feeEnabled = _feeEnabled;\n        emit FeeEnabled(_feeEnabled);\n    }\n\n    function setZroEnabled(bool _zroEnabled) external onlyOwner {\n        zroEnabled = _zroEnabled;\n        emit ZroEnabled(_zroEnabled);\n    }\n\n    function setNativeBP(uint _nativeBP) external onlyOwner {\n        nativeBP = _nativeBP;\n        emit NativeBP(_nativeBP);\n    }\n\n    function setZroFee(uint _zroFee) external onlyOwner {\n        zroFee = _zroFee;\n        emit ZroFee(_zroFee);\n    }\n\n    //    uint8 public constant WITHDRAW_TYPE_TREASURY_PROTOCOL_FEES = 0;\n    function withdrawZROFromULN(address _to, uint _amount) external onlyOwner {\n        uln.withdrawZRO(_to, _amount);\n    }\n\n    //    uint8 public constant WITHDRAW_TYPE_TREASURY_PROTOCOL_FEES = 0;\n    function withdrawNativeFromULN(address payable _to, uint _amount) external onlyOwner {\n        uln.withdrawNative(0, address(0x0), _to, _amount);\n    }\n}\n"
    },
    "contracts/V1Contracts/contracts/TreasuryV2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./interfaces/ILayerZeroTreasury.sol\";\nimport \"./interfaces/ILayerZeroUltraLightNodeV2.sol\";\n\ncontract TreasuryV2 is ILayerZeroTreasury, Ownable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint;\n\n    uint public nativeBP;\n    uint public zroFee;\n    bool public feeEnabled;\n    bool public zroEnabled;\n\n    ILayerZeroUltraLightNodeV2 public uln;\n\n    event NativeBP(uint bp);\n    event ZroFee(uint zroFee);\n    event FeeEnabled(bool feeEnabled);\n    event ZroEnabled(bool zroEnabled);\n\n    constructor(address _ulnv2) {\n        uln = ILayerZeroUltraLightNodeV2(_ulnv2);\n    }\n\n    function getFees(bool payInZro, uint relayerFee, uint oracleFee) external view override returns (uint) {\n        if (feeEnabled) {\n            if (payInZro) {\n                require(zroEnabled, \"LayerZero: ZRO is not enabled\");\n                return zroFee;\n            } else {\n                return relayerFee.add(oracleFee).mul(nativeBP).div(10000);\n            }\n        }\n        return 0;\n    }\n\n    function setFeeEnabled(bool _feeEnabled) external onlyOwner {\n        feeEnabled = _feeEnabled;\n        emit FeeEnabled(_feeEnabled);\n    }\n\n    function setZroEnabled(bool _zroEnabled) external onlyOwner {\n        zroEnabled = _zroEnabled;\n        emit ZroEnabled(_zroEnabled);\n    }\n\n    function setNativeBP(uint _nativeBP) external onlyOwner {\n        nativeBP = _nativeBP;\n        emit NativeBP(_nativeBP);\n    }\n\n    function setZroFee(uint _zroFee) external onlyOwner {\n        zroFee = _zroFee;\n        emit ZroFee(_zroFee);\n    }\n\n    function withdrawZROFromULN(address _to, uint _amount) external onlyOwner {\n        uln.withdrawZRO(_to, _amount);\n    }\n\n    function withdrawNativeFromULN(address payable _to, uint _amount) external onlyOwner {\n        uln.withdrawNative(_to, _amount);\n    }\n\n    function withdrawToken(address _token, address _to, uint _amount) external onlyOwner {\n        IERC20(_token).safeTransfer(_to, _amount);\n    }\n}\n"
    },
    "contracts/V1Contracts/contracts/TreasuryV2Radar.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\n\nimport \"./interfaces/ILayerZeroTreasury.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";import \"./interfaces/ILayerZeroUltraLightNodeV2.sol\";\n\ncontract TreasuryV2Radar is ILayerZeroTreasury, Ownable {\n    using SafeMath for uint;\n\n    uint public nativeBP;\n    uint public zroFee;\n    bool public feeEnabled;\n    bool public zroEnabled;\n\n    ILayerZeroUltraLightNodeV2 public uln;\n\n    event NativeBP(uint bp);\n    event ZroFee(uint zroFee);\n    event FeeEnabled(bool feeEnabled);\n    event ZroEnabled(bool zroEnabled);\n\n    constructor(address _ulnv2) {\n        uln = ILayerZeroUltraLightNodeV2(_ulnv2);\n    }\n\n    function getFees(bool payInZro, uint relayerFee, uint oracleFee) external view override returns (uint) {\n        if (feeEnabled) {\n            if (payInZro) {\n                require(zroEnabled, \"LayerZero: ZRO is not enabled\");\n                return zroFee;\n            } else {\n                return relayerFee.add(oracleFee).mul(nativeBP).div(10000);\n            }\n        }\n        return 0;\n    }\n\n    function setFeeEnabled(bool _feeEnabled) external onlyOwner {\n        feeEnabled = _feeEnabled;\n        emit FeeEnabled(_feeEnabled);\n    }\n\n    function setZroEnabled(bool _zroEnabled) external onlyOwner {\n        zroEnabled = _zroEnabled;\n        emit ZroEnabled(_zroEnabled);\n    }\n\n    function setNativeBP(uint _nativeBP) external onlyOwner {\n        nativeBP = _nativeBP;\n        emit NativeBP(_nativeBP);\n    }\n\n    function setZroFee(uint _zroFee) external onlyOwner {\n        zroFee = _zroFee;\n        emit ZroFee(_zroFee);\n    }\n\n    function withdrawZROFromULN(address _to, uint _amount) external onlyOwner {\n        uln.withdrawZRO(_to, _amount);\n    }\n\n    function withdrawNativeFromULN(address payable _to, uint _amount) external onlyOwner {\n        uln.withdrawNative(_to, _amount);\n    }\n}\n"
    },
    "contracts/V1Contracts/contracts/UltraLightNode.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";import \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"./interfaces/ILayerZeroValidationLibrary.sol\";\nimport \"./interfaces/ILayerZeroMessagingLibrary.sol\";\nimport \"./interfaces/ILayerZeroReceiver.sol\";\nimport \"./interfaces/ILayerZeroRelayer.sol\";\nimport \"./interfaces/ILayerZeroTreasury.sol\";\nimport \"./interfaces/ILayerZeroOracle.sol\";\nimport \"./interfaces/ILayerZeroUltraLightNodeV1.sol\";\nimport \"./interfaces/ILayerZeroEndpoint.sol\";\n\ncontract UltraLightNode is ILayerZeroMessagingLibrary, ILayerZeroUltraLightNodeV1, ReentrancyGuard, Ownable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint;\n\n    struct BlockData {\n        uint confirmations;\n        bytes32 data;\n    }\n\n    // Application config\n    uint public constant CONFIG_TYPE_INBOUND_PROOF_LIBRARY_VERSION = 1;\n    uint public constant CONFIG_TYPE_INBOUND_BLOCK_CONFIRMATIONS = 2;\n    uint public constant CONFIG_TYPE_RELAYER = 3;\n    uint public constant CONFIG_TYPE_OUTBOUND_PROOF_TYPE = 4;\n    uint public constant CONFIG_TYPE_OUTBOUND_BLOCK_CONFIRMATIONS = 5;\n    uint public constant CONFIG_TYPE_ORACLE = 6;\n\n    struct ApplicationConfiguration {\n        uint16 inboundProofLibraryVersion;\n        uint64 inboundBlockConfirmations;\n        address relayer;\n        uint16 outboundProofType;\n        uint64 outboundBlockConfirmations;\n        address oracle;\n    }\n\n    // Token and Contracts\n    IERC20 public layerZeroToken;\n    ILayerZeroTreasury public treasuryContract;\n\n    // Fee management\n    uint public constant BP_DENOMINATOR = 10000;\n    // treasury and relayer share the protocol fee, either in native token or ZRO\n    uint8 public constant WITHDRAW_TYPE_TREASURY_PROTOCOL_FEES = 0;\n    uint8 public constant WITHDRAW_TYPE_ORACLE_QUOTED_FEES = 1; // quoted fee refers to the fee in block relaying\n    uint8 public constant WITHDRAW_TYPE_RELAYER_QUOTED_FEES = 2; //quoted fee refers the fee in msg relaying\n\n    mapping(address => uint) public oracleQuotedFees;\n    mapping(address => uint) public relayerQuotedFees;\n    uint public treasuryNativeFees;\n    uint public treasuryZROFees;\n\n    // User Application\n    mapping(address => mapping(uint16 => ApplicationConfiguration)) public appConfig; // app address => chainId => config\n    mapping(uint16 => ApplicationConfiguration) public defaultAppConfig; // default UA settings if no version specified\n    mapping(uint16 => mapping(uint16 => bytes)) public defaultAdapterParams;\n\n    // Validation\n    mapping(uint16 => mapping(uint16 => address)) public inboundProofLibrary; // chainId => library Id => inboundProofLibrary contract\n    mapping(uint16 => uint16) public maxInboundProofLibrary; // chainId => inboundProofLibrary\n    mapping(uint16 => mapping(uint16 => bool)) public supportedOutboundProof; // chainId => outboundProofType => enabled\n    mapping(uint16 => uint) public chainAddressSizeMap;\n    mapping(address => mapping(uint16 => mapping(bytes32 => BlockData))) public hashLookup;\n    mapping(uint16 => bytes32) public ulnLookup; // remote ulns\n\n    ILayerZeroEndpoint public immutable endpoint;\n\n    // Events\n    event AppConfigUpdated(address userApplication, uint configType, bytes newConfig);\n    event AddInboundProofLibraryForChain(uint16 chainId, address lib);\n    event EnableSupportedOutboundProof(uint16 chainId, uint16 proofType);\n    event HashReceived(uint16 srcChainId, address oracle, uint confirmations, bytes32 blockhash);\n    event Packet(uint16 chainId, bytes payload);\n    event RelayerParams(uint16 chainId, uint64 nonce, uint16 outboundProofType, bytes adapterParams);\n    event SetChainAddressSize(uint16 chainId, uint size);\n    event SetDefaultConfigForChainId(\n        uint16 chainId,\n        uint16 inboundProofLib,\n        uint64 inboundBlockConfirm,\n        address relayer,\n        uint16 outboundProofType,\n        uint16 outboundBlockConfirm,\n        address oracle\n    );\n    event SetDefaultAdapterParamsForChainId(uint16 chainId, uint16 proofType, bytes adapterParams);\n    event SetLayerZeroToken(address tokenAddress);\n    event SetRelayerFeeContract(address relayerFeeContract);\n    event SetRemoteUln(uint16 chainId, bytes32 uln);\n    event SetTreasury(address treasuryAddress);\n    event WithdrawZRO(address _msgSender, address _to, uint _amount);\n    event WithdrawNative(uint8 _type, address _owner, address _msgSender, address _to, uint _amount);\n\n    constructor(address _endpoint) {\n        require(_endpoint != address(0x0), \"LayerZero: endpoint cannot be zero address\");\n        endpoint = ILayerZeroEndpoint(_endpoint);\n    }\n\n    // only the endpoint can call SEND() and setConfig()\n    modifier onlyEndpoint() {\n        require(address(endpoint) == msg.sender, \"LayerZero: only endpoint\");\n        _;\n    }\n\n    //----------------------------------------------------------------------------------\n    // PROTOCOL\n\n    // This function completes delivery of a LayerZero message.\n    //\n    // In order to deliver the message, this function:\n    // (a) takes the _transactionProof submitted by UA's relayer, and\n    // (b) retrieve UA's validation library\n    // (c) takes the _blockData submitted by the UA's oracle given the their configuration (and blockConfirmations),\n    // (d) decodes using UA's validation library using (a) and (c)\n    //  then, this functions asserts that\n    // (e) the payload originated from the known Ultra Light Node from source chain, and\n    // (f) the _dstAddress the specified destination contract\n    function validateTransactionProof(\n        uint16 _srcChainId,\n        address _dstAddress,\n        uint _gasLimit,\n        bytes32 _lookupHash,\n        bytes calldata _transactionProof\n    ) external override {\n        // retrieve UA's configuration using the _dstAddress from arguments.\n        ApplicationConfiguration memory uaConfig = getAppConfig(_srcChainId, _dstAddress);\n\n        // (a) assert that the caller == UA's relayer\n        require(uaConfig.relayer == msg.sender, \"LayerZero: invalid relayer\");\n\n        LayerZeroPacket.Packet memory _packet;\n        {\n            // (b) retrieve UA's validation library\n            address inboundProofLib = inboundProofLibrary[_srcChainId][uaConfig.inboundProofLibraryVersion];\n\n            // (c) assert that the data submitted by UA's oracle have no fewer confirmations than UA's configuration\n            BlockData storage blockData = hashLookup[uaConfig.oracle][_srcChainId][_lookupHash];\n            require(\n                blockData.confirmations >= uaConfig.inboundBlockConfirmations,\n                \"LayerZero: not enough block confirmations\"\n            );\n\n            // (d) decode\n            uint remoteAddressSize = chainAddressSizeMap[_srcChainId];\n            _packet = ILayerZeroValidationLibrary(inboundProofLib).validateProof(\n                blockData.data,\n                _transactionProof,\n                remoteAddressSize\n            );\n        }\n\n        // (e) assert that the packet was emitted by the source ultra light node\n        require(ulnLookup[_srcChainId] == _packet.ulnAddress, \"LayerZero: _packet.ulnAddress is invalid\");\n\n        // (f) assert that the _packet._dstAddress == the _dstAddress specified by the UAs message\n        require(_packet.dstAddress == _dstAddress, \"LayerZero: invalid dst address\");\n\n        // publish the payload and _gasLimit to the endpoint for calling lzReceive at _dstAddress\n        endpoint.receivePayload(\n            _packet.srcChainId,\n            _packet.srcAddress,\n            _packet.dstAddress,\n            _packet.nonce,\n            _gasLimit,\n            _packet.payload\n        );\n    }\n\n    // Called (by the Endpoint) with the information required to send a LayerZero message for a User Application.\n    // This function:\n    // (a) pays the protocol (native token or ZRO), oracle (native token) and relayer (native token) for their roles in sending the message.\n    // (b) generates the message payload and emits events of the message and adapterParams\n    // (c) notifies the oracle\n    function send(\n        address _ua,\n        uint64 _nonce,\n        uint16 _chainId,\n        bytes calldata _destination,\n        bytes calldata _payload,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes calldata _adapterParams\n    ) external payable override onlyEndpoint {\n        ApplicationConfiguration memory uaConfig = getAppConfig(_chainId, _ua);\n        address ua = _ua;\n        uint64 nonce = _nonce;\n        uint16 chainId = _chainId;\n        require(ulnLookup[chainId] != bytes32(0), \"LayerZero: chainId does not exist\");\n\n        uint totalNativeFee;\n        {\n            uint oracleFee;\n            // (a - 1), pay the oracle\n            {\n                oracleFee = ILayerZeroOracle(uaConfig.oracle).getPrice(chainId, uaConfig.outboundProofType);\n                oracleQuotedFees[uaConfig.oracle] = oracleQuotedFees[uaConfig.oracle].add(oracleFee);\n            }\n\n            // (a - 2), pay the relayer\n            {\n                uint payloadSize = _payload.length;\n                ILayerZeroRelayer relayer = ILayerZeroRelayer(uaConfig.relayer);\n                if (_adapterParams.length == 0) {\n                    bytes memory defaultAdaptorParam = defaultAdapterParams[chainId][uaConfig.outboundProofType];\n                    totalNativeFee = relayer.getPrice(\n                        chainId,\n                        uaConfig.outboundProofType,\n                        ua,\n                        payloadSize,\n                        defaultAdaptorParam\n                    );\n                    relayer.notifyRelayer(chainId, uaConfig.outboundProofType, defaultAdaptorParam);\n                } else {\n                    totalNativeFee = relayer.getPrice(\n                        chainId,\n                        uaConfig.outboundProofType,\n                        ua,\n                        payloadSize,\n                        _adapterParams\n                    );\n                    relayer.notifyRelayer(chainId, uaConfig.outboundProofType, _adapterParams);\n                }\n                relayerQuotedFees[uaConfig.relayer] = relayerQuotedFees[uaConfig.relayer].add(totalNativeFee); // totalNativeFee == relayerFee here\n\n                // emit the param events\n                emit RelayerParams(chainId, nonce, uaConfig.outboundProofType, _adapterParams);\n            }\n\n            // (a - 3), pay the protocol\n            {\n                // if no ZRO token or not specifying a payment address, pay in native token\n                bool payInNative = _zroPaymentAddress == address(0x0) || address(layerZeroToken) == address(0x0);\n                uint protocolFee = treasuryContract.getFees(!payInNative, totalNativeFee, oracleFee); // totalNativeFee == relayerFee here\n\n                if (protocolFee > 0) {\n                    if (payInNative) {\n                        treasuryNativeFees = treasuryNativeFees.add(protocolFee);\n                        totalNativeFee = totalNativeFee.add(protocolFee);\n                    } else {\n                        // zro payment address must equal the _ua or the tx.origin otherwise the transaction reverts\n                        require(\n                            _zroPaymentAddress == ua || _zroPaymentAddress == tx.origin,\n                            \"LayerZero: must be paid by sender or origin\"\n                        );\n\n                        // transfer the LayerZero token to this contract from the payee\n                        layerZeroToken.safeTransferFrom(_zroPaymentAddress, address(this), protocolFee);\n\n                        treasuryZROFees = treasuryZROFees.add(protocolFee);\n                    }\n                }\n            }\n\n            totalNativeFee = totalNativeFee.add(oracleFee);\n        }\n\n        // (b) emit payload and the adapterParams if any\n        {\n            bytes memory encodedPayload = abi.encodePacked(nonce, ua, _destination, _payload);\n            emit Packet(chainId, encodedPayload);\n            // (c) notify the oracle\n            ILayerZeroOracle(uaConfig.oracle).notifyOracle(\n                chainId,\n                uaConfig.outboundProofType,\n                uaConfig.outboundBlockConfirmations\n            );\n        }\n\n        require(totalNativeFee <= msg.value, \"LayerZero: not enough native for fees\");\n        // refund if they send too much\n        uint amount = msg.value.sub(totalNativeFee);\n        if (amount > 0) {\n            (bool success, ) = _refundAddress.call{value: amount}(\"\");\n            require(success, \"LayerZero: failed to refund\");\n        }\n    }\n\n    // Can be called by any address to update a block header\n    // can only upload new block data or the same block data with more confirmations\n    function updateHash(uint16 _srcChainId, bytes32 _lookupHash, uint _confirmations, bytes32 _data) external override {\n        // this function may revert with a default message if the oracle address is not an ILayerZeroOracle\n        BlockData storage bd = hashLookup[msg.sender][_srcChainId][_lookupHash];\n        // if it has a record, requires a larger confirmation.\n        require(\n            bd.confirmations < _confirmations,\n            \"LayerZero: oracle data can only update if it has more confirmations\"\n        );\n\n        // set the new information into storage\n        bd.confirmations = _confirmations;\n        bd.data = _data;\n\n        emit HashReceived(_srcChainId, msg.sender, _confirmations, _lookupHash);\n    }\n\n    //----------------------------------------------------------------------------------\n    // Other Library Interfaces\n\n    // default to DEFAULT setting if ZERO value\n    function getAppConfig(\n        uint16 _chainId,\n        address userApplicationAddress\n    ) public view returns (ApplicationConfiguration memory) {\n        ApplicationConfiguration memory config = appConfig[userApplicationAddress][_chainId];\n        ApplicationConfiguration storage defaultConfig = defaultAppConfig[_chainId];\n\n        if (config.inboundProofLibraryVersion == 0) {\n            config.inboundProofLibraryVersion = defaultConfig.inboundProofLibraryVersion;\n        }\n\n        if (config.inboundBlockConfirmations == 0) {\n            config.inboundBlockConfirmations = defaultConfig.inboundBlockConfirmations;\n        }\n\n        if (config.relayer == address(0x0)) {\n            config.relayer = defaultConfig.relayer;\n        }\n\n        if (config.outboundProofType == 0) {\n            config.outboundProofType = defaultConfig.outboundProofType;\n        }\n\n        if (config.outboundBlockConfirmations == 0) {\n            config.outboundBlockConfirmations = defaultConfig.outboundBlockConfirmations;\n        }\n\n        if (config.oracle == address(0x0)) {\n            config.oracle = defaultConfig.oracle;\n        }\n\n        return config;\n    }\n\n    function setConfig(\n        uint16 chainId,\n        address _ua,\n        uint _configType,\n        bytes calldata _config\n    ) external override onlyEndpoint {\n        ApplicationConfiguration storage uaConfig = appConfig[_ua][chainId];\n        if (_configType == CONFIG_TYPE_INBOUND_PROOF_LIBRARY_VERSION) {\n            uint16 inboundProofLibraryVersion = abi.decode(_config, (uint16));\n            require(\n                inboundProofLibraryVersion <= maxInboundProofLibrary[chainId],\n                \"LayerZero: invalid inbound proof library version\"\n            );\n            uaConfig.inboundProofLibraryVersion = inboundProofLibraryVersion;\n        } else if (_configType == CONFIG_TYPE_INBOUND_BLOCK_CONFIRMATIONS) {\n            uint64 blockConfirmations = abi.decode(_config, (uint64));\n            uaConfig.inboundBlockConfirmations = blockConfirmations;\n        } else if (_configType == CONFIG_TYPE_RELAYER) {\n            address relayer = abi.decode(_config, (address));\n            uaConfig.relayer = relayer;\n        } else if (_configType == CONFIG_TYPE_OUTBOUND_PROOF_TYPE) {\n            uint16 outboundProofType = abi.decode(_config, (uint16));\n            require(\n                supportedOutboundProof[chainId][outboundProofType] || outboundProofType == 0,\n                \"LayerZero: invalid outbound proof type\"\n            );\n            uaConfig.outboundProofType = outboundProofType;\n        } else if (_configType == CONFIG_TYPE_OUTBOUND_BLOCK_CONFIRMATIONS) {\n            uint64 blockConfirmations = abi.decode(_config, (uint64));\n            uaConfig.outboundBlockConfirmations = blockConfirmations;\n        } else if (_configType == CONFIG_TYPE_ORACLE) {\n            address oracle = abi.decode(_config, (address));\n            uaConfig.oracle = oracle;\n        } else {\n            revert(\"LayerZero: Invalid config type\");\n        }\n\n        emit AppConfigUpdated(_ua, _configType, _config);\n    }\n\n    function getConfig(\n        uint16 _chainId,\n        address userApplicationAddress,\n        uint _configType\n    ) external view override returns (bytes memory) {\n        ApplicationConfiguration storage uaConfig = appConfig[userApplicationAddress][_chainId];\n\n        if (_configType == CONFIG_TYPE_INBOUND_PROOF_LIBRARY_VERSION) {\n            if (uaConfig.inboundProofLibraryVersion == 0) {\n                return abi.encode(defaultAppConfig[_chainId].inboundProofLibraryVersion);\n            }\n            return abi.encode(uaConfig.inboundProofLibraryVersion);\n        } else if (_configType == CONFIG_TYPE_INBOUND_BLOCK_CONFIRMATIONS) {\n            if (uaConfig.inboundBlockConfirmations == 0) {\n                return abi.encode(defaultAppConfig[_chainId].inboundBlockConfirmations);\n            }\n            return abi.encode(uaConfig.inboundBlockConfirmations);\n        } else if (_configType == CONFIG_TYPE_RELAYER) {\n            if (uaConfig.relayer == address(0x0)) {\n                return abi.encode(defaultAppConfig[_chainId].relayer);\n            }\n            return abi.encode(uaConfig.relayer);\n        } else if (_configType == CONFIG_TYPE_OUTBOUND_PROOF_TYPE) {\n            if (uaConfig.outboundProofType == 0) {\n                return abi.encode(defaultAppConfig[_chainId].outboundProofType);\n            }\n            return abi.encode(uaConfig.outboundProofType);\n        } else if (_configType == CONFIG_TYPE_OUTBOUND_BLOCK_CONFIRMATIONS) {\n            if (uaConfig.outboundBlockConfirmations == 0) {\n                return abi.encode(defaultAppConfig[_chainId].outboundBlockConfirmations);\n            }\n            return abi.encode(uaConfig.outboundBlockConfirmations);\n        } else if (_configType == CONFIG_TYPE_ORACLE) {\n            if (uaConfig.oracle == address(0x0)) {\n                return abi.encode(defaultAppConfig[_chainId].oracle);\n            }\n            return abi.encode(uaConfig.oracle);\n        } else {\n            revert(\"LayerZero: Invalid config type\");\n        }\n    }\n\n    // returns the native fee the UA pays to cover fees\n    function estimateFees(\n        uint16 _chainId,\n        address _ua,\n        bytes calldata _payload,\n        bool _payInZRO,\n        bytes calldata _adapterParams\n    ) external view override returns (uint nativeFee, uint zroFee) {\n        uint16 chainId = _chainId;\n        address ua = _ua;\n        uint payloadSize = _payload.length;\n        bytes memory adapterParam = _adapterParams;\n\n        ApplicationConfiguration memory uaConfig = getAppConfig(chainId, ua);\n\n        // Relayer Fee\n        uint relayerFee;\n        {\n            if (adapterParam.length == 0) {\n                bytes memory defaultAdaptorParam = defaultAdapterParams[chainId][uaConfig.outboundProofType];\n                relayerFee = ILayerZeroRelayer(uaConfig.relayer).getPrice(\n                    chainId,\n                    uaConfig.outboundProofType,\n                    ua,\n                    payloadSize,\n                    defaultAdaptorParam\n                );\n            } else {\n                relayerFee = ILayerZeroRelayer(uaConfig.relayer).getPrice(\n                    chainId,\n                    uaConfig.outboundProofType,\n                    ua,\n                    payloadSize,\n                    adapterParam\n                );\n            }\n        }\n\n        // Oracle Fee\n        uint oracleFee = ILayerZeroOracle(uaConfig.oracle).getPrice(chainId, uaConfig.outboundProofType);\n\n        // LayerZero Fee\n        {\n            uint protocolFee = treasuryContract.getFees(_payInZRO, relayerFee, oracleFee);\n            _payInZRO ? zroFee = protocolFee : nativeFee = protocolFee;\n        }\n\n        // return the sum of fees\n        nativeFee = nativeFee.add(relayerFee).add(oracleFee);\n    }\n\n    //---------------------------------------------------------------------------\n    // Claim Fees\n\n    // universal withdraw ZRO token function\n    function withdrawZRO(address _to, uint _amount) external override nonReentrant {\n        require(msg.sender == address(treasuryContract), \"LayerZero: only treasury\");\n        treasuryZROFees = treasuryZROFees.sub(_amount);\n        layerZeroToken.safeTransfer(_to, _amount);\n        emit WithdrawZRO(msg.sender, _to, _amount);\n    }\n\n    // universal withdraw native token function.\n    // the source contract should perform all the authentication control\n    // safemath overflow if the amount is not enough\n    function withdrawNative(\n        uint8 _type,\n        address _owner,\n        address payable _to,\n        uint _amount\n    ) external override nonReentrant {\n        if (_type == WITHDRAW_TYPE_TREASURY_PROTOCOL_FEES) {\n            require(msg.sender == address(treasuryContract), \"LayerZero:only treasury\");\n            treasuryNativeFees = treasuryNativeFees.sub(_amount);\n        } else if (_type == WITHDRAW_TYPE_ORACLE_QUOTED_FEES) {\n            oracleQuotedFees[msg.sender] = oracleQuotedFees[msg.sender].sub(_amount);\n        } else if (_type == WITHDRAW_TYPE_RELAYER_QUOTED_FEES) {\n            relayerQuotedFees[msg.sender] = relayerQuotedFees[msg.sender].sub(_amount);\n        } else {\n            revert(\"LayerZero: unsupported withdraw type\");\n        }\n\n        (bool success, ) = _to.call{value: _amount}(\"\");\n        require(success, \"LayerZero: withdraw failed\");\n        emit WithdrawNative(_type, _owner, msg.sender, _to, _amount);\n    }\n\n    //---------------------------------------------------------------------------\n    // Owner calls, configuration only.\n    function setLayerZeroToken(address _layerZeroToken) external onlyOwner {\n        require(_layerZeroToken != address(0x0), \"LayerZero: _layerZeroToken cannot be zero address\");\n        layerZeroToken = IERC20(_layerZeroToken);\n        emit SetLayerZeroToken(_layerZeroToken);\n    }\n\n    function setTreasury(address _treasury) external onlyOwner {\n        require(_treasury != address(0x0), \"LayerZero: treasury cannot be zero address\");\n        treasuryContract = ILayerZeroTreasury(_treasury);\n        emit SetTreasury(_treasury);\n    }\n\n    function addInboundProofLibraryForChain(uint16 _chainId, address _library) external onlyOwner {\n        require(_library != address(0x0), \"LayerZero: library cannot be zero address\");\n        require(maxInboundProofLibrary[_chainId] < 65535, \"LayerZero: can not add new library\");\n        maxInboundProofLibrary[_chainId]++;\n        inboundProofLibrary[_chainId][maxInboundProofLibrary[_chainId]] = _library;\n        emit AddInboundProofLibraryForChain(_chainId, _library);\n    }\n\n    function enableSupportedOutboundProof(uint16 _chainId, uint16 _proofType) external onlyOwner {\n        supportedOutboundProof[_chainId][_proofType] = true;\n        emit EnableSupportedOutboundProof(_chainId, _proofType);\n    }\n\n    function setDefaultConfigForChainId(\n        uint16 _chainId,\n        uint16 _inboundProofLibraryVersion,\n        uint64 _inboundBlockConfirmations,\n        address _relayer,\n        uint16 _outboundProofType,\n        uint16 _outboundBlockConfirmations,\n        address _oracle\n    ) external onlyOwner {\n        require(\n            _inboundProofLibraryVersion <= maxInboundProofLibrary[_chainId] && _inboundProofLibraryVersion > 0,\n            \"LayerZero: invalid inbound proof library version\"\n        );\n        require(_inboundBlockConfirmations > 0, \"LayerZero: invalid inbound block confirmation\");\n        require(_relayer != address(0x0), \"LayerZero: invalid relayer address\");\n        require(supportedOutboundProof[_chainId][_outboundProofType], \"LayerZero: invalid outbound proof type\");\n        require(_outboundBlockConfirmations > 0, \"LayerZero: invalid outbound block confirmation\");\n        require(_oracle != address(0x0), \"LayerZero: invalid oracle address\");\n        defaultAppConfig[_chainId] = ApplicationConfiguration(\n            _inboundProofLibraryVersion,\n            _inboundBlockConfirmations,\n            _relayer,\n            _outboundProofType,\n            _outboundBlockConfirmations,\n            _oracle\n        );\n        emit SetDefaultConfigForChainId(\n            _chainId,\n            _inboundProofLibraryVersion,\n            _inboundBlockConfirmations,\n            _relayer,\n            _outboundProofType,\n            _outboundBlockConfirmations,\n            _oracle\n        );\n    }\n\n    function setDefaultAdapterParamsForChainId(\n        uint16 _chainId,\n        uint16 _proofType,\n        bytes calldata _adapterParams\n    ) external onlyOwner {\n        defaultAdapterParams[_chainId][_proofType] = _adapterParams;\n        emit SetDefaultAdapterParamsForChainId(_chainId, _proofType, _adapterParams);\n    }\n\n    function setRemoteUln(uint16 _remoteChainId, bytes32 _remoteUln) external onlyOwner {\n        require(ulnLookup[_remoteChainId] == bytes32(0), \"LayerZero: remote uln already set\");\n        ulnLookup[_remoteChainId] = _remoteUln;\n        emit SetRemoteUln(_remoteChainId, _remoteUln);\n    }\n\n    function setChainAddressSize(uint16 _chainId, uint _size) external onlyOwner {\n        require(chainAddressSizeMap[_chainId] == 0, \"LayerZero: remote chain address size already set\");\n        chainAddressSizeMap[_chainId] = _size;\n        emit SetChainAddressSize(_chainId, _size);\n    }\n\n    //----------------------------------------------------------------------------------\n    // view functions\n    function getBlockHeaderData(\n        address _oracle,\n        uint16 _remoteChainId,\n        bytes32 _lookupHash\n    ) external view returns (BlockData memory blockData) {\n        return hashLookup[_oracle][_remoteChainId][_lookupHash];\n    }\n\n    function oracleQuotedAmount(address _oracle) external view override returns (uint) {\n        return oracleQuotedFees[_oracle];\n    }\n\n    function relayerQuotedAmount(address _relayer) external view override returns (uint) {\n        return relayerQuotedFees[_relayer];\n    }\n}\n"
    },
    "contracts/V1Contracts/contracts/UltraLightNodeV2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";import \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"./interfaces/ILayerZeroValidationLibrary.sol\";\nimport \"./interfaces/ILayerZeroReceiver.sol\";\nimport \"./interfaces/ILayerZeroTreasury.sol\";\nimport \"./interfaces/ILayerZeroEndpoint.sol\";\n// v2\nimport \"./interfaces/ILayerZeroMessagingLibraryV2.sol\";\nimport \"./interfaces/ILayerZeroOracleV2.sol\";\nimport \"./interfaces/ILayerZeroUltraLightNodeV2.sol\";\nimport \"./interfaces/ILayerZeroRelayerV2.sol\";\nimport \"./NonceContract.sol\";\n\ncontract UltraLightNodeV2 is ILayerZeroMessagingLibraryV2, ILayerZeroUltraLightNodeV2, ReentrancyGuard, Ownable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint;\n\n    // Application config\n    uint public constant CONFIG_TYPE_INBOUND_PROOF_LIBRARY_VERSION = 1;\n    uint public constant CONFIG_TYPE_INBOUND_BLOCK_CONFIRMATIONS = 2;\n    uint public constant CONFIG_TYPE_RELAYER = 3;\n    uint public constant CONFIG_TYPE_OUTBOUND_PROOF_TYPE = 4;\n    uint public constant CONFIG_TYPE_OUTBOUND_BLOCK_CONFIRMATIONS = 5;\n    uint public constant CONFIG_TYPE_ORACLE = 6;\n\n    // Token and Contracts\n    IERC20 public layerZeroToken;\n    ILayerZeroTreasury public treasuryContract;\n\n    mapping(address => uint) public nativeFees;\n    uint public treasuryZROFees;\n\n    // User Application\n    mapping(address => mapping(uint16 => ApplicationConfiguration)) public appConfig; // app address => chainId => config\n    mapping(uint16 => ApplicationConfiguration) public defaultAppConfig; // default UA settings if no version specified\n    mapping(uint16 => mapping(uint16 => bytes)) public defaultAdapterParams;\n\n    // Validation\n    mapping(uint16 => mapping(uint16 => address)) public inboundProofLibrary; // chainId => library Id => inboundProofLibrary contract\n    mapping(uint16 => uint16) public maxInboundProofLibrary; // chainId => inboundProofLibrary\n    mapping(uint16 => mapping(uint16 => bool)) public supportedOutboundProof; // chainId => outboundProofType => enabled\n    mapping(uint16 => uint) public chainAddressSizeMap;\n    mapping(address => mapping(uint16 => mapping(bytes32 => mapping(bytes32 => uint)))) public hashLookup; //[oracle][srcChainId][blockhash][datahash] -> confirmation\n    mapping(uint16 => bytes32) public ulnLookup; // remote ulns\n\n    ILayerZeroEndpoint public immutable endpoint;\n    uint16 public immutable localChainId;\n    NonceContract public immutable nonceContract;\n\n    constructor(address _endpoint, address _nonceContract, uint16 _localChainId) {\n        require(_endpoint != address(0x0), \"LayerZero: endpoint cannot be zero address\");\n        require(_nonceContract != address(0x0), \"LayerZero: nonceContract cannot be zero address\");\n        ILayerZeroEndpoint lzEndpoint = ILayerZeroEndpoint(_endpoint);\n        localChainId = _localChainId;\n        endpoint = lzEndpoint;\n        nonceContract = NonceContract(_nonceContract);\n    }\n\n    // only the endpoint can call SEND() and setConfig()\n    modifier onlyEndpoint() {\n        require(address(endpoint) == msg.sender, \"LayerZero: only endpoint\");\n        _;\n    }\n\n    //----------------------------------------------------------------------------------\n    // PROTOCOL\n    function validateTransactionProof(\n        uint16 _srcChainId,\n        address _dstAddress,\n        uint _gasLimit,\n        bytes32 _lookupHash,\n        bytes32 _blockData,\n        bytes calldata _transactionProof\n    ) external override {\n        // retrieve UA's configuration using the _dstAddress from arguments.\n        ApplicationConfiguration memory uaConfig = _getAppConfig(_srcChainId, _dstAddress);\n\n        // assert that the caller == UA's relayer\n        require(uaConfig.relayer == msg.sender, \"LayerZero: invalid relayer\");\n\n        LayerZeroPacket.Packet memory _packet;\n        uint remoteAddressSize = chainAddressSizeMap[_srcChainId];\n        require(remoteAddressSize != 0, \"LayerZero: incorrect remote address size\");\n        {\n            // assert that the data submitted by UA's oracle have no fewer confirmations than UA's configuration\n            uint storedConfirmations = hashLookup[uaConfig.oracle][_srcChainId][_lookupHash][_blockData];\n            require(\n                storedConfirmations > 0 && storedConfirmations >= uaConfig.inboundBlockConfirmations,\n                \"LayerZero: not enough block confirmations\"\n            );\n\n            // decode\n            address inboundProofLib = inboundProofLibrary[_srcChainId][uaConfig.inboundProofLibraryVersion];\n            _packet = ILayerZeroValidationLibrary(inboundProofLib).validateProof(\n                _blockData,\n                _transactionProof,\n                remoteAddressSize\n            );\n        }\n\n        // packet content assertion\n        require(\n            ulnLookup[_srcChainId] == _packet.ulnAddress && _packet.ulnAddress != bytes32(0),\n            \"LayerZero: invalid _packet.ulnAddress\"\n        );\n        require(_packet.srcChainId == _srcChainId, \"LayerZero: invalid srcChain Id\");\n        // failsafe because the remoteAddress size being passed into validateProof trims the address this should not hit\n        require(_packet.srcAddress.length == remoteAddressSize, \"LayerZero: invalid srcAddress size\");\n        require(_packet.dstChainId == localChainId, \"LayerZero: invalid dstChain Id\");\n        require(_packet.dstAddress == _dstAddress, \"LayerZero: invalid dstAddress\");\n\n        // if the dst is not a contract, then emit and return early. This will break inbound nonces, but this particular\n        // path is already broken and wont ever be able to deliver anyways\n        if (!_isContract(_dstAddress)) {\n            emit InvalidDst(\n                _packet.srcChainId,\n                _packet.srcAddress,\n                _packet.dstAddress,\n                _packet.nonce,\n                keccak256(_packet.payload)\n            );\n            return;\n        }\n\n        bytes memory pathData = abi.encodePacked(_packet.srcAddress, _packet.dstAddress);\n        emit PacketReceived(\n            _packet.srcChainId,\n            _packet.srcAddress,\n            _packet.dstAddress,\n            _packet.nonce,\n            keccak256(_packet.payload)\n        );\n        endpoint.receivePayload(_srcChainId, pathData, _dstAddress, _packet.nonce, _gasLimit, _packet.payload);\n    }\n\n    function send(\n        address _ua,\n        uint64,\n        uint16 _dstChainId,\n        bytes calldata _path,\n        bytes calldata _payload,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes calldata _adapterParams\n    ) external payable override onlyEndpoint {\n        address ua = _ua;\n        uint16 dstChainId = _dstChainId;\n        require(ulnLookup[dstChainId] != bytes32(0), \"LayerZero: dstChainId does not exist\");\n\n        bytes memory dstAddress;\n        uint64 nonce;\n        // code block for solving 'Stack Too Deep'\n        {\n            uint chainAddressSize = chainAddressSizeMap[dstChainId];\n            // path = remoteAddress + localAddress\n            require(\n                chainAddressSize != 0 && _path.length == 20 + chainAddressSize,\n                \"LayerZero: incorrect remote address size\"\n            );\n            address srcInPath;\n            bytes memory path = _path; // copy to memory\n            assembly {\n                srcInPath := mload(add(add(path, 20), chainAddressSize)) // chainAddressSize + 20\n            }\n            require(ua == srcInPath, \"LayerZero: wrong path data\");\n            dstAddress = _path[0:chainAddressSize];\n            nonce = nonceContract.increment(dstChainId, ua, path);\n        }\n\n        bytes memory payload = _payload;\n        ApplicationConfiguration memory uaConfig = _getAppConfig(dstChainId, ua);\n\n        // compute all the fees\n        uint relayerFee = _handleRelayer(dstChainId, uaConfig, ua, payload.length, _adapterParams);\n        uint oracleFee = _handleOracle(dstChainId, uaConfig, ua);\n        uint nativeProtocolFee = _handleProtocolFee(relayerFee, oracleFee, ua, _zroPaymentAddress);\n\n        // total native fee, does not include ZRO protocol fee\n        uint totalNativeFee = relayerFee.add(oracleFee).add(nativeProtocolFee);\n\n        // assert the user has attached enough native token for this address\n        require(totalNativeFee <= msg.value, \"LayerZero: not enough native for fees\");\n        // refund if they send too much\n        uint amount = msg.value.sub(totalNativeFee);\n        if (amount > 0) {\n            (bool success, ) = _refundAddress.call{value: amount}(\"\");\n            require(success, \"LayerZero: failed to refund\");\n        }\n\n        // emit the data packet\n        bytes memory encodedPayload = abi.encodePacked(nonce, localChainId, ua, dstChainId, dstAddress, payload);\n        emit Packet(encodedPayload);\n    }\n\n    function _handleRelayer(\n        uint16 _dstChainId,\n        ApplicationConfiguration memory _uaConfig,\n        address _ua,\n        uint _payloadSize,\n        bytes memory _adapterParams\n    ) internal returns (uint relayerFee) {\n        if (_adapterParams.length == 0) {\n            _adapterParams = defaultAdapterParams[_dstChainId][_uaConfig.outboundProofType];\n        }\n        address relayerAddress = _uaConfig.relayer;\n        ILayerZeroRelayerV2 relayer = ILayerZeroRelayerV2(relayerAddress);\n        relayerFee = relayer.assignJob(_dstChainId, _uaConfig.outboundProofType, _ua, _payloadSize, _adapterParams);\n\n        _creditNativeFee(relayerAddress, relayerFee);\n\n        // emit the param events\n        emit RelayerParams(_adapterParams, _uaConfig.outboundProofType);\n    }\n\n    function _handleOracle(\n        uint16 _dstChainId,\n        ApplicationConfiguration memory _uaConfig,\n        address _ua\n    ) internal returns (uint oracleFee) {\n        address oracleAddress = _uaConfig.oracle;\n        oracleFee = ILayerZeroOracleV2(oracleAddress).assignJob(\n            _dstChainId,\n            _uaConfig.outboundProofType,\n            _uaConfig.outboundBlockConfirmations,\n            _ua\n        );\n\n        _creditNativeFee(oracleAddress, oracleFee);\n    }\n\n    function _handleProtocolFee(\n        uint _relayerFee,\n        uint _oracleFee,\n        address _ua,\n        address _zroPaymentAddress\n    ) internal returns (uint protocolNativeFee) {\n        // if no ZRO token or not specifying a payment address, pay in native token\n        bool payInNative = _zroPaymentAddress == address(0x0) || address(layerZeroToken) == address(0x0);\n        uint protocolFee = treasuryContract.getFees(!payInNative, _relayerFee, _oracleFee);\n\n        if (protocolFee > 0) {\n            if (payInNative) {\n                address treasuryAddress = address(treasuryContract);\n                _creditNativeFee(treasuryAddress, protocolFee);\n                protocolNativeFee = protocolFee;\n            } else {\n                // zro payment address must equal the ua or the tx.origin otherwise the transaction reverts\n                require(\n                    _zroPaymentAddress == _ua || _zroPaymentAddress == tx.origin,\n                    \"LayerZero: must be paid by sender or origin\"\n                );\n\n                // transfer the LayerZero token to this contract from the payee\n                layerZeroToken.safeTransferFrom(_zroPaymentAddress, address(this), protocolFee);\n\n                treasuryZROFees = treasuryZROFees.add(protocolFee);\n            }\n        }\n    }\n\n    function _creditNativeFee(address _receiver, uint _amount) internal {\n        nativeFees[_receiver] = nativeFees[_receiver].add(_amount);\n    }\n\n    // Can be called by any address to update a block header\n    // can only upload new block data or the same block data with more confirmations\n    function updateHash(\n        uint16 _srcChainId,\n        bytes32 _lookupHash,\n        uint _confirmations,\n        bytes32 _blockData\n    ) external override {\n        uint storedConfirmations = hashLookup[msg.sender][_srcChainId][_lookupHash][_blockData];\n\n        // if it has a record, requires a larger confirmation.\n        require(\n            storedConfirmations < _confirmations,\n            \"LayerZero: oracle data can only update if it has more confirmations\"\n        );\n\n        // set the new information into storage\n        hashLookup[msg.sender][_srcChainId][_lookupHash][_blockData] = _confirmations;\n\n        emit HashReceived(_srcChainId, msg.sender, _lookupHash, _blockData, _confirmations);\n    }\n\n    //----------------------------------------------------------------------------------\n    // Other Library Interfaces\n\n    // default to DEFAULT setting if ZERO value\n    function getAppConfig(\n        uint16 _remoteChainId,\n        address _ua\n    ) external view override returns (ApplicationConfiguration memory) {\n        return _getAppConfig(_remoteChainId, _ua);\n    }\n\n    function _getAppConfig(uint16 _remoteChainId, address _ua) internal view returns (ApplicationConfiguration memory) {\n        ApplicationConfiguration memory config = appConfig[_ua][_remoteChainId];\n        ApplicationConfiguration storage defaultConfig = defaultAppConfig[_remoteChainId];\n\n        if (config.inboundProofLibraryVersion == 0) {\n            config.inboundProofLibraryVersion = defaultConfig.inboundProofLibraryVersion;\n        }\n\n        if (config.inboundBlockConfirmations == 0) {\n            config.inboundBlockConfirmations = defaultConfig.inboundBlockConfirmations;\n        }\n\n        if (config.relayer == address(0x0)) {\n            config.relayer = defaultConfig.relayer;\n        }\n\n        if (config.outboundProofType == 0) {\n            config.outboundProofType = defaultConfig.outboundProofType;\n        }\n\n        if (config.outboundBlockConfirmations == 0) {\n            config.outboundBlockConfirmations = defaultConfig.outboundBlockConfirmations;\n        }\n\n        if (config.oracle == address(0x0)) {\n            config.oracle = defaultConfig.oracle;\n        }\n\n        return config;\n    }\n\n    function setConfig(\n        uint16 _remoteChainId,\n        address _ua,\n        uint _configType,\n        bytes calldata _config\n    ) external override onlyEndpoint {\n        ApplicationConfiguration storage uaConfig = appConfig[_ua][_remoteChainId];\n        if (_configType == CONFIG_TYPE_INBOUND_PROOF_LIBRARY_VERSION) {\n            uint16 inboundProofLibraryVersion = abi.decode(_config, (uint16));\n            require(\n                inboundProofLibraryVersion <= maxInboundProofLibrary[_remoteChainId],\n                \"LayerZero: invalid inbound proof library version\"\n            );\n            uaConfig.inboundProofLibraryVersion = inboundProofLibraryVersion;\n        } else if (_configType == CONFIG_TYPE_INBOUND_BLOCK_CONFIRMATIONS) {\n            uint64 blockConfirmations = abi.decode(_config, (uint64));\n            uaConfig.inboundBlockConfirmations = blockConfirmations;\n        } else if (_configType == CONFIG_TYPE_RELAYER) {\n            address relayer = abi.decode(_config, (address));\n            uaConfig.relayer = relayer;\n        } else if (_configType == CONFIG_TYPE_OUTBOUND_PROOF_TYPE) {\n            uint16 outboundProofType = abi.decode(_config, (uint16));\n            require(\n                supportedOutboundProof[_remoteChainId][outboundProofType] || outboundProofType == 0,\n                \"LayerZero: invalid outbound proof type\"\n            );\n            uaConfig.outboundProofType = outboundProofType;\n        } else if (_configType == CONFIG_TYPE_OUTBOUND_BLOCK_CONFIRMATIONS) {\n            uint64 blockConfirmations = abi.decode(_config, (uint64));\n            uaConfig.outboundBlockConfirmations = blockConfirmations;\n        } else if (_configType == CONFIG_TYPE_ORACLE) {\n            address oracle = abi.decode(_config, (address));\n            uaConfig.oracle = oracle;\n        } else {\n            revert(\"LayerZero: Invalid config type\");\n        }\n\n        emit AppConfigUpdated(_ua, _configType, _config);\n    }\n\n    function getConfig(\n        uint16 _remoteChainId,\n        address _ua,\n        uint _configType\n    ) external view override returns (bytes memory) {\n        ApplicationConfiguration storage uaConfig = appConfig[_ua][_remoteChainId];\n\n        if (_configType == CONFIG_TYPE_INBOUND_PROOF_LIBRARY_VERSION) {\n            if (uaConfig.inboundProofLibraryVersion == 0) {\n                return abi.encode(defaultAppConfig[_remoteChainId].inboundProofLibraryVersion);\n            }\n            return abi.encode(uaConfig.inboundProofLibraryVersion);\n        } else if (_configType == CONFIG_TYPE_INBOUND_BLOCK_CONFIRMATIONS) {\n            if (uaConfig.inboundBlockConfirmations == 0) {\n                return abi.encode(defaultAppConfig[_remoteChainId].inboundBlockConfirmations);\n            }\n            return abi.encode(uaConfig.inboundBlockConfirmations);\n        } else if (_configType == CONFIG_TYPE_RELAYER) {\n            if (uaConfig.relayer == address(0x0)) {\n                return abi.encode(defaultAppConfig[_remoteChainId].relayer);\n            }\n            return abi.encode(uaConfig.relayer);\n        } else if (_configType == CONFIG_TYPE_OUTBOUND_PROOF_TYPE) {\n            if (uaConfig.outboundProofType == 0) {\n                return abi.encode(defaultAppConfig[_remoteChainId].outboundProofType);\n            }\n            return abi.encode(uaConfig.outboundProofType);\n        } else if (_configType == CONFIG_TYPE_OUTBOUND_BLOCK_CONFIRMATIONS) {\n            if (uaConfig.outboundBlockConfirmations == 0) {\n                return abi.encode(defaultAppConfig[_remoteChainId].outboundBlockConfirmations);\n            }\n            return abi.encode(uaConfig.outboundBlockConfirmations);\n        } else if (_configType == CONFIG_TYPE_ORACLE) {\n            if (uaConfig.oracle == address(0x0)) {\n                return abi.encode(defaultAppConfig[_remoteChainId].oracle);\n            }\n            return abi.encode(uaConfig.oracle);\n        } else {\n            revert(\"LayerZero: Invalid config type\");\n        }\n    }\n\n    // returns the native fee the UA pays to cover fees\n    function estimateFees(\n        uint16 _dstChainId,\n        address _ua,\n        bytes calldata _payload,\n        bool _payInZRO,\n        bytes calldata _adapterParams\n    ) external view override returns (uint nativeFee, uint zroFee) {\n        ApplicationConfiguration memory uaConfig = _getAppConfig(_dstChainId, _ua);\n\n        // Relayer Fee\n        bytes memory adapterParams;\n        if (_adapterParams.length > 0) {\n            adapterParams = _adapterParams;\n        } else {\n            adapterParams = defaultAdapterParams[_dstChainId][uaConfig.outboundProofType];\n        }\n        uint relayerFee = ILayerZeroRelayerV2(uaConfig.relayer).getFee(\n            _dstChainId,\n            uaConfig.outboundProofType,\n            _ua,\n            _payload.length,\n            adapterParams\n        );\n\n        // Oracle Fee\n        address ua = _ua; // stack too deep\n        uint oracleFee = ILayerZeroOracleV2(uaConfig.oracle).getFee(\n            _dstChainId,\n            uaConfig.outboundProofType,\n            uaConfig.outboundBlockConfirmations,\n            ua\n        );\n\n        // LayerZero Fee\n        uint protocolFee = treasuryContract.getFees(_payInZRO, relayerFee, oracleFee);\n        _payInZRO ? zroFee = protocolFee : nativeFee = protocolFee;\n\n        // return the sum of fees\n        nativeFee = nativeFee.add(relayerFee).add(oracleFee);\n    }\n\n    //---------------------------------------------------------------------------\n    // Claim Fees\n\n    // universal withdraw ZRO token function\n    function withdrawZRO(address _to, uint _amount) external override nonReentrant {\n        require(msg.sender == address(treasuryContract), \"LayerZero: only treasury\");\n        treasuryZROFees = treasuryZROFees.sub(_amount);\n        layerZeroToken.safeTransfer(_to, _amount);\n        emit WithdrawZRO(msg.sender, _to, _amount);\n    }\n\n    // universal withdraw native token function.\n    // the source contract should perform all the authentication control\n    function withdrawNative(address payable _to, uint _amount) external override nonReentrant {\n        require(_to != address(0x0), \"LayerZero: _to cannot be zero address\");\n        nativeFees[msg.sender] = nativeFees[msg.sender].sub(_amount);\n\n        (bool success, ) = _to.call{value: _amount}(\"\");\n        require(success, \"LayerZero: withdraw failed\");\n        emit WithdrawNative(msg.sender, _to, _amount);\n    }\n\n    //---------------------------------------------------------------------------\n    // Owner calls, configuration only.\n    function setLayerZeroToken(address _layerZeroToken) external onlyOwner {\n        require(_layerZeroToken != address(0x0), \"LayerZero: _layerZeroToken cannot be zero address\");\n        layerZeroToken = IERC20(_layerZeroToken);\n        emit SetLayerZeroToken(_layerZeroToken);\n    }\n\n    function setTreasury(address _treasury) external onlyOwner {\n        require(_treasury != address(0x0), \"LayerZero: treasury cannot be zero address\");\n        treasuryContract = ILayerZeroTreasury(_treasury);\n        emit SetTreasury(_treasury);\n    }\n\n    function addInboundProofLibraryForChain(uint16 _chainId, address _library) external onlyOwner {\n        require(_library != address(0x0), \"LayerZero: library cannot be zero address\");\n        uint16 libId = maxInboundProofLibrary[_chainId];\n        require(libId < 65535, \"LayerZero: can not add new library\");\n        maxInboundProofLibrary[_chainId] = ++libId;\n        inboundProofLibrary[_chainId][libId] = _library;\n        emit AddInboundProofLibraryForChain(_chainId, _library);\n    }\n\n    function enableSupportedOutboundProof(uint16 _chainId, uint16 _proofType) external onlyOwner {\n        supportedOutboundProof[_chainId][_proofType] = true;\n        emit EnableSupportedOutboundProof(_chainId, _proofType);\n    }\n\n    function setDefaultConfigForChainId(\n        uint16 _chainId,\n        uint16 _inboundProofLibraryVersion,\n        uint64 _inboundBlockConfirmations,\n        address _relayer,\n        uint16 _outboundProofType,\n        uint64 _outboundBlockConfirmations,\n        address _oracle\n    ) external onlyOwner {\n        require(\n            _inboundProofLibraryVersion <= maxInboundProofLibrary[_chainId] && _inboundProofLibraryVersion > 0,\n            \"LayerZero: invalid inbound proof library version\"\n        );\n        require(_inboundBlockConfirmations > 0, \"LayerZero: invalid inbound block confirmation\");\n        require(_relayer != address(0x0), \"LayerZero: invalid relayer address\");\n        require(supportedOutboundProof[_chainId][_outboundProofType], \"LayerZero: invalid outbound proof type\");\n        require(_outboundBlockConfirmations > 0, \"LayerZero: invalid outbound block confirmation\");\n        require(_oracle != address(0x0), \"LayerZero: invalid oracle address\");\n        defaultAppConfig[_chainId] = ApplicationConfiguration(\n            _inboundProofLibraryVersion,\n            _inboundBlockConfirmations,\n            _relayer,\n            _outboundProofType,\n            _outboundBlockConfirmations,\n            _oracle\n        );\n        emit SetDefaultConfigForChainId(\n            _chainId,\n            _inboundProofLibraryVersion,\n            _inboundBlockConfirmations,\n            _relayer,\n            _outboundProofType,\n            _outboundBlockConfirmations,\n            _oracle\n        );\n    }\n\n    function setDefaultAdapterParamsForChainId(\n        uint16 _chainId,\n        uint16 _proofType,\n        bytes calldata _adapterParams\n    ) external onlyOwner {\n        defaultAdapterParams[_chainId][_proofType] = _adapterParams;\n        emit SetDefaultAdapterParamsForChainId(_chainId, _proofType, _adapterParams);\n    }\n\n    function setRemoteUln(uint16 _remoteChainId, bytes32 _remoteUln) external onlyOwner {\n        require(ulnLookup[_remoteChainId] == bytes32(0), \"LayerZero: remote uln already set\");\n        ulnLookup[_remoteChainId] = _remoteUln;\n        emit SetRemoteUln(_remoteChainId, _remoteUln);\n    }\n\n    function setChainAddressSize(uint16 _chainId, uint _size) external onlyOwner {\n        require(chainAddressSizeMap[_chainId] == 0, \"LayerZero: remote chain address size already set\");\n        chainAddressSizeMap[_chainId] = _size;\n        emit SetChainAddressSize(_chainId, _size);\n    }\n\n    //----------------------------------------------------------------------------------\n    // view functions\n\n    function accruedNativeFee(address _address) external view override returns (uint) {\n        return nativeFees[_address];\n    }\n\n    function getOutboundNonce(uint16 _chainId, bytes calldata _path) external view override returns (uint64) {\n        return nonceContract.outboundNonce(_chainId, _path);\n    }\n\n    function _isContract(address addr) internal view returns (bool) {\n        uint size;\n        assembly {\n            size := extcodesize(addr)\n        }\n        return size != 0;\n    }\n}\n"
    },
    "contracts/V1Contracts/contracts/UltraLightNodeV2AltToken.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";import \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"./interfaces/ILayerZeroValidationLibrary.sol\";\nimport \"./interfaces/ILayerZeroReceiver.sol\";\nimport \"./interfaces/ILayerZeroTreasury.sol\";\nimport \"./interfaces/ILayerZeroEndpoint.sol\";\n// v2\nimport \"./interfaces/ILayerZeroMessagingLibraryV2.sol\";\nimport \"./interfaces/ILayerZeroOracleV2.sol\";\nimport \"./interfaces/ILayerZeroUltraLightNodeV2.sol\";\nimport \"./interfaces/ILayerZeroRelayerV2.sol\";\nimport \"./FeeHandler.sol\";\nimport \"./NonceContract.sol\";\n\ncontract UltraLightNodeV2AltToken is\n    ILayerZeroMessagingLibraryV2,\n    ILayerZeroUltraLightNodeV2,\n    ReentrancyGuard,\n    Ownable\n{\n    using SafeERC20 for IERC20;\n    using SafeMath for uint;\n\n    // Application config\n    uint public constant CONFIG_TYPE_INBOUND_PROOF_LIBRARY_VERSION = 1;\n    uint public constant CONFIG_TYPE_INBOUND_BLOCK_CONFIRMATIONS = 2;\n    uint public constant CONFIG_TYPE_RELAYER = 3;\n    uint public constant CONFIG_TYPE_OUTBOUND_PROOF_TYPE = 4;\n    uint public constant CONFIG_TYPE_OUTBOUND_BLOCK_CONFIRMATIONS = 5;\n    uint public constant CONFIG_TYPE_ORACLE = 6;\n\n    // Token and Contracts\n    IERC20 public layerZeroToken;\n    ILayerZeroTreasury public treasuryContract;\n\n    mapping(address => uint) public nativeFees;\n    uint public treasuryZROFees;\n\n    // User Application\n    mapping(address => mapping(uint16 => ApplicationConfiguration)) public appConfig; // app address => chainId => config\n    mapping(uint16 => ApplicationConfiguration) public defaultAppConfig; // default UA settings if no version specified\n    mapping(uint16 => mapping(uint16 => bytes)) public defaultAdapterParams;\n\n    // Validation\n    mapping(uint16 => mapping(uint16 => address)) public inboundProofLibrary; // chainId => library Id => inboundProofLibrary contract\n    mapping(uint16 => uint16) public maxInboundProofLibrary; // chainId => inboundProofLibrary\n    mapping(uint16 => mapping(uint16 => bool)) public supportedOutboundProof; // chainId => outboundProofType => enabled\n    mapping(uint16 => uint) public chainAddressSizeMap;\n    mapping(address => mapping(uint16 => mapping(bytes32 => mapping(bytes32 => uint)))) public hashLookup; //[oracle][srcChainId][blockhash][datahash] -> confirmation\n    mapping(uint16 => bytes32) public ulnLookup; // remote ulns\n\n    ILayerZeroEndpoint public immutable endpoint;\n    uint16 public immutable localChainId;\n    NonceContract public immutable nonceContract;\n    FeeHandler public immutable feeHandler;\n\n    constructor(address _endpoint, address _nonceContract, uint16 _localChainId, address _feeHandler) {\n        require(_endpoint != address(0x0), \"LayerZero: endpoint cannot be zero address\");\n        require(_nonceContract != address(0x0), \"LayerZero: nonceContract cannot be zero address\");\n        ILayerZeroEndpoint lzEndpoint = ILayerZeroEndpoint(_endpoint);\n        localChainId = _localChainId;\n        endpoint = lzEndpoint;\n        nonceContract = NonceContract(_nonceContract);\n        feeHandler = FeeHandler(_feeHandler);\n    }\n\n    // only the endpoint can call SEND() and setConfig()\n    modifier onlyEndpoint() {\n        require(address(endpoint) == msg.sender, \"LayerZero: only endpoint\");\n        _;\n    }\n\n    //----------------------------------------------------------------------------------\n    // PROTOCOL\n    function validateTransactionProof(\n        uint16 _srcChainId,\n        address _dstAddress,\n        uint _gasLimit,\n        bytes32 _lookupHash,\n        bytes32 _blockData,\n        bytes calldata _transactionProof\n    ) external override {\n        // retrieve UA's configuration using the _dstAddress from arguments.\n        ApplicationConfiguration memory uaConfig = _getAppConfig(_srcChainId, _dstAddress);\n\n        // assert that the caller == UA's relayer\n        require(uaConfig.relayer == msg.sender, \"LayerZero: invalid relayer\");\n\n        LayerZeroPacket.Packet memory _packet;\n        uint remoteAddressSize = chainAddressSizeMap[_srcChainId];\n        require(remoteAddressSize != 0, \"LayerZero: incorrect remote address size\");\n        {\n            // assert that the data submitted by UA's oracle have no fewer confirmations than UA's configuration\n            uint storedConfirmations = hashLookup[uaConfig.oracle][_srcChainId][_lookupHash][_blockData];\n            require(\n                storedConfirmations > 0 && storedConfirmations >= uaConfig.inboundBlockConfirmations,\n                \"LayerZero: not enough block confirmations\"\n            );\n\n            // decode\n            address inboundProofLib = inboundProofLibrary[_srcChainId][uaConfig.inboundProofLibraryVersion];\n            _packet = ILayerZeroValidationLibrary(inboundProofLib).validateProof(\n                _blockData,\n                _transactionProof,\n                remoteAddressSize\n            );\n        }\n\n        // packet content assertion\n        require(\n            ulnLookup[_srcChainId] == _packet.ulnAddress && _packet.ulnAddress != bytes32(0),\n            \"LayerZero: invalid _packet.ulnAddress\"\n        );\n        require(_packet.srcChainId == _srcChainId, \"LayerZero: invalid srcChain Id\");\n        // failsafe because the remoteAddress size being passed into validateProof trims the address this should not hit\n        require(_packet.srcAddress.length == remoteAddressSize, \"LayerZero: invalid srcAddress size\");\n        require(_packet.dstChainId == localChainId, \"LayerZero: invalid dstChain Id\");\n        require(_packet.dstAddress == _dstAddress, \"LayerZero: invalid dstAddress\");\n\n        // if the dst is not a contract, then emit and return early. This will break inbound nonces, but this particular\n        // path is already broken and wont ever be able to deliver anyways\n        if (!_isContract(_dstAddress)) {\n            emit InvalidDst(\n                _packet.srcChainId,\n                _packet.srcAddress,\n                _packet.dstAddress,\n                _packet.nonce,\n                keccak256(_packet.payload)\n            );\n            return;\n        }\n\n        bytes memory pathData = abi.encodePacked(_packet.srcAddress, _packet.dstAddress);\n        emit PacketReceived(\n            _packet.srcChainId,\n            _packet.srcAddress,\n            _packet.dstAddress,\n            _packet.nonce,\n            keccak256(_packet.payload)\n        );\n        endpoint.receivePayload(_srcChainId, pathData, _dstAddress, _packet.nonce, _gasLimit, _packet.payload);\n    }\n\n    function send(\n        address _ua,\n        uint64,\n        uint16 _dstChainId,\n        bytes calldata _path,\n        bytes calldata _payload,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes calldata _adapterParams\n    ) external payable override onlyEndpoint {\n        address ua = _ua;\n        uint16 dstChainId = _dstChainId;\n        require(ulnLookup[dstChainId] != bytes32(0), \"LayerZero: dstChainId does not exist\");\n\n        bytes memory dstAddress;\n        uint64 nonce;\n        // code block for solving 'Stack Too Deep'\n        {\n            uint chainAddressSize = chainAddressSizeMap[dstChainId];\n            // path = remoteAddress + localAddress\n            require(\n                chainAddressSize != 0 && _path.length == 20 + chainAddressSize,\n                \"LayerZero: incorrect remote address size\"\n            );\n            address srcInPath;\n            bytes memory path = _path; // copy to memory\n            assembly {\n                srcInPath := mload(add(add(path, 20), chainAddressSize)) // chainAddressSize + 20\n            }\n            require(ua == srcInPath, \"LayerZero: wrong path data\");\n            dstAddress = _path[0:chainAddressSize];\n            nonce = nonceContract.increment(dstChainId, ua, path);\n        }\n\n        bytes memory payload = _payload;\n        ApplicationConfiguration memory uaConfig = _getAppConfig(dstChainId, ua);\n\n        // compute all the fees\n        uint[] memory fees = new uint[](3);\n        fees[0] = _handleRelayer(dstChainId, uaConfig, ua, payload.length, _adapterParams);\n        fees[1] = _handleOracle(dstChainId, uaConfig, ua);\n        fees[2] = _handleProtocolFee(fees[0], fees[1], ua, _zroPaymentAddress);\n\n        address[] memory receivers = new address[](3);\n        receivers[0] = uaConfig.relayer;\n        receivers[1] = uaConfig.oracle;\n        receivers[2] = address(treasuryContract);\n\n        feeHandler.creditFee(receivers, fees, _refundAddress);\n\n        // emit the data packet\n        bytes memory encodedPayload = abi.encodePacked(nonce, localChainId, ua, dstChainId, dstAddress, payload);\n        emit Packet(encodedPayload);\n    }\n\n    function _handleRelayer(\n        uint16 _dstChainId,\n        ApplicationConfiguration memory _uaConfig,\n        address _ua,\n        uint _payloadSize,\n        bytes memory _adapterParams\n    ) internal returns (uint relayerFee) {\n        if (_adapterParams.length == 0) {\n            _adapterParams = defaultAdapterParams[_dstChainId][_uaConfig.outboundProofType];\n        }\n        address relayerAddress = _uaConfig.relayer;\n        ILayerZeroRelayerV2 relayer = ILayerZeroRelayerV2(relayerAddress);\n        relayerFee = relayer.assignJob(_dstChainId, _uaConfig.outboundProofType, _ua, _payloadSize, _adapterParams);\n\n        // emit the param events\n        emit RelayerParams(_adapterParams, _uaConfig.outboundProofType);\n    }\n\n    function _handleOracle(\n        uint16 _dstChainId,\n        ApplicationConfiguration memory _uaConfig,\n        address _ua\n    ) internal returns (uint oracleFee) {\n        address oracleAddress = _uaConfig.oracle;\n        oracleFee = ILayerZeroOracleV2(oracleAddress).assignJob(\n            _dstChainId,\n            _uaConfig.outboundProofType,\n            _uaConfig.outboundBlockConfirmations,\n            _ua\n        );\n    }\n\n    function _handleProtocolFee(\n        uint _relayerFee,\n        uint _oracleFee,\n        address _ua,\n        address _zroPaymentAddress\n    ) internal returns (uint protocolNativeFee) {\n        // if no ZRO token or not specifying a payment address, pay in native token\n        bool payInNative = _zroPaymentAddress == address(0x0) || address(layerZeroToken) == address(0x0);\n        uint protocolFee = treasuryContract.getFees(!payInNative, _relayerFee, _oracleFee);\n\n        if (protocolFee > 0) {\n            if (payInNative) {\n                address treasuryAddress = address(treasuryContract);\n                protocolNativeFee = protocolFee;\n            } else {\n                // zro payment address must equal the ua or the tx.origin otherwise the transaction reverts\n                require(\n                    _zroPaymentAddress == _ua || _zroPaymentAddress == tx.origin,\n                    \"LayerZero: must be paid by sender or origin\"\n                );\n\n                // transfer the LayerZero token to this contract from the payee\n                layerZeroToken.safeTransferFrom(_zroPaymentAddress, address(this), protocolFee);\n\n                treasuryZROFees = treasuryZROFees.add(protocolFee);\n            }\n        }\n    }\n\n    // Can be called by any address to update a block header\n    // can only upload new block data or the same block data with more confirmations\n    function updateHash(\n        uint16 _srcChainId,\n        bytes32 _lookupHash,\n        uint _confirmations,\n        bytes32 _blockData\n    ) external override {\n        uint storedConfirmations = hashLookup[msg.sender][_srcChainId][_lookupHash][_blockData];\n\n        // if it has a record, requires a larger confirmation.\n        require(\n            storedConfirmations < _confirmations,\n            \"LayerZero: oracle data can only update if it has more confirmations\"\n        );\n\n        // set the new information into storage\n        hashLookup[msg.sender][_srcChainId][_lookupHash][_blockData] = _confirmations;\n\n        emit HashReceived(_srcChainId, msg.sender, _lookupHash, _blockData, _confirmations);\n    }\n\n    //----------------------------------------------------------------------------------\n    // Other Library Interfaces\n\n    // default to DEFAULT setting if ZERO value\n    function getAppConfig(\n        uint16 _remoteChainId,\n        address _ua\n    ) external view override returns (ApplicationConfiguration memory) {\n        return _getAppConfig(_remoteChainId, _ua);\n    }\n\n    function _getAppConfig(uint16 _remoteChainId, address _ua) internal view returns (ApplicationConfiguration memory) {\n        ApplicationConfiguration memory config = appConfig[_ua][_remoteChainId];\n        ApplicationConfiguration storage defaultConfig = defaultAppConfig[_remoteChainId];\n\n        if (config.inboundProofLibraryVersion == 0) {\n            config.inboundProofLibraryVersion = defaultConfig.inboundProofLibraryVersion;\n        }\n\n        if (config.inboundBlockConfirmations == 0) {\n            config.inboundBlockConfirmations = defaultConfig.inboundBlockConfirmations;\n        }\n\n        if (config.relayer == address(0x0)) {\n            config.relayer = defaultConfig.relayer;\n        }\n\n        if (config.outboundProofType == 0) {\n            config.outboundProofType = defaultConfig.outboundProofType;\n        }\n\n        if (config.outboundBlockConfirmations == 0) {\n            config.outboundBlockConfirmations = defaultConfig.outboundBlockConfirmations;\n        }\n\n        if (config.oracle == address(0x0)) {\n            config.oracle = defaultConfig.oracle;\n        }\n\n        return config;\n    }\n\n    function setConfig(\n        uint16 _remoteChainId,\n        address _ua,\n        uint _configType,\n        bytes calldata _config\n    ) external override onlyEndpoint {\n        ApplicationConfiguration storage uaConfig = appConfig[_ua][_remoteChainId];\n        if (_configType == CONFIG_TYPE_INBOUND_PROOF_LIBRARY_VERSION) {\n            uint16 inboundProofLibraryVersion = abi.decode(_config, (uint16));\n            require(\n                inboundProofLibraryVersion <= maxInboundProofLibrary[_remoteChainId],\n                \"LayerZero: invalid inbound proof library version\"\n            );\n            uaConfig.inboundProofLibraryVersion = inboundProofLibraryVersion;\n        } else if (_configType == CONFIG_TYPE_INBOUND_BLOCK_CONFIRMATIONS) {\n            uint64 blockConfirmations = abi.decode(_config, (uint64));\n            uaConfig.inboundBlockConfirmations = blockConfirmations;\n        } else if (_configType == CONFIG_TYPE_RELAYER) {\n            address relayer = abi.decode(_config, (address));\n            uaConfig.relayer = relayer;\n        } else if (_configType == CONFIG_TYPE_OUTBOUND_PROOF_TYPE) {\n            uint16 outboundProofType = abi.decode(_config, (uint16));\n            require(\n                supportedOutboundProof[_remoteChainId][outboundProofType] || outboundProofType == 0,\n                \"LayerZero: invalid outbound proof type\"\n            );\n            uaConfig.outboundProofType = outboundProofType;\n        } else if (_configType == CONFIG_TYPE_OUTBOUND_BLOCK_CONFIRMATIONS) {\n            uint64 blockConfirmations = abi.decode(_config, (uint64));\n            uaConfig.outboundBlockConfirmations = blockConfirmations;\n        } else if (_configType == CONFIG_TYPE_ORACLE) {\n            address oracle = abi.decode(_config, (address));\n            uaConfig.oracle = oracle;\n        } else {\n            revert(\"LayerZero: Invalid config type\");\n        }\n\n        emit AppConfigUpdated(_ua, _configType, _config);\n    }\n\n    function getConfig(\n        uint16 _remoteChainId,\n        address _ua,\n        uint _configType\n    ) external view override returns (bytes memory) {\n        ApplicationConfiguration storage uaConfig = appConfig[_ua][_remoteChainId];\n\n        if (_configType == CONFIG_TYPE_INBOUND_PROOF_LIBRARY_VERSION) {\n            if (uaConfig.inboundProofLibraryVersion == 0) {\n                return abi.encode(defaultAppConfig[_remoteChainId].inboundProofLibraryVersion);\n            }\n            return abi.encode(uaConfig.inboundProofLibraryVersion);\n        } else if (_configType == CONFIG_TYPE_INBOUND_BLOCK_CONFIRMATIONS) {\n            if (uaConfig.inboundBlockConfirmations == 0) {\n                return abi.encode(defaultAppConfig[_remoteChainId].inboundBlockConfirmations);\n            }\n            return abi.encode(uaConfig.inboundBlockConfirmations);\n        } else if (_configType == CONFIG_TYPE_RELAYER) {\n            if (uaConfig.relayer == address(0x0)) {\n                return abi.encode(defaultAppConfig[_remoteChainId].relayer);\n            }\n            return abi.encode(uaConfig.relayer);\n        } else if (_configType == CONFIG_TYPE_OUTBOUND_PROOF_TYPE) {\n            if (uaConfig.outboundProofType == 0) {\n                return abi.encode(defaultAppConfig[_remoteChainId].outboundProofType);\n            }\n            return abi.encode(uaConfig.outboundProofType);\n        } else if (_configType == CONFIG_TYPE_OUTBOUND_BLOCK_CONFIRMATIONS) {\n            if (uaConfig.outboundBlockConfirmations == 0) {\n                return abi.encode(defaultAppConfig[_remoteChainId].outboundBlockConfirmations);\n            }\n            return abi.encode(uaConfig.outboundBlockConfirmations);\n        } else if (_configType == CONFIG_TYPE_ORACLE) {\n            if (uaConfig.oracle == address(0x0)) {\n                return abi.encode(defaultAppConfig[_remoteChainId].oracle);\n            }\n            return abi.encode(uaConfig.oracle);\n        } else {\n            revert(\"LayerZero: Invalid config type\");\n        }\n    }\n\n    // returns the native fee the UA pays to cover fees\n    function estimateFees(\n        uint16 _dstChainId,\n        address _ua,\n        bytes calldata _payload,\n        bool _payInZRO,\n        bytes calldata _adapterParams\n    ) external view override returns (uint nativeFee, uint zroFee) {\n        ApplicationConfiguration memory uaConfig = _getAppConfig(_dstChainId, _ua);\n\n        // Relayer Fee\n        bytes memory adapterParams;\n        if (_adapterParams.length > 0) {\n            adapterParams = _adapterParams;\n        } else {\n            adapterParams = defaultAdapterParams[_dstChainId][uaConfig.outboundProofType];\n        }\n        uint relayerFee = ILayerZeroRelayerV2(uaConfig.relayer).getFee(\n            _dstChainId,\n            uaConfig.outboundProofType,\n            _ua,\n            _payload.length,\n            adapterParams\n        );\n\n        // Oracle Fee\n        address ua = _ua; // stack too deep\n        uint oracleFee = ILayerZeroOracleV2(uaConfig.oracle).getFee(\n            _dstChainId,\n            uaConfig.outboundProofType,\n            uaConfig.outboundBlockConfirmations,\n            ua\n        );\n\n        // LayerZero Fee\n        uint protocolFee = treasuryContract.getFees(_payInZRO, relayerFee, oracleFee);\n        _payInZRO ? zroFee = protocolFee : nativeFee = protocolFee;\n\n        // return the sum of fees\n        nativeFee = nativeFee.add(relayerFee).add(oracleFee);\n    }\n\n    //---------------------------------------------------------------------------\n    // Claim Fees\n\n    // universal withdraw ZRO token function\n    function withdrawZRO(address _to, uint _amount) external override nonReentrant {\n        require(msg.sender == address(treasuryContract), \"LayerZero: only treasury\");\n        treasuryZROFees = treasuryZROFees.sub(_amount);\n        layerZeroToken.safeTransfer(_to, _amount);\n        emit WithdrawZRO(msg.sender, _to, _amount);\n    }\n\n    // universal withdraw native token function.\n    // the source contract should perform all the authentication control\n    function withdrawNative(address payable _to, uint _amount) external override nonReentrant {\n        require(_to != address(0x0), \"LayerZero: _to cannot be zero address\");\n        nativeFees[msg.sender] = nativeFees[msg.sender].sub(_amount);\n\n        (bool success, ) = _to.call{value: _amount}(\"\");\n        require(success, \"LayerZero: withdraw failed\");\n        emit WithdrawNative(msg.sender, _to, _amount);\n    }\n\n    //---------------------------------------------------------------------------\n    // Owner calls, configuration only.\n    function setLayerZeroToken(address _layerZeroToken) external onlyOwner {\n        require(_layerZeroToken != address(0x0), \"LayerZero: _layerZeroToken cannot be zero address\");\n        layerZeroToken = IERC20(_layerZeroToken);\n        emit SetLayerZeroToken(_layerZeroToken);\n    }\n\n    function setTreasury(address _treasury) external onlyOwner {\n        require(_treasury != address(0x0), \"LayerZero: treasury cannot be zero address\");\n        treasuryContract = ILayerZeroTreasury(_treasury);\n        emit SetTreasury(_treasury);\n    }\n\n    function addInboundProofLibraryForChain(uint16 _chainId, address _library) external onlyOwner {\n        require(_library != address(0x0), \"LayerZero: library cannot be zero address\");\n        uint16 libId = maxInboundProofLibrary[_chainId];\n        require(libId < 65535, \"LayerZero: can not add new library\");\n        maxInboundProofLibrary[_chainId] = ++libId;\n        inboundProofLibrary[_chainId][libId] = _library;\n        emit AddInboundProofLibraryForChain(_chainId, _library);\n    }\n\n    function enableSupportedOutboundProof(uint16 _chainId, uint16 _proofType) external onlyOwner {\n        supportedOutboundProof[_chainId][_proofType] = true;\n        emit EnableSupportedOutboundProof(_chainId, _proofType);\n    }\n\n    function setDefaultConfigForChainId(\n        uint16 _chainId,\n        uint16 _inboundProofLibraryVersion,\n        uint64 _inboundBlockConfirmations,\n        address _relayer,\n        uint16 _outboundProofType,\n        uint64 _outboundBlockConfirmations,\n        address _oracle\n    ) external onlyOwner {\n        require(\n            _inboundProofLibraryVersion <= maxInboundProofLibrary[_chainId] && _inboundProofLibraryVersion > 0,\n            \"LayerZero: invalid inbound proof library version\"\n        );\n        require(_inboundBlockConfirmations > 0, \"LayerZero: invalid inbound block confirmation\");\n        require(_relayer != address(0x0), \"LayerZero: invalid relayer address\");\n        require(supportedOutboundProof[_chainId][_outboundProofType], \"LayerZero: invalid outbound proof type\");\n        require(_outboundBlockConfirmations > 0, \"LayerZero: invalid outbound block confirmation\");\n        require(_oracle != address(0x0), \"LayerZero: invalid oracle address\");\n        defaultAppConfig[_chainId] = ApplicationConfiguration(\n            _inboundProofLibraryVersion,\n            _inboundBlockConfirmations,\n            _relayer,\n            _outboundProofType,\n            _outboundBlockConfirmations,\n            _oracle\n        );\n        emit SetDefaultConfigForChainId(\n            _chainId,\n            _inboundProofLibraryVersion,\n            _inboundBlockConfirmations,\n            _relayer,\n            _outboundProofType,\n            _outboundBlockConfirmations,\n            _oracle\n        );\n    }\n\n    function setDefaultAdapterParamsForChainId(\n        uint16 _chainId,\n        uint16 _proofType,\n        bytes calldata _adapterParams\n    ) external onlyOwner {\n        defaultAdapterParams[_chainId][_proofType] = _adapterParams;\n        emit SetDefaultAdapterParamsForChainId(_chainId, _proofType, _adapterParams);\n    }\n\n    function setRemoteUln(uint16 _remoteChainId, bytes32 _remoteUln) external onlyOwner {\n        require(ulnLookup[_remoteChainId] == bytes32(0), \"LayerZero: remote uln already set\");\n        ulnLookup[_remoteChainId] = _remoteUln;\n        emit SetRemoteUln(_remoteChainId, _remoteUln);\n    }\n\n    function setChainAddressSize(uint16 _chainId, uint _size) external onlyOwner {\n        require(chainAddressSizeMap[_chainId] == 0, \"LayerZero: remote chain address size already set\");\n        chainAddressSizeMap[_chainId] = _size;\n        emit SetChainAddressSize(_chainId, _size);\n    }\n\n    //----------------------------------------------------------------------------------\n    // view functions\n\n    function accruedNativeFee(address _address) external view override returns (uint) {\n        return nativeFees[_address];\n    }\n\n    function getOutboundNonce(uint16 _chainId, bytes calldata _path) external view override returns (uint64) {\n        return nonceContract.outboundNonce(_chainId, _path);\n    }\n\n    function _isContract(address addr) internal view returns (bool) {\n        uint size;\n        assembly {\n            size := extcodesize(addr)\n        }\n        return size != 0;\n    }\n}\n"
    },
    "contracts/V1Contracts/contracts/UltraLightNodeV2Radar.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";import \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"./interfaces/ILayerZeroValidationLibrary.sol\";\nimport \"./interfaces/ILayerZeroReceiver.sol\";\nimport \"./interfaces/ILayerZeroTreasury.sol\";\nimport \"./interfaces/ILayerZeroEndpoint.sol\";\n// v2\nimport \"./interfaces/ILayerZeroMessagingLibraryV2.sol\";\nimport \"./interfaces/ILayerZeroOracleV2.sol\";\nimport \"./interfaces/ILayerZeroUltraLightNodeV2.sol\";\nimport \"./interfaces/ILayerZeroRelayerV2.sol\";\nimport \"./NonceContractRadar.sol\";\n\ncontract UltraLightNodeV2Radar is ILayerZeroMessagingLibraryV2, ILayerZeroUltraLightNodeV2, ReentrancyGuard, Ownable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint;\n\n    // Application config\n    uint public constant CONFIG_TYPE_INBOUND_PROOF_LIBRARY_VERSION = 1;\n    uint public constant CONFIG_TYPE_INBOUND_BLOCK_CONFIRMATIONS = 2;\n    uint public constant CONFIG_TYPE_RELAYER = 3;\n    uint public constant CONFIG_TYPE_OUTBOUND_PROOF_TYPE = 4;\n    uint public constant CONFIG_TYPE_OUTBOUND_BLOCK_CONFIRMATIONS = 5;\n    uint public constant CONFIG_TYPE_ORACLE = 6;\n\n    // Token and Contracts\n    IERC20 public layerZeroToken;\n    ILayerZeroTreasury public treasuryContract;\n\n    mapping(address => uint) public nativeFees;\n    uint public treasuryZROFees;\n\n    // User Application\n    mapping(address => mapping(uint16 => ApplicationConfiguration)) public appConfig; // app address => chainId => config\n    mapping(uint16 => ApplicationConfiguration) public defaultAppConfig; // default UA settings if no version specified\n    mapping(uint16 => mapping(uint16 => bytes)) public defaultAdapterParams;\n\n    // Validation\n    mapping(uint16 => mapping(uint16 => address)) public inboundProofLibrary; // chainId => library Id => inboundProofLibrary contract\n    mapping(uint16 => uint16) public maxInboundProofLibrary; // chainId => inboundProofLibrary\n    mapping(uint16 => mapping(uint16 => bool)) public supportedOutboundProof; // chainId => outboundProofType => enabled\n    mapping(uint16 => uint) public chainAddressSizeMap;\n    mapping(address => mapping(uint16 => mapping(bytes32 => mapping(bytes32 => uint)))) public hashLookup; //[oracle][srcChainId][blockhash][datahash] -> confirmation\n    mapping(uint16 => bytes32) public ulnLookup; // remote ulns\n\n    ILayerZeroEndpoint public immutable endpoint;\n    uint16 public immutable localChainId;\n    NonceContractRadar public immutable nonceContract;\n\n    constructor(address _endpoint, address _nonceContract, uint16 _localChainId, address _dappRadar) {\n        require(_endpoint != address(0x0), \"LayerZero: endpoint cannot be zero address\");\n        require(_nonceContract != address(0x0), \"LayerZero: nonceContract cannot be zero address\");\n        ILayerZeroEndpoint lzEndpoint = ILayerZeroEndpoint(_endpoint);\n        localChainId = _localChainId;\n        endpoint = lzEndpoint;\n        nonceContract = NonceContractRadar(_nonceContract);\n\n        // dappRadar\n        dappRadar = _dappRadar;\n    }\n\n    // only the endpoint can call SEND() and setConfig()\n    modifier onlyEndpoint() {\n        require(address(endpoint) == msg.sender, \"LayerZero: only endpoint\");\n        _;\n    }\n\n    // Manual for DappRadar handling. This contract is dappRadar-only (send/receive)\n    // 1. Layerzero deploys UltraLightNodeV2Radar and NonceContractRadar using old chain ID with the local dappRadar address in constructor\n    // 2. Dapp Radar sets the messaging library to UltraLightNodeV2Radar\n    // 3. Dapp Radar sets the trustedRemote to the full path\n    // 4. Layerzero initializes the outboundNonce (1 call) and inboundNonce (batch call)\n    // 5. Test message flows\n    //\n    // 6. after an agree-upon period of time, decommission this contract (one-way trip).\n\n    //\n    // DappRadar constructs\n    //\n    address public immutable dappRadar;\n    bool public decommissioned;\n    mapping(uint16 => bool) public outboundNonceSet;\n    mapping(address => uint64) public inboundNonceCap;\n\n    // only dappRadar\n    function initRadarOutboundNonce(uint16 _dstChainId, address _dstRadarAddress) external onlyOwner {\n        // can only inherit the outbound nonce from previous path once\n        // assuming dappRadar has only 1 remote peer at a destination chain.\n        require(!outboundNonceSet[_dstChainId], \"LayerZero: dappRadar nonce already set\");\n        uint64 inheritedNonce = endpoint.getOutboundNonce(_dstChainId, dappRadar);\n        outboundNonceSet[_dstChainId] = true;\n\n        // can only set the path owned by the dappRadar\n        // dappRadar is only deployed on EVM chains so the address is 20 bytes for all\n        bytes memory radarPath = abi.encodePacked(_dstRadarAddress, dappRadar); //// remote + local\n\n        // insert into the nonce contract\n        nonceContract.initRadarOutboundNonce(_dstChainId, radarPath, inheritedNonce);\n    }\n\n    // generate a message from the new dappRadar-owned path with now payload\n    // dappRadar needs to first change the trustedRemote\n    // messages will fail locally in the nonBlockingLzApp from the nonce checking\n    // can only increment the nonce till we hit the legacy nonce\n    function incrementRadarInboundNonce(\n        uint16 _srcChainId,\n        address _srcRadarAddress,\n        uint _gasLimitPerCall,\n        uint _steps\n    ) external onlyOwner {\n        // initialize the inboundNonceCap, only once\n        if (inboundNonceCap[_srcRadarAddress] == 0) {\n            // check if the _srcRadarAddress is a legacy address by checking the nonce\n            uint64 inheritNonce = endpoint.getInboundNonce(_srcChainId, abi.encodePacked(_srcRadarAddress));\n            require(inheritNonce > 0, \"LayerZero: not legacy radar address\");\n\n            inboundNonceCap[_srcRadarAddress] = inheritNonce;\n        }\n\n        // can only set the path owned by the dappRadar\n        // dappRadar is only deployed on EVM chains so the address is 20 bytes for all\n        bytes memory radarPath = abi.encodePacked(_srcRadarAddress, dappRadar); // remote + local\n        uint64 radarPathNonce = endpoint.getInboundNonce(_srcChainId, radarPath);\n        uint64 nonceCap = inboundNonceCap[_srcRadarAddress];\n\n        for (uint i = 0; i < _steps; i++) {\n            // ensure that the nonce of the new path is not already at the cap\n            radarPathNonce++;\n            if (radarPathNonce > nonceCap) {\n                break;\n            }\n            // receive the message with null Payload\n            endpoint.receivePayload(_srcChainId, radarPath, dappRadar, radarPathNonce, _gasLimitPerCall, bytes(\"\"));\n        }\n    }\n\n    // this contract will only serve for a period of time\n    function decommission() external onlyOwner {\n        decommissioned = true;\n    }\n\n    //----------------------------------------------------------------------------------\n    // PROTOCOL\n    function validateTransactionProof(\n        uint16 _srcChainId,\n        address _dstAddress,\n        uint _gasLimit,\n        bytes32 _lookupHash,\n        bytes32 _blockData,\n        bytes calldata _transactionProof\n    ) external override {\n        require(_dstAddress == dappRadar, \"LayerZero: only dappRadar\");\n        require(!decommissioned, \"LayerZero: decommissioned\");\n\n        // retrieve UA's configuration using the _dstAddress from arguments.\n        ApplicationConfiguration memory uaConfig = _getAppConfig(_srcChainId, _dstAddress);\n\n        // assert that the caller == UA's relayer\n        require(uaConfig.relayer == msg.sender, \"LayerZero: invalid relayer\");\n\n        LayerZeroPacket.Packet memory _packet;\n        uint remoteAddressSize = chainAddressSizeMap[_srcChainId];\n        require(remoteAddressSize != 0, \"LayerZero: incorrect remote address size\");\n        {\n            // assert that the data submitted by UA's oracle have no fewer confirmations than UA's configuration\n            uint storedConfirmations = hashLookup[uaConfig.oracle][_srcChainId][_lookupHash][_blockData];\n            require(\n                storedConfirmations > 0 && storedConfirmations >= uaConfig.inboundBlockConfirmations,\n                \"LayerZero: not enough block confirmations\"\n            );\n\n            // decode\n            address inboundProofLib = inboundProofLibrary[_srcChainId][uaConfig.inboundProofLibraryVersion];\n            _packet = ILayerZeroValidationLibrary(inboundProofLib).validateProof(\n                _blockData,\n                _transactionProof,\n                remoteAddressSize\n            );\n        }\n\n        // packet content assertion\n        require(\n            ulnLookup[_srcChainId] == _packet.ulnAddress && _packet.ulnAddress != bytes32(0),\n            \"LayerZero: invalid _packet.ulnAddress\"\n        );\n        require(_packet.srcChainId == _srcChainId, \"LayerZero: invalid srcChain Id\");\n        // failsafe because the remoteAddress size being passed into validateProof trims the address this should not hit\n        require(_packet.srcAddress.length == remoteAddressSize, \"LayerZero: invalid srcAddress size\");\n        require(_packet.dstChainId == localChainId, \"LayerZero: invalid dstChain Id\");\n        require(_packet.dstAddress == _dstAddress, \"LayerZero: invalid dstAddress\");\n\n        // if the dst is not a contract, then emit and return early. This will break inbound nonces, but this particular\n        // path is already broken and wont ever be able to deliver anyways\n        if (!_isContract(_dstAddress)) {\n            emit InvalidDst(\n                _packet.srcChainId,\n                _packet.srcAddress,\n                _packet.dstAddress,\n                _packet.nonce,\n                keccak256(_packet.payload)\n            );\n            return;\n        }\n\n        bytes memory pathData = abi.encodePacked(_packet.srcAddress, _packet.dstAddress);\n        emit PacketReceived(\n            _packet.srcChainId,\n            _packet.srcAddress,\n            _packet.dstAddress,\n            _packet.nonce,\n            keccak256(_packet.payload)\n        );\n        endpoint.receivePayload(_srcChainId, pathData, _dstAddress, _packet.nonce, _gasLimit, _packet.payload);\n    }\n\n    function send(\n        address _ua,\n        uint64,\n        uint16 _dstChainId,\n        bytes calldata _path,\n        bytes calldata _payload,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes calldata _adapterParams\n    ) external payable override onlyEndpoint {\n        require(_ua == dappRadar, \"LayerZero: only dappRadar\");\n        require(!decommissioned, \"LayerZero: decommissioned\");\n\n        address ua = _ua;\n        uint16 dstChainId = _dstChainId;\n        require(ulnLookup[dstChainId] != bytes32(0), \"LayerZero: dstChainId does not exist\");\n\n        bytes memory dstAddress;\n        uint64 nonce;\n        // code block for solving 'Stack Too Deep'\n        {\n            uint chainAddressSize = chainAddressSizeMap[dstChainId];\n            // path = remoteAddress + localAddress\n            require(\n                chainAddressSize != 0 && _path.length == 20 + chainAddressSize,\n                \"LayerZero: incorrect remote address size\"\n            );\n            address srcInPath;\n            bytes memory path = _path; // copy to memory\n            assembly {\n                srcInPath := mload(add(add(path, 20), chainAddressSize)) // chainAddressSize + 20\n            }\n            require(ua == srcInPath, \"LayerZero: wrong path data\");\n            dstAddress = _path[0:chainAddressSize];\n            nonce = nonceContract.increment(dstChainId, ua, path);\n        }\n\n        bytes memory payload = _payload;\n        ApplicationConfiguration memory uaConfig = _getAppConfig(dstChainId, ua);\n\n        // compute all the fees\n        uint relayerFee = _handleRelayer(dstChainId, uaConfig, ua, payload.length, _adapterParams);\n        uint oracleFee = _handleOracle(dstChainId, uaConfig, ua);\n        uint nativeProtocolFee = _handleProtocolFee(relayerFee, oracleFee, ua, _zroPaymentAddress);\n\n        // total native fee, does not include ZRO protocol fee\n        uint totalNativeFee = relayerFee.add(oracleFee).add(nativeProtocolFee);\n\n        // assert the user has attached enough native token for this address\n        require(totalNativeFee <= msg.value, \"LayerZero: not enough native for fees\");\n        // refund if they send too much\n        uint amount = msg.value.sub(totalNativeFee);\n        if (amount > 0) {\n            (bool success, ) = _refundAddress.call{value: amount}(\"\");\n            require(success, \"LayerZero: failed to refund\");\n        }\n\n        // emit the data packet\n        bytes memory encodedPayload = abi.encodePacked(nonce, localChainId, ua, dstChainId, dstAddress, payload);\n        emit Packet(encodedPayload);\n    }\n\n    function _handleRelayer(\n        uint16 _dstChainId,\n        ApplicationConfiguration memory _uaConfig,\n        address _ua,\n        uint _payloadSize,\n        bytes memory _adapterParams\n    ) internal returns (uint relayerFee) {\n        if (_adapterParams.length == 0) {\n            _adapterParams = defaultAdapterParams[_dstChainId][_uaConfig.outboundProofType];\n        }\n        address relayerAddress = _uaConfig.relayer;\n        ILayerZeroRelayerV2 relayer = ILayerZeroRelayerV2(relayerAddress);\n        relayerFee = relayer.assignJob(_dstChainId, _uaConfig.outboundProofType, _ua, _payloadSize, _adapterParams);\n\n        _creditNativeFee(relayerAddress, relayerFee);\n\n        // emit the param events\n        emit RelayerParams(_adapterParams, _uaConfig.outboundProofType);\n    }\n\n    function _handleOracle(\n        uint16 _dstChainId,\n        ApplicationConfiguration memory _uaConfig,\n        address _ua\n    ) internal returns (uint oracleFee) {\n        address oracleAddress = _uaConfig.oracle;\n        oracleFee = ILayerZeroOracleV2(oracleAddress).assignJob(\n            _dstChainId,\n            _uaConfig.outboundProofType,\n            _uaConfig.outboundBlockConfirmations,\n            _ua\n        );\n\n        _creditNativeFee(oracleAddress, oracleFee);\n    }\n\n    function _handleProtocolFee(\n        uint _relayerFee,\n        uint _oracleFee,\n        address _ua,\n        address _zroPaymentAddress\n    ) internal returns (uint protocolNativeFee) {\n        // if no ZRO token or not specifying a payment address, pay in native token\n        bool payInNative = _zroPaymentAddress == address(0x0) || address(layerZeroToken) == address(0x0);\n        uint protocolFee = treasuryContract.getFees(!payInNative, _relayerFee, _oracleFee);\n\n        if (protocolFee > 0) {\n            if (payInNative) {\n                address treasuryAddress = address(treasuryContract);\n                _creditNativeFee(treasuryAddress, protocolFee);\n                protocolNativeFee = protocolFee;\n            } else {\n                // zro payment address must equal the ua or the tx.origin otherwise the transaction reverts\n                require(\n                    _zroPaymentAddress == _ua || _zroPaymentAddress == tx.origin,\n                    \"LayerZero: must be paid by sender or origin\"\n                );\n\n                // transfer the LayerZero token to this contract from the payee\n                layerZeroToken.safeTransferFrom(_zroPaymentAddress, address(this), protocolFee);\n\n                treasuryZROFees = treasuryZROFees.add(protocolFee);\n            }\n        }\n    }\n\n    function _creditNativeFee(address _receiver, uint _amount) internal {\n        nativeFees[_receiver] = nativeFees[_receiver].add(_amount);\n    }\n\n    // Can be called by any address to update a block header\n    // can only upload new block data or the same block data with more confirmations\n    function updateHash(\n        uint16 _srcChainId,\n        bytes32 _lookupHash,\n        uint _confirmations,\n        bytes32 _blockData\n    ) external override {\n        uint storedConfirmations = hashLookup[msg.sender][_srcChainId][_lookupHash][_blockData];\n\n        // if it has a record, requires a larger confirmation.\n        require(\n            storedConfirmations < _confirmations,\n            \"LayerZero: oracle data can only update if it has more confirmations\"\n        );\n\n        // set the new information into storage\n        hashLookup[msg.sender][_srcChainId][_lookupHash][_blockData] = _confirmations;\n\n        emit HashReceived(_srcChainId, msg.sender, _lookupHash, _blockData, _confirmations);\n    }\n\n    //----------------------------------------------------------------------------------\n    // Other Library Interfaces\n\n    // default to DEFAULT setting if ZERO value\n    function getAppConfig(\n        uint16 _remoteChainId,\n        address _ua\n    ) external view override returns (ApplicationConfiguration memory) {\n        return _getAppConfig(_remoteChainId, _ua);\n    }\n\n    function _getAppConfig(uint16 _remoteChainId, address _ua) internal view returns (ApplicationConfiguration memory) {\n        ApplicationConfiguration memory config = appConfig[_ua][_remoteChainId];\n        ApplicationConfiguration storage defaultConfig = defaultAppConfig[_remoteChainId];\n\n        if (config.inboundProofLibraryVersion == 0) {\n            config.inboundProofLibraryVersion = defaultConfig.inboundProofLibraryVersion;\n        }\n\n        if (config.inboundBlockConfirmations == 0) {\n            config.inboundBlockConfirmations = defaultConfig.inboundBlockConfirmations;\n        }\n\n        if (config.relayer == address(0x0)) {\n            config.relayer = defaultConfig.relayer;\n        }\n\n        if (config.outboundProofType == 0) {\n            config.outboundProofType = defaultConfig.outboundProofType;\n        }\n\n        if (config.outboundBlockConfirmations == 0) {\n            config.outboundBlockConfirmations = defaultConfig.outboundBlockConfirmations;\n        }\n\n        if (config.oracle == address(0x0)) {\n            config.oracle = defaultConfig.oracle;\n        }\n\n        return config;\n    }\n\n    function setConfig(\n        uint16 _remoteChainId,\n        address _ua,\n        uint _configType,\n        bytes calldata _config\n    ) external override onlyEndpoint {\n        ApplicationConfiguration storage uaConfig = appConfig[_ua][_remoteChainId];\n        if (_configType == CONFIG_TYPE_INBOUND_PROOF_LIBRARY_VERSION) {\n            uint16 inboundProofLibraryVersion = abi.decode(_config, (uint16));\n            require(\n                inboundProofLibraryVersion <= maxInboundProofLibrary[_remoteChainId],\n                \"LayerZero: invalid inbound proof library version\"\n            );\n            uaConfig.inboundProofLibraryVersion = inboundProofLibraryVersion;\n        } else if (_configType == CONFIG_TYPE_INBOUND_BLOCK_CONFIRMATIONS) {\n            uint64 blockConfirmations = abi.decode(_config, (uint64));\n            uaConfig.inboundBlockConfirmations = blockConfirmations;\n        } else if (_configType == CONFIG_TYPE_RELAYER) {\n            address relayer = abi.decode(_config, (address));\n            uaConfig.relayer = relayer;\n        } else if (_configType == CONFIG_TYPE_OUTBOUND_PROOF_TYPE) {\n            uint16 outboundProofType = abi.decode(_config, (uint16));\n            require(\n                supportedOutboundProof[_remoteChainId][outboundProofType] || outboundProofType == 0,\n                \"LayerZero: invalid outbound proof type\"\n            );\n            uaConfig.outboundProofType = outboundProofType;\n        } else if (_configType == CONFIG_TYPE_OUTBOUND_BLOCK_CONFIRMATIONS) {\n            uint64 blockConfirmations = abi.decode(_config, (uint64));\n            uaConfig.outboundBlockConfirmations = blockConfirmations;\n        } else if (_configType == CONFIG_TYPE_ORACLE) {\n            address oracle = abi.decode(_config, (address));\n            uaConfig.oracle = oracle;\n        } else {\n            revert(\"LayerZero: Invalid config type\");\n        }\n\n        emit AppConfigUpdated(_ua, _configType, _config);\n    }\n\n    function getConfig(\n        uint16 _remoteChainId,\n        address _ua,\n        uint _configType\n    ) external view override returns (bytes memory) {\n        ApplicationConfiguration storage uaConfig = appConfig[_ua][_remoteChainId];\n\n        if (_configType == CONFIG_TYPE_INBOUND_PROOF_LIBRARY_VERSION) {\n            if (uaConfig.inboundProofLibraryVersion == 0) {\n                return abi.encode(defaultAppConfig[_remoteChainId].inboundProofLibraryVersion);\n            }\n            return abi.encode(uaConfig.inboundProofLibraryVersion);\n        } else if (_configType == CONFIG_TYPE_INBOUND_BLOCK_CONFIRMATIONS) {\n            if (uaConfig.inboundBlockConfirmations == 0) {\n                return abi.encode(defaultAppConfig[_remoteChainId].inboundBlockConfirmations);\n            }\n            return abi.encode(uaConfig.inboundBlockConfirmations);\n        } else if (_configType == CONFIG_TYPE_RELAYER) {\n            if (uaConfig.relayer == address(0x0)) {\n                return abi.encode(defaultAppConfig[_remoteChainId].relayer);\n            }\n            return abi.encode(uaConfig.relayer);\n        } else if (_configType == CONFIG_TYPE_OUTBOUND_PROOF_TYPE) {\n            if (uaConfig.outboundProofType == 0) {\n                return abi.encode(defaultAppConfig[_remoteChainId].outboundProofType);\n            }\n            return abi.encode(uaConfig.outboundProofType);\n        } else if (_configType == CONFIG_TYPE_OUTBOUND_BLOCK_CONFIRMATIONS) {\n            if (uaConfig.outboundBlockConfirmations == 0) {\n                return abi.encode(defaultAppConfig[_remoteChainId].outboundBlockConfirmations);\n            }\n            return abi.encode(uaConfig.outboundBlockConfirmations);\n        } else if (_configType == CONFIG_TYPE_ORACLE) {\n            if (uaConfig.oracle == address(0x0)) {\n                return abi.encode(defaultAppConfig[_remoteChainId].oracle);\n            }\n            return abi.encode(uaConfig.oracle);\n        } else {\n            revert(\"LayerZero: Invalid config type\");\n        }\n    }\n\n    // returns the native fee the UA pays to cover fees\n    function estimateFees(\n        uint16 _dstChainId,\n        address _ua,\n        bytes calldata _payload,\n        bool _payInZRO,\n        bytes calldata _adapterParams\n    ) external view override returns (uint nativeFee, uint zroFee) {\n        ApplicationConfiguration memory uaConfig = _getAppConfig(_dstChainId, _ua);\n\n        // Relayer Fee\n        bytes memory adapterParams;\n        if (_adapterParams.length > 0) {\n            adapterParams = _adapterParams;\n        } else {\n            adapterParams = defaultAdapterParams[_dstChainId][uaConfig.outboundProofType];\n        }\n        uint relayerFee = ILayerZeroRelayerV2(uaConfig.relayer).getFee(\n            _dstChainId,\n            uaConfig.outboundProofType,\n            _ua,\n            _payload.length,\n            adapterParams\n        );\n\n        // Oracle Fee\n        address ua = _ua; // stack too deep\n        uint oracleFee = ILayerZeroOracleV2(uaConfig.oracle).getFee(\n            _dstChainId,\n            uaConfig.outboundProofType,\n            uaConfig.outboundBlockConfirmations,\n            ua\n        );\n\n        // LayerZero Fee\n        uint protocolFee = treasuryContract.getFees(_payInZRO, relayerFee, oracleFee);\n        _payInZRO ? zroFee = protocolFee : nativeFee = protocolFee;\n\n        // return the sum of fees\n        nativeFee = nativeFee.add(relayerFee).add(oracleFee);\n    }\n\n    //---------------------------------------------------------------------------\n    // Claim Fees\n\n    // universal withdraw ZRO token function\n    function withdrawZRO(address _to, uint _amount) external override nonReentrant {\n        require(msg.sender == address(treasuryContract), \"LayerZero: only treasury\");\n        treasuryZROFees = treasuryZROFees.sub(_amount);\n        layerZeroToken.safeTransfer(_to, _amount);\n        emit WithdrawZRO(msg.sender, _to, _amount);\n    }\n\n    // universal withdraw native token function.\n    // the source contract should perform all the authentication control\n    function withdrawNative(address payable _to, uint _amount) external override nonReentrant {\n        require(_to != address(0x0), \"LayerZero: _to cannot be zero address\");\n        nativeFees[msg.sender] = nativeFees[msg.sender].sub(_amount);\n\n        (bool success, ) = _to.call{value: _amount}(\"\");\n        require(success, \"LayerZero: withdraw failed\");\n        emit WithdrawNative(msg.sender, _to, _amount);\n    }\n\n    //---------------------------------------------------------------------------\n    // Owner calls, configuration only.\n    function setLayerZeroToken(address _layerZeroToken) external onlyOwner {\n        require(_layerZeroToken != address(0x0), \"LayerZero: _layerZeroToken cannot be zero address\");\n        layerZeroToken = IERC20(_layerZeroToken);\n        emit SetLayerZeroToken(_layerZeroToken);\n    }\n\n    function setTreasury(address _treasury) external onlyOwner {\n        require(_treasury != address(0x0), \"LayerZero: treasury cannot be zero address\");\n        treasuryContract = ILayerZeroTreasury(_treasury);\n        emit SetTreasury(_treasury);\n    }\n\n    function addInboundProofLibraryForChain(uint16 _chainId, address _library) external onlyOwner {\n        require(_library != address(0x0), \"LayerZero: library cannot be zero address\");\n        uint16 libId = maxInboundProofLibrary[_chainId];\n        require(libId < 65535, \"LayerZero: can not add new library\");\n        maxInboundProofLibrary[_chainId] = ++libId;\n        inboundProofLibrary[_chainId][libId] = _library;\n        emit AddInboundProofLibraryForChain(_chainId, _library);\n    }\n\n    function enableSupportedOutboundProof(uint16 _chainId, uint16 _proofType) external onlyOwner {\n        supportedOutboundProof[_chainId][_proofType] = true;\n        emit EnableSupportedOutboundProof(_chainId, _proofType);\n    }\n\n    function setDefaultConfigForChainId(\n        uint16 _chainId,\n        uint16 _inboundProofLibraryVersion,\n        uint64 _inboundBlockConfirmations,\n        address _relayer,\n        uint16 _outboundProofType,\n        uint64 _outboundBlockConfirmations,\n        address _oracle\n    ) external onlyOwner {\n        require(\n            _inboundProofLibraryVersion <= maxInboundProofLibrary[_chainId] && _inboundProofLibraryVersion > 0,\n            \"LayerZero: invalid inbound proof library version\"\n        );\n        require(_inboundBlockConfirmations > 0, \"LayerZero: invalid inbound block confirmation\");\n        require(_relayer != address(0x0), \"LayerZero: invalid relayer address\");\n        require(supportedOutboundProof[_chainId][_outboundProofType], \"LayerZero: invalid outbound proof type\");\n        require(_outboundBlockConfirmations > 0, \"LayerZero: invalid outbound block confirmation\");\n        require(_oracle != address(0x0), \"LayerZero: invalid oracle address\");\n        defaultAppConfig[_chainId] = ApplicationConfiguration(\n            _inboundProofLibraryVersion,\n            _inboundBlockConfirmations,\n            _relayer,\n            _outboundProofType,\n            _outboundBlockConfirmations,\n            _oracle\n        );\n        emit SetDefaultConfigForChainId(\n            _chainId,\n            _inboundProofLibraryVersion,\n            _inboundBlockConfirmations,\n            _relayer,\n            _outboundProofType,\n            _outboundBlockConfirmations,\n            _oracle\n        );\n    }\n\n    function setDefaultAdapterParamsForChainId(\n        uint16 _chainId,\n        uint16 _proofType,\n        bytes calldata _adapterParams\n    ) external onlyOwner {\n        defaultAdapterParams[_chainId][_proofType] = _adapterParams;\n        emit SetDefaultAdapterParamsForChainId(_chainId, _proofType, _adapterParams);\n    }\n\n    function setRemoteUln(uint16 _remoteChainId, bytes32 _remoteUln) external onlyOwner {\n        require(ulnLookup[_remoteChainId] == bytes32(0), \"LayerZero: remote uln already set\");\n        ulnLookup[_remoteChainId] = _remoteUln;\n        emit SetRemoteUln(_remoteChainId, _remoteUln);\n    }\n\n    function setChainAddressSize(uint16 _chainId, uint _size) external onlyOwner {\n        require(chainAddressSizeMap[_chainId] == 0, \"LayerZero: remote chain address size already set\");\n        chainAddressSizeMap[_chainId] = _size;\n        emit SetChainAddressSize(_chainId, _size);\n    }\n\n    //----------------------------------------------------------------------------------\n    // view functions\n\n    function accruedNativeFee(address _address) external view override returns (uint) {\n        return nativeFees[_address];\n    }\n\n    function getOutboundNonce(uint16 _chainId, bytes calldata _path) external view override returns (uint64) {\n        return nonceContract.outboundNonce(_chainId, _path);\n    }\n\n    function _isContract(address addr) internal view returns (bool) {\n        uint size;\n        assembly {\n            size := extcodesize(addr)\n        }\n        return size != 0;\n    }\n}\n"
    },
    "contracts/V1Contracts/contracts/utility/Buffer.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n// https://github.com/ensdomains/buffer\n\npragma solidity ^0.7.0;\n\n/**\n * @dev A library for working with mutable byte buffers in Solidity.\n *\n * Byte buffers are mutable and expandable, and provide a variety of primitives\n * for writing to them. At any time you can fetch a bytes object containing the\n * current contents of the buffer. The bytes object should not be stored between\n * operations, as it may change due to resizing of the buffer.\n */\nlibrary Buffer {\n    /**\n     * @dev Represents a mutable buffer. Buffers have a current value (buf) and\n     *      a capacity. The capacity may be longer than the current value, in\n     *      which case it can be extended without the need to allocate more memory.\n     */\n    struct buffer {\n        bytes buf;\n        uint capacity;\n    }\n\n    /**\n     * @dev Initializes a buffer with an initial capacity.a co\n     * @param buf The buffer to initialize.\n     * @param capacity The number of bytes of space to allocate the buffer.\n     * @return The buffer, for chaining.\n     */\n    function init(buffer memory buf, uint capacity) internal pure returns (buffer memory) {\n        if (capacity % 32 != 0) {\n            capacity += 32 - (capacity % 32);\n        }\n        // Allocate space for the buffer data\n        buf.capacity = capacity;\n        assembly {\n            let ptr := mload(0x40)\n            mstore(buf, ptr)\n            mstore(ptr, 0)\n            mstore(0x40, add(32, add(ptr, capacity)))\n        }\n        return buf;\n    }\n\n    /**\n     * @dev Writes a byte string to a buffer. Resizes if doing so would exceed\n     *      the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param off The start offset to write to.\n     * @param rawData The data to append.\n     * @param len The number of bytes to copy.\n     * @return The original buffer, for chaining.\n     */\n    function writeRawBytes(\n        buffer memory buf,\n        uint off,\n        bytes memory rawData,\n        uint offData,\n        uint len\n    ) internal pure returns (buffer memory) {\n        if (off + len > buf.capacity) {\n            resize(buf, max(buf.capacity, len + off) * 2);\n        }\n\n        uint dest;\n        uint src;\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Length of existing buffer data\n            let buflen := mload(bufptr)\n            // Start address = buffer address + offset + sizeof(buffer length)\n            dest := add(add(bufptr, 32), off)\n            // Update buffer length if we're extending it\n            if gt(add(len, off), buflen) {\n                mstore(bufptr, add(len, off))\n            }\n            src := add(rawData, offData)\n        }\n\n        // Copy word-length chunks while possible\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        uint mask = 256 ** (32 - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n\n        return buf;\n    }\n\n    /**\n     * @dev Writes a byte string to a buffer. Resizes if doing so would exceed\n     *      the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param off The start offset to write to.\n     * @param data The data to append.\n     * @param len The number of bytes to copy.\n     * @return The original buffer, for chaining.\n     */\n    function write(buffer memory buf, uint off, bytes memory data, uint len) internal pure returns (buffer memory) {\n        require(len <= data.length);\n\n        if (off + len > buf.capacity) {\n            resize(buf, max(buf.capacity, len + off) * 2);\n        }\n\n        uint dest;\n        uint src;\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Length of existing buffer data\n            let buflen := mload(bufptr)\n            // Start address = buffer address + offset + sizeof(buffer length)\n            dest := add(add(bufptr, 32), off)\n            // Update buffer length if we're extending it\n            if gt(add(len, off), buflen) {\n                mstore(bufptr, add(len, off))\n            }\n            src := add(data, 32)\n        }\n\n        // Copy word-length chunks while possible\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        uint mask = 256 ** (32 - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n\n        return buf;\n    }\n\n    function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\n        return write(buf, buf.buf.length, data, data.length);\n    }\n\n    function resize(buffer memory buf, uint capacity) private pure {\n        bytes memory oldbuf = buf.buf;\n        init(buf, capacity);\n        append(buf, oldbuf);\n    }\n\n    function max(uint a, uint b) private pure returns (uint) {\n        if (a > b) {\n            return a;\n        }\n        return b;\n    }\n}\n"
    },
    "contracts/V1Contracts/contracts/utility/LayerZeroPacket.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\n\nimport \"./Buffer.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nlibrary LayerZeroPacket {\n    using Buffer for Buffer.buffer;\n    using SafeMath for uint;\n\n    struct Packet {\n        uint16 srcChainId;\n        uint16 dstChainId;\n        uint64 nonce;\n        address dstAddress;\n        bytes srcAddress;\n        bytes32 ulnAddress;\n        bytes payload;\n    }\n\n    function getPacket(\n        bytes memory data,\n        uint16 srcChain,\n        uint sizeOfSrcAddress,\n        bytes32 ulnAddress\n    ) internal pure returns (LayerZeroPacket.Packet memory) {\n        uint16 dstChainId;\n        address dstAddress;\n        uint size;\n        uint64 nonce;\n\n        // The log consists of the destination chain id and then a bytes payload\n        //      0--------------------------------------------31\n        // 0   |  total bytes size\n        // 32  |  destination chain id\n        // 64  |  bytes offset\n        // 96  |  bytes array size\n        // 128 |  payload\n        assembly {\n            dstChainId := mload(add(data, 32))\n            size := mload(add(data, 96)) /// size of the byte array\n            nonce := mload(add(data, 104)) // offset to convert to uint64  128  is index -24\n            dstAddress := mload(add(data, sub(add(128, sizeOfSrcAddress), 4))) // offset to convert to address 12 -8\n        }\n\n        Buffer.buffer memory srcAddressBuffer;\n        srcAddressBuffer.init(sizeOfSrcAddress);\n        srcAddressBuffer.writeRawBytes(0, data, 136, sizeOfSrcAddress); // 128 + 8\n\n        uint payloadSize = size.sub(28).sub(sizeOfSrcAddress);\n        Buffer.buffer memory payloadBuffer;\n        payloadBuffer.init(payloadSize);\n        payloadBuffer.writeRawBytes(0, data, sizeOfSrcAddress.add(156), payloadSize); // 148 + 8\n        return\n            LayerZeroPacket.Packet(\n                srcChain,\n                dstChainId,\n                nonce,\n                dstAddress,\n                srcAddressBuffer.buf,\n                ulnAddress,\n                payloadBuffer.buf\n            );\n    }\n\n    function getPacketV2(\n        bytes memory data,\n        uint sizeOfSrcAddress,\n        bytes32 ulnAddress\n    ) internal pure returns (LayerZeroPacket.Packet memory) {\n        // packet def: abi.encodePacked(nonce, srcChain, srcAddress, dstChain, dstAddress, payload);\n        // data def: abi.encode(packet) = offset(32) + length(32) + packet\n        //              if from EVM\n        // 0 - 31       0 - 31          |  total bytes size\n        // 32 - 63      32 - 63         |  location\n        // 64 - 95      64 - 95         |  size of the packet\n        // 96 - 103     96 - 103        |  nonce\n        // 104 - 105    104 - 105       |  srcChainId\n        // 106 - P      106 - 125       |  srcAddress, where P = 106 + sizeOfSrcAddress - 1,\n        // P+1 - P+2    126 - 127       |  dstChainId\n        // P+3 - P+22   128 - 147       |  dstAddress\n        // P+23 - END   148 - END       |  payload\n\n        // decode the packet\n        uint256 realSize;\n        uint64 nonce;\n        uint16 srcChain;\n        uint16 dstChain;\n        address dstAddress;\n        assembly {\n            realSize := mload(add(data, 64))\n            nonce := mload(add(data, 72)) // 104 - 32\n            srcChain := mload(add(data, 74)) // 106 - 32\n            dstChain := mload(add(data, add(76, sizeOfSrcAddress))) // P + 3 - 32 = 105 + size + 3 - 32 = 76 + size\n            dstAddress := mload(add(data, add(96, sizeOfSrcAddress))) // P + 23 - 32 = 105 + size + 23 - 32 = 96 + size\n        }\n\n        require(srcChain != 0, \"LayerZeroPacket: invalid packet\");\n\n        Buffer.buffer memory srcAddressBuffer;\n        srcAddressBuffer.init(sizeOfSrcAddress);\n        srcAddressBuffer.writeRawBytes(0, data, 106, sizeOfSrcAddress);\n\n        uint nonPayloadSize = sizeOfSrcAddress.add(32); // 2 + 2 + 8 + 20, 32 + 20 = 52 if sizeOfSrcAddress == 20\n        uint payloadSize = realSize.sub(nonPayloadSize);\n        Buffer.buffer memory payloadBuffer;\n        payloadBuffer.init(payloadSize);\n        payloadBuffer.writeRawBytes(0, data, nonPayloadSize.add(96), payloadSize);\n\n        return\n            LayerZeroPacket.Packet(\n                srcChain,\n                dstChain,\n                nonce,\n                dstAddress,\n                srcAddressBuffer.buf,\n                ulnAddress,\n                payloadBuffer.buf\n            );\n    }\n\n    function getPacketV3(\n        bytes memory data,\n        uint sizeOfSrcAddress,\n        bytes32 ulnAddress\n    ) internal pure returns (LayerZeroPacket.Packet memory) {\n        // data def: abi.encodePacked(nonce, srcChain, srcAddress, dstChain, dstAddress, payload);\n        //              if from EVM\n        // 0 - 31       0 - 31          |  total bytes size\n        // 32 - 39      32 - 39         |  nonce\n        // 40 - 41      40 - 41         |  srcChainId\n        // 42 - P       42 - 61         |  srcAddress, where P = 41 + sizeOfSrcAddress,\n        // P+1 - P+2    62 - 63         |  dstChainId\n        // P+3 - P+22   64 - 83         |  dstAddress\n        // P+23 - END   84 - END        |  payload\n\n        // decode the packet\n        uint256 realSize = data.length;\n        uint nonPayloadSize = sizeOfSrcAddress.add(32); // 2 + 2 + 8 + 20, 32 + 20 = 52 if sizeOfSrcAddress == 20\n        require(realSize >= nonPayloadSize, \"LayerZeroPacket: invalid packet\");\n        uint payloadSize = realSize - nonPayloadSize;\n\n        uint64 nonce;\n        uint16 srcChain;\n        uint16 dstChain;\n        address dstAddress;\n        assembly {\n            nonce := mload(add(data, 8)) // 40 - 32\n            srcChain := mload(add(data, 10)) // 42 - 32\n            dstChain := mload(add(data, add(12, sizeOfSrcAddress))) // P + 3 - 32 = 41 + size + 3 - 32 = 12 + size\n            dstAddress := mload(add(data, add(32, sizeOfSrcAddress))) // P + 23 - 32 = 41 + size + 23 - 32 = 32 + size\n        }\n\n        require(srcChain != 0, \"LayerZeroPacket: invalid packet\");\n\n        Buffer.buffer memory srcAddressBuffer;\n        srcAddressBuffer.init(sizeOfSrcAddress);\n        srcAddressBuffer.writeRawBytes(0, data, 42, sizeOfSrcAddress);\n\n        Buffer.buffer memory payloadBuffer;\n        if (payloadSize > 0) {\n            payloadBuffer.init(payloadSize);\n            payloadBuffer.writeRawBytes(0, data, nonPayloadSize.add(32), payloadSize);\n        }\n\n        return\n            LayerZeroPacket.Packet(\n                srcChain,\n                dstChain,\n                nonce,\n                dstAddress,\n                srcAddressBuffer.buf,\n                ulnAddress,\n                payloadBuffer.buf\n            );\n    }\n}\n"
    },
    "contracts/V1Contracts/interfaces/ILayerZeroValidationLibrary.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.7.0;\npragma abicoder v2;\n\nimport \"../proof/utility/LayerZeroPacket.sol\";\n\ninterface ILayerZeroValidationLibrary {\n    function validateProof(\n        bytes32 blockData,\n        bytes calldata _data,\n        uint _remoteAddressSize\n    ) external returns (LayerZeroPacket.Packet memory packet);\n}\n"
    },
    "contracts/V1Contracts/interfaces/IValidationLibraryHelperV2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.7.0;\npragma abicoder v2;\n\nimport \"../proof/utility/LayerZeroPacket.sol\";\n\ninterface IValidationLibraryHelperV2 {\n    struct ULNLog {\n        bytes32 contractAddress;\n        bytes32 topicZeroSig;\n        bytes data;\n    }\n\n    function getVerifyLog(\n        bytes32 hashRoot,\n        uint[] calldata receiptSlotIndex,\n        uint logIndex,\n        bytes[] calldata proof\n    ) external pure returns (ULNLog memory);\n\n    function getPacket(\n        bytes calldata data,\n        uint sizeOfSrcAddress,\n        bytes32 ulnAddress\n    ) external pure returns (LayerZeroPacket.Packet memory);\n\n    function getUtilsVersion() external view returns (uint8);\n\n    function getProofType() external view returns (uint8);\n}\n"
    },
    "contracts/V1Contracts/proof/utility/Buffer.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n// https://github.com/ensdomains/buffer\n\npragma solidity ^0.7.0;\n\n/**\n * @dev A library for working with mutable byte buffers in Solidity.\n *\n * Byte buffers are mutable and expandable, and provide a variety of primitives\n * for writing to them. At any time you can fetch a bytes object containing the\n * current contents of the buffer. The bytes object should not be stored between\n * operations, as it may change due to resizing of the buffer.\n */\nlibrary Buffer {\n    /**\n     * @dev Represents a mutable buffer. Buffers have a current value (buf) and\n     *      a capacity. The capacity may be longer than the current value, in\n     *      which case it can be extended without the need to allocate more memory.\n     */\n    struct buffer {\n        bytes buf;\n        uint capacity;\n    }\n\n    /**\n     * @dev Initializes a buffer with an initial capacity.a co\n     * @param buf The buffer to initialize.\n     * @param capacity The number of bytes of space to allocate the buffer.\n     * @return The buffer, for chaining.\n     */\n    function init(buffer memory buf, uint capacity) internal pure returns (buffer memory) {\n        if (capacity % 32 != 0) {\n            capacity += 32 - (capacity % 32);\n        }\n        // Allocate space for the buffer data\n        buf.capacity = capacity;\n        assembly {\n            let ptr := mload(0x40)\n            mstore(buf, ptr)\n            mstore(ptr, 0)\n            mstore(0x40, add(32, add(ptr, capacity)))\n        }\n        return buf;\n    }\n\n    /**\n     * @dev Writes a byte string to a buffer. Resizes if doing so would exceed\n     *      the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param off The start offset to write to.\n     * @param rawData The data to append.\n     * @param len The number of bytes to copy.\n     * @return The original buffer, for chaining.\n     */\n    function writeRawBytes(\n        buffer memory buf,\n        uint off,\n        bytes memory rawData,\n        uint offData,\n        uint len\n    ) internal pure returns (buffer memory) {\n        if (off + len > buf.capacity) {\n            resize(buf, max(buf.capacity, len + off) * 2);\n        }\n\n        uint dest;\n        uint src;\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Length of existing buffer data\n            let buflen := mload(bufptr)\n            // Start address = buffer address + offset + sizeof(buffer length)\n            dest := add(add(bufptr, 32), off)\n            // Update buffer length if we're extending it\n            if gt(add(len, off), buflen) {\n                mstore(bufptr, add(len, off))\n            }\n            src := add(rawData, offData)\n        }\n\n        // Copy word-length chunks while possible\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        uint mask = 256 ** (32 - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n\n        return buf;\n    }\n\n    /**\n     * @dev Writes a byte string to a buffer. Resizes if doing so would exceed\n     *      the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param off The start offset to write to.\n     * @param data The data to append.\n     * @param len The number of bytes to copy.\n     * @return The original buffer, for chaining.\n     */\n    function write(buffer memory buf, uint off, bytes memory data, uint len) internal pure returns (buffer memory) {\n        require(len <= data.length);\n\n        if (off + len > buf.capacity) {\n            resize(buf, max(buf.capacity, len + off) * 2);\n        }\n\n        uint dest;\n        uint src;\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Length of existing buffer data\n            let buflen := mload(bufptr)\n            // Start address = buffer address + offset + sizeof(buffer length)\n            dest := add(add(bufptr, 32), off)\n            // Update buffer length if we're extending it\n            if gt(add(len, off), buflen) {\n                mstore(bufptr, add(len, off))\n            }\n            src := add(data, 32)\n        }\n\n        // Copy word-length chunks while possible\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        uint mask = 256 ** (32 - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n\n        return buf;\n    }\n\n    function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\n        return write(buf, buf.buf.length, data, data.length);\n    }\n\n    function resize(buffer memory buf, uint capacity) private pure {\n        bytes memory oldbuf = buf.buf;\n        init(buf, capacity);\n        append(buf, oldbuf);\n    }\n\n    function max(uint a, uint b) private pure returns (uint) {\n        if (a > b) {\n            return a;\n        }\n        return b;\n    }\n}\n"
    },
    "contracts/V1Contracts/proof/utility/LayerZeroPacket.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\n\nimport \"./Buffer.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nlibrary LayerZeroPacket {\n    using Buffer for Buffer.buffer;\n    using SafeMath for uint;\n\n    struct Packet {\n        uint16 srcChainId;\n        uint16 dstChainId;\n        uint64 nonce;\n        address dstAddress;\n        bytes srcAddress;\n        bytes32 ulnAddress;\n        bytes payload;\n    }\n\n    function getPacket(\n        bytes memory data,\n        uint16 srcChain,\n        uint sizeOfSrcAddress,\n        bytes32 ulnAddress\n    ) internal pure returns (LayerZeroPacket.Packet memory) {\n        uint16 dstChainId;\n        address dstAddress;\n        uint size;\n        uint64 nonce;\n\n        // The log consists of the destination chain id and then a bytes payload\n        //      0--------------------------------------------31\n        // 0   |  total bytes size\n        // 32  |  destination chain id\n        // 64  |  bytes offset\n        // 96  |  bytes array size\n        // 128 |  payload\n        assembly {\n            dstChainId := mload(add(data, 32))\n            size := mload(add(data, 96)) /// size of the byte array\n            nonce := mload(add(data, 104)) // offset to convert to uint64  128  is index -24\n            dstAddress := mload(add(data, sub(add(128, sizeOfSrcAddress), 4))) // offset to convert to address 12 -8\n        }\n\n        Buffer.buffer memory srcAddressBuffer;\n        srcAddressBuffer.init(sizeOfSrcAddress);\n        srcAddressBuffer.writeRawBytes(0, data, 136, sizeOfSrcAddress); // 128 + 8\n\n        uint payloadSize = size.sub(28).sub(sizeOfSrcAddress);\n        Buffer.buffer memory payloadBuffer;\n        payloadBuffer.init(payloadSize);\n        payloadBuffer.writeRawBytes(0, data, sizeOfSrcAddress.add(156), payloadSize); // 148 + 8\n        return\n            LayerZeroPacket.Packet(\n                srcChain,\n                dstChainId,\n                nonce,\n                dstAddress,\n                srcAddressBuffer.buf,\n                ulnAddress,\n                payloadBuffer.buf\n            );\n    }\n\n    function getPacketV2(\n        bytes memory data,\n        uint sizeOfSrcAddress,\n        bytes32 ulnAddress\n    ) internal pure returns (LayerZeroPacket.Packet memory) {\n        // packet def: abi.encodePacked(nonce, srcChain, srcAddress, dstChain, dstAddress, payload);\n        // data def: abi.encode(packet) = offset(32) + length(32) + packet\n        //              if from EVM\n        // 0 - 31       0 - 31          |  total bytes size\n        // 32 - 63      32 - 63         |  location\n        // 64 - 95      64 - 95         |  size of the packet\n        // 96 - 103     96 - 103        |  nonce\n        // 104 - 105    104 - 105       |  srcChainId\n        // 106 - P      106 - 125       |  srcAddress, where P = 106 + sizeOfSrcAddress - 1,\n        // P+1 - P+2    126 - 127       |  dstChainId\n        // P+3 - P+22   128 - 147       |  dstAddress\n        // P+23 - END   148 - END       |  payload\n\n        // decode the packet\n        uint256 realSize;\n        uint64 nonce;\n        uint16 srcChain;\n        uint16 dstChain;\n        address dstAddress;\n        assembly {\n            realSize := mload(add(data, 64))\n            nonce := mload(add(data, 72)) // 104 - 32\n            srcChain := mload(add(data, 74)) // 106 - 32\n            dstChain := mload(add(data, add(76, sizeOfSrcAddress))) // P + 3 - 32 = 105 + size + 3 - 32 = 76 + size\n            dstAddress := mload(add(data, add(96, sizeOfSrcAddress))) // P + 23 - 32 = 105 + size + 23 - 32 = 96 + size\n        }\n\n        require(srcChain != 0, \"LayerZeroPacket: invalid packet\");\n\n        Buffer.buffer memory srcAddressBuffer;\n        srcAddressBuffer.init(sizeOfSrcAddress);\n        srcAddressBuffer.writeRawBytes(0, data, 106, sizeOfSrcAddress);\n\n        uint nonPayloadSize = sizeOfSrcAddress.add(32); // 2 + 2 + 8 + 20, 32 + 20 = 52 if sizeOfSrcAddress == 20\n        uint payloadSize = realSize.sub(nonPayloadSize);\n        Buffer.buffer memory payloadBuffer;\n        payloadBuffer.init(payloadSize);\n        payloadBuffer.writeRawBytes(0, data, nonPayloadSize.add(96), payloadSize);\n\n        return\n            LayerZeroPacket.Packet(\n                srcChain,\n                dstChain,\n                nonce,\n                dstAddress,\n                srcAddressBuffer.buf,\n                ulnAddress,\n                payloadBuffer.buf\n            );\n    }\n\n    function getPacketV3(\n        bytes memory data,\n        uint sizeOfSrcAddress,\n        bytes32 ulnAddress\n    ) internal pure returns (LayerZeroPacket.Packet memory) {\n        // data def: abi.encodePacked(nonce, srcChain, srcAddress, dstChain, dstAddress, payload);\n        //              if from EVM\n        // 0 - 31       0 - 31          |  total bytes size\n        // 32 - 39      32 - 39         |  nonce\n        // 40 - 41      40 - 41         |  srcChainId\n        // 42 - P       42 - 61         |  srcAddress, where P = 41 + sizeOfSrcAddress,\n        // P+1 - P+2    62 - 63         |  dstChainId\n        // P+3 - P+22   64 - 83         |  dstAddress\n        // P+23 - END   84 - END        |  payload\n\n        // decode the packet\n        uint256 realSize = data.length;\n        uint nonPayloadSize = sizeOfSrcAddress.add(32); // 2 + 2 + 8 + 20, 32 + 20 = 52 if sizeOfSrcAddress == 20\n        require(realSize >= nonPayloadSize, \"LayerZeroPacket: invalid packet\");\n        uint payloadSize = realSize - nonPayloadSize;\n\n        uint64 nonce;\n        uint16 srcChain;\n        uint16 dstChain;\n        address dstAddress;\n        assembly {\n            nonce := mload(add(data, 8)) // 40 - 32\n            srcChain := mload(add(data, 10)) // 42 - 32\n            dstChain := mload(add(data, add(12, sizeOfSrcAddress))) // P + 3 - 32 = 41 + size + 3 - 32 = 12 + size\n            dstAddress := mload(add(data, add(32, sizeOfSrcAddress))) // P + 23 - 32 = 41 + size + 23 - 32 = 32 + size\n        }\n\n        require(srcChain != 0, \"LayerZeroPacket: invalid packet\");\n\n        Buffer.buffer memory srcAddressBuffer;\n        srcAddressBuffer.init(sizeOfSrcAddress);\n        srcAddressBuffer.writeRawBytes(0, data, 42, sizeOfSrcAddress);\n\n        Buffer.buffer memory payloadBuffer;\n        if (payloadSize > 0) {\n            payloadBuffer.init(payloadSize);\n            payloadBuffer.writeRawBytes(0, data, nonPayloadSize.add(32), payloadSize);\n        }\n\n        return\n            LayerZeroPacket.Packet(\n                srcChain,\n                dstChain,\n                nonce,\n                dstAddress,\n                srcAddressBuffer.buf,\n                ulnAddress,\n                payloadBuffer.buf\n            );\n    }\n}\n"
    },
    "hardhat-deploy/solc_0.7/proxy/Proxied.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nabstract contract Proxied {\n    /// @notice to be used by initialisation / postUpgrade function so that only the proxy's admin can execute them\n    /// It also allows these functions to be called inside a contructor\n    /// even if the contract is meant to be used without proxy\n    modifier proxied() {\n        address proxyAdminAddress = _proxyAdmin();\n        // With hardhat-deploy proxies\n        // the proxyAdminAddress is zero only for the implementation contract\n        // if the implementation contract want to be used as a standalone/immutable contract\n        // it simply has to execute the `proxied` function\n        // This ensure the proxyAdminAddress is never zero post deployment\n        // And allow you to keep the same code for both proxied contract and immutable contract\n        if (proxyAdminAddress == address(0)) {\n            // ensure can not be called twice when used outside of proxy : no admin\n            // solhint-disable-next-line security/no-inline-assembly\n            assembly {\n                sstore(\n                    0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103,\n                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n                )\n            }\n        } else {\n            require(msg.sender == proxyAdminAddress);\n        }\n        _;\n    }\n\n    modifier onlyProxyAdmin() {\n        require(msg.sender == _proxyAdmin(), \"NOT_AUTHORIZED\");\n        _;\n    }\n\n    function _proxyAdmin() internal view returns (address ownerAddress) {\n        // solhint-disable-next-line security/no-inline-assembly\n        assembly {\n            ownerAddress := sload(0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103)\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}