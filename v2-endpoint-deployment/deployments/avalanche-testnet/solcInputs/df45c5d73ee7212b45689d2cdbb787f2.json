{
  "language": "Solidity",
  "sources": {
    "@arbitrum/nitro-contracts/src/bridge/IBridge.sol": {
      "content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\n// solhint-disable-next-line compiler-version\npragma solidity >=0.6.9 <0.9.0;\n\nimport \"./IOwnable.sol\";\n\ninterface IBridge {\n    /// @dev This is an instruction to offchain readers to inform them where to look\n    ///      for sequencer inbox batch data. This is not the type of data (eg. das, brotli encoded, or blob versioned hash)\n    ///      and this enum is not used in the state transition function, rather it informs an offchain\n    ///      reader where to find the data so that they can supply it to the replay binary\n    enum BatchDataLocation {\n        /// @notice The data can be found in the transaction call data\n        TxInput,\n        /// @notice The data can be found in an event emitted during the transaction\n        SeparateBatchEvent,\n        /// @notice This batch contains no data\n        NoData,\n        /// @notice The data can be found in the 4844 data blobs on this transaction\n        Blob\n    }\n\n    struct TimeBounds {\n        uint64 minTimestamp;\n        uint64 maxTimestamp;\n        uint64 minBlockNumber;\n        uint64 maxBlockNumber;\n    }\n\n    event MessageDelivered(\n        uint256 indexed messageIndex,\n        bytes32 indexed beforeInboxAcc,\n        address inbox,\n        uint8 kind,\n        address sender,\n        bytes32 messageDataHash,\n        uint256 baseFeeL1,\n        uint64 timestamp\n    );\n\n    event BridgeCallTriggered(\n        address indexed outbox,\n        address indexed to,\n        uint256 value,\n        bytes data\n    );\n\n    event InboxToggle(address indexed inbox, bool enabled);\n\n    event OutboxToggle(address indexed outbox, bool enabled);\n\n    event SequencerInboxUpdated(address newSequencerInbox);\n\n    event RollupUpdated(address rollup);\n\n    function allowedDelayedInboxList(uint256) external returns (address);\n\n    function allowedOutboxList(uint256) external returns (address);\n\n    /// @dev Accumulator for delayed inbox messages; tail represents hash of the current state; each element represents the inclusion of a new message.\n    function delayedInboxAccs(uint256) external view returns (bytes32);\n\n    /// @dev Accumulator for sequencer inbox messages; tail represents hash of the current state; each element represents the inclusion of a new message.\n    function sequencerInboxAccs(uint256) external view returns (bytes32);\n\n    function rollup() external view returns (IOwnable);\n\n    function sequencerInbox() external view returns (address);\n\n    function activeOutbox() external view returns (address);\n\n    function allowedDelayedInboxes(address inbox) external view returns (bool);\n\n    function allowedOutboxes(address outbox) external view returns (bool);\n\n    function sequencerReportedSubMessageCount() external view returns (uint256);\n\n    function executeCall(\n        address to,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bool success, bytes memory returnData);\n\n    function delayedMessageCount() external view returns (uint256);\n\n    function sequencerMessageCount() external view returns (uint256);\n\n    // ---------- onlySequencerInbox functions ----------\n\n    function enqueueSequencerMessage(\n        bytes32 dataHash,\n        uint256 afterDelayedMessagesRead,\n        uint256 prevMessageCount,\n        uint256 newMessageCount\n    )\n        external\n        returns (\n            uint256 seqMessageIndex,\n            bytes32 beforeAcc,\n            bytes32 delayedAcc,\n            bytes32 acc\n        );\n\n    /**\n     * @dev Allows the sequencer inbox to submit a delayed message of the batchPostingReport type\n     *      This is done through a separate function entrypoint instead of allowing the sequencer inbox\n     *      to call `enqueueDelayedMessage` to avoid the gas overhead of an extra SLOAD in either\n     *      every delayed inbox or every sequencer inbox call.\n     */\n    function submitBatchSpendingReport(address batchPoster, bytes32 dataHash)\n        external\n        returns (uint256 msgNum);\n\n    // ---------- onlyRollupOrOwner functions ----------\n\n    function setSequencerInbox(address _sequencerInbox) external;\n\n    function setDelayedInbox(address inbox, bool enabled) external;\n\n    function setOutbox(address inbox, bool enabled) external;\n\n    function updateRollupAddress(IOwnable _rollup) external;\n}\n"
    },
    "@arbitrum/nitro-contracts/src/bridge/IDelayedMessageProvider.sol": {
      "content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\n// solhint-disable-next-line compiler-version\npragma solidity >=0.6.9 <0.9.0;\n\ninterface IDelayedMessageProvider {\n    /// @dev event emitted when a inbox message is added to the Bridge's delayed accumulator\n    event InboxMessageDelivered(uint256 indexed messageNum, bytes data);\n\n    /// @dev event emitted when a inbox message is added to the Bridge's delayed accumulator\n    /// same as InboxMessageDelivered but the batch data is available in tx.input\n    event InboxMessageDeliveredFromOrigin(uint256 indexed messageNum);\n}\n"
    },
    "@arbitrum/nitro-contracts/src/bridge/IInbox.sol": {
      "content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/nitro/blob/master/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\n// solhint-disable-next-line compiler-version\npragma solidity >=0.6.9 <0.9.0;\n\nimport \"./IBridge.sol\";\nimport \"./IInboxBase.sol\";\n\ninterface IInbox is IInboxBase {\n    function sendL1FundedUnsignedTransaction(\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        uint256 nonce,\n        address to,\n        bytes calldata data\n    ) external payable returns (uint256);\n\n    function sendL1FundedContractTransaction(\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        address to,\n        bytes calldata data\n    ) external payable returns (uint256);\n\n    /**\n     * @dev This method can only be called upon L1 fork and will not alias the caller\n     *      This method will revert if not called from origin\n     */\n    function sendL1FundedUnsignedTransactionToFork(\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        uint256 nonce,\n        address to,\n        bytes calldata data\n    ) external payable returns (uint256);\n\n    /**\n     * @dev This method can only be called upon L1 fork and will not alias the caller\n     *      This method will revert if not called from origin\n     */\n    function sendUnsignedTransactionToFork(\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        uint256 nonce,\n        address to,\n        uint256 value,\n        bytes calldata data\n    ) external returns (uint256);\n\n    /**\n     * @notice Send a message to initiate L2 withdrawal\n     * @dev This method can only be called upon L1 fork and will not alias the caller\n     *      This method will revert if not called from origin\n     */\n    function sendWithdrawEthToFork(\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        uint256 nonce,\n        uint256 value,\n        address withdrawTo\n    ) external returns (uint256);\n\n    /**\n     * @notice Deposit eth from L1 to L2 to address of the sender if sender is an EOA, and to its aliased address if the sender is a contract\n     * @dev This does not trigger the fallback function when receiving in the L2 side.\n     *      Look into retryable tickets if you are interested in this functionality.\n     * @dev This function should not be called inside contract constructors\n     */\n    function depositEth() external payable returns (uint256);\n\n    /**\n     * @notice Put a message in the L2 inbox that can be reexecuted for some fixed amount of time if it reverts\n     * @dev all msg.value will deposited to callValueRefundAddress on L2\n     * @dev Gas limit and maxFeePerGas should not be set to 1 as that is used to trigger the RetryableData error\n     * @param to destination L2 contract address\n     * @param l2CallValue call value for retryable L2 message\n     * @param maxSubmissionCost Max gas deducted from user's L2 balance to cover base submission fee\n     * @param excessFeeRefundAddress gasLimit x maxFeePerGas - execution cost gets credited here on L2 balance\n     * @param callValueRefundAddress l2Callvalue gets credited here on L2 if retryable txn times out or gets cancelled\n     * @param gasLimit Max gas deducted from user's L2 balance to cover L2 execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\n     * @param maxFeePerGas price bid for L2 execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\n     * @param data ABI encoded data of L2 message\n     * @return unique message number of the retryable transaction\n     */\n    function createRetryableTicket(\n        address to,\n        uint256 l2CallValue,\n        uint256 maxSubmissionCost,\n        address excessFeeRefundAddress,\n        address callValueRefundAddress,\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        bytes calldata data\n    ) external payable returns (uint256);\n\n    /**\n     * @notice Put a message in the L2 inbox that can be reexecuted for some fixed amount of time if it reverts\n     * @dev Same as createRetryableTicket, but does not guarantee that submission will succeed by requiring the needed funds\n     * come from the deposit alone, rather than falling back on the user's L2 balance\n     * @dev Advanced usage only (does not rewrite aliases for excessFeeRefundAddress and callValueRefundAddress).\n     * createRetryableTicket method is the recommended standard.\n     * @dev Gas limit and maxFeePerGas should not be set to 1 as that is used to trigger the RetryableData error\n     * @param to destination L2 contract address\n     * @param l2CallValue call value for retryable L2 message\n     * @param maxSubmissionCost Max gas deducted from user's L2 balance to cover base submission fee\n     * @param excessFeeRefundAddress gasLimit x maxFeePerGas - execution cost gets credited here on L2 balance\n     * @param callValueRefundAddress l2Callvalue gets credited here on L2 if retryable txn times out or gets cancelled\n     * @param gasLimit Max gas deducted from user's L2 balance to cover L2 execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\n     * @param maxFeePerGas price bid for L2 execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\n     * @param data ABI encoded data of L2 message\n     * @return unique message number of the retryable transaction\n     */\n    function unsafeCreateRetryableTicket(\n        address to,\n        uint256 l2CallValue,\n        uint256 maxSubmissionCost,\n        address excessFeeRefundAddress,\n        address callValueRefundAddress,\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        bytes calldata data\n    ) external payable returns (uint256);\n\n    // ---------- initializer ----------\n\n    /**\n     * @dev function to be called one time during the inbox upgrade process\n     *      this is used to fix the storage slots\n     */\n    function postUpgradeInit(IBridge _bridge) external;\n}\n"
    },
    "@arbitrum/nitro-contracts/src/bridge/IInboxBase.sol": {
      "content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\n// solhint-disable-next-line compiler-version\npragma solidity >=0.6.9 <0.9.0;\n\nimport \"./IBridge.sol\";\nimport \"./IDelayedMessageProvider.sol\";\nimport \"./ISequencerInbox.sol\";\n\ninterface IInboxBase is IDelayedMessageProvider {\n    function bridge() external view returns (IBridge);\n\n    function sequencerInbox() external view returns (ISequencerInbox);\n\n    function maxDataSize() external view returns (uint256);\n\n    /**\n     * @notice Send a generic L2 message to the chain\n     * @dev This method is an optimization to avoid having to emit the entirety of the messageData in a log. Instead validators are expected to be able to parse the data from the transaction's input\n     * @param messageData Data of the message being sent\n     */\n    function sendL2MessageFromOrigin(bytes calldata messageData) external returns (uint256);\n\n    /**\n     * @notice Send a generic L2 message to the chain\n     * @dev This method can be used to send any type of message that doesn't require L1 validation\n     * @param messageData Data of the message being sent\n     */\n    function sendL2Message(bytes calldata messageData) external returns (uint256);\n\n    function sendUnsignedTransaction(\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        uint256 nonce,\n        address to,\n        uint256 value,\n        bytes calldata data\n    ) external returns (uint256);\n\n    function sendContractTransaction(\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        address to,\n        uint256 value,\n        bytes calldata data\n    ) external returns (uint256);\n\n    /**\n     * @notice Get the L1 fee for submitting a retryable\n     * @dev This fee can be paid by funds already in the L2 aliased address or by the current message value\n     * @dev This formula may change in the future, to future proof your code query this method instead of inlining!!\n     * @param dataLength The length of the retryable's calldata, in bytes\n     * @param baseFee The block basefee when the retryable is included in the chain, if 0 current block.basefee will be used\n     */\n    function calculateRetryableSubmissionFee(uint256 dataLength, uint256 baseFee)\n        external\n        view\n        returns (uint256);\n\n    // ---------- onlyRollupOrOwner functions ----------\n\n    /// @notice pauses all inbox functionality\n    function pause() external;\n\n    /// @notice unpauses all inbox functionality\n    function unpause() external;\n\n    /// @notice add or remove users from allowList\n    function setAllowList(address[] memory user, bool[] memory val) external;\n\n    /// @notice enable or disable allowList\n    function setAllowListEnabled(bool _allowListEnabled) external;\n\n    /// @notice check if user is in allowList\n    function isAllowed(address user) external view returns (bool);\n\n    /// @notice check if allowList is enabled\n    function allowListEnabled() external view returns (bool);\n\n    function initialize(IBridge _bridge, ISequencerInbox _sequencerInbox) external;\n\n    /// @notice returns the current admin\n    function getProxyAdmin() external view returns (address);\n}\n"
    },
    "@arbitrum/nitro-contracts/src/bridge/IOwnable.sol": {
      "content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\n// solhint-disable-next-line compiler-version\npragma solidity >=0.4.21 <0.9.0;\n\ninterface IOwnable {\n    function owner() external view returns (address);\n}\n"
    },
    "@arbitrum/nitro-contracts/src/bridge/ISequencerInbox.sol": {
      "content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\n// solhint-disable-next-line compiler-version\npragma solidity >=0.6.9 <0.9.0;\npragma experimental ABIEncoderV2;\n\nimport \"../libraries/IGasRefunder.sol\";\nimport \"./IDelayedMessageProvider.sol\";\nimport \"./IBridge.sol\";\n\ninterface ISequencerInbox is IDelayedMessageProvider {\n    struct MaxTimeVariation {\n        uint256 delayBlocks;\n        uint256 futureBlocks;\n        uint256 delaySeconds;\n        uint256 futureSeconds;\n    }\n\n    event SequencerBatchDelivered(\n        uint256 indexed batchSequenceNumber,\n        bytes32 indexed beforeAcc,\n        bytes32 indexed afterAcc,\n        bytes32 delayedAcc,\n        uint256 afterDelayedMessagesRead,\n        IBridge.TimeBounds timeBounds,\n        IBridge.BatchDataLocation dataLocation\n    );\n\n    event OwnerFunctionCalled(uint256 indexed id);\n\n    /// @dev a separate event that emits batch data when this isn't easily accessible in the tx.input\n    event SequencerBatchData(uint256 indexed batchSequenceNumber, bytes data);\n\n    /// @dev a valid keyset was added\n    event SetValidKeyset(bytes32 indexed keysetHash, bytes keysetBytes);\n\n    /// @dev a keyset was invalidated\n    event InvalidateKeyset(bytes32 indexed keysetHash);\n\n    function totalDelayedMessagesRead() external view returns (uint256);\n\n    function bridge() external view returns (IBridge);\n\n    /// @dev The size of the batch header\n    // solhint-disable-next-line func-name-mixedcase\n    function HEADER_LENGTH() external view returns (uint256);\n\n    /// @dev If the first batch data byte after the header has this bit set,\n    ///      the sequencer inbox has authenticated the data. Currently only used for 4844 blob support.\n    ///      See: https://github.com/OffchainLabs/nitro/blob/69de0603abf6f900a4128cab7933df60cad54ded/arbstate/das_reader.go\n    // solhint-disable-next-line func-name-mixedcase\n    function DATA_AUTHENTICATED_FLAG() external view returns (bytes1);\n\n    /// @dev If the first data byte after the header has this bit set,\n    ///      then the batch data is to be found in 4844 data blobs\n    ///      See: https://github.com/OffchainLabs/nitro/blob/69de0603abf6f900a4128cab7933df60cad54ded/arbstate/das_reader.go\n    // solhint-disable-next-line func-name-mixedcase\n    function DATA_BLOB_HEADER_FLAG() external view returns (bytes1);\n\n    /// @dev If the first data byte after the header has this bit set,\n    ///      then the batch data is a das message\n    ///      See: https://github.com/OffchainLabs/nitro/blob/69de0603abf6f900a4128cab7933df60cad54ded/arbstate/das_reader.go\n    // solhint-disable-next-line func-name-mixedcase\n    function DAS_MESSAGE_HEADER_FLAG() external view returns (bytes1);\n\n    /// @dev If the first data byte after the header has this bit set,\n    ///      then the batch data is a das message that employs a merklesization strategy\n    ///      See: https://github.com/OffchainLabs/nitro/blob/69de0603abf6f900a4128cab7933df60cad54ded/arbstate/das_reader.go\n    // solhint-disable-next-line func-name-mixedcase\n    function TREE_DAS_MESSAGE_HEADER_FLAG() external view returns (bytes1);\n\n    /// @dev If the first data byte after the header has this bit set,\n    ///      then the batch data has been brotli compressed\n    ///      See: https://github.com/OffchainLabs/nitro/blob/69de0603abf6f900a4128cab7933df60cad54ded/arbstate/das_reader.go\n    // solhint-disable-next-line func-name-mixedcase\n    function BROTLI_MESSAGE_HEADER_FLAG() external view returns (bytes1);\n\n    /// @dev If the first data byte after the header has this bit set,\n    ///      then the batch data uses a zero heavy encoding\n    ///      See: https://github.com/OffchainLabs/nitro/blob/69de0603abf6f900a4128cab7933df60cad54ded/arbstate/das_reader.go\n    // solhint-disable-next-line func-name-mixedcase\n    function ZERO_HEAVY_MESSAGE_HEADER_FLAG() external view returns (bytes1);\n\n    function rollup() external view returns (IOwnable);\n\n    function isBatchPoster(address) external view returns (bool);\n\n    function isSequencer(address) external view returns (bool);\n\n    function maxDataSize() external view returns (uint256);\n\n    /// @notice The batch poster manager has the ability to change the batch poster addresses\n    ///         This enables the batch poster to do key rotation\n    function batchPosterManager() external view returns (address);\n\n    struct DasKeySetInfo {\n        bool isValidKeyset;\n        uint64 creationBlock;\n    }\n\n    /// @dev returns 4 uint256 to be compatible with older version\n    function maxTimeVariation()\n        external\n        view\n        returns (\n            uint256 delayBlocks,\n            uint256 futureBlocks,\n            uint256 delaySeconds,\n            uint256 futureSeconds\n        );\n\n    function dasKeySetInfo(bytes32) external view returns (bool, uint64);\n\n    /// @notice Remove force inclusion delay after a L1 chainId fork\n    function removeDelayAfterFork() external;\n\n    /// @notice Force messages from the delayed inbox to be included in the chain\n    ///         Callable by any address, but message can only be force-included after maxTimeVariation.delayBlocks and\n    ///         maxTimeVariation.delaySeconds has elapsed. As part of normal behaviour the sequencer will include these\n    ///         messages so it's only necessary to call this if the sequencer is down, or not including any delayed messages.\n    /// @param _totalDelayedMessagesRead The total number of messages to read up to\n    /// @param kind The kind of the last message to be included\n    /// @param l1BlockAndTime The l1 block and the l1 timestamp of the last message to be included\n    /// @param baseFeeL1 The l1 gas price of the last message to be included\n    /// @param sender The sender of the last message to be included\n    /// @param messageDataHash The messageDataHash of the last message to be included\n    function forceInclusion(\n        uint256 _totalDelayedMessagesRead,\n        uint8 kind,\n        uint64[2] calldata l1BlockAndTime,\n        uint256 baseFeeL1,\n        address sender,\n        bytes32 messageDataHash\n    ) external;\n\n    function inboxAccs(uint256 index) external view returns (bytes32);\n\n    function batchCount() external view returns (uint256);\n\n    function isValidKeysetHash(bytes32 ksHash) external view returns (bool);\n\n    /// @notice the creation block is intended to still be available after a keyset is deleted\n    function getKeysetCreationBlock(bytes32 ksHash) external view returns (uint256);\n\n    // ---------- BatchPoster functions ----------\n\n    function addSequencerL2BatchFromOrigin(\n        uint256 sequenceNumber,\n        bytes calldata data,\n        uint256 afterDelayedMessagesRead,\n        IGasRefunder gasRefunder\n    ) external;\n\n    function addSequencerL2BatchFromOrigin(\n        uint256 sequenceNumber,\n        bytes calldata data,\n        uint256 afterDelayedMessagesRead,\n        IGasRefunder gasRefunder,\n        uint256 prevMessageCount,\n        uint256 newMessageCount\n    ) external;\n\n    function addSequencerL2Batch(\n        uint256 sequenceNumber,\n        bytes calldata data,\n        uint256 afterDelayedMessagesRead,\n        IGasRefunder gasRefunder,\n        uint256 prevMessageCount,\n        uint256 newMessageCount\n    ) external;\n\n    function addSequencerL2BatchFromBlobs(\n        uint256 sequenceNumber,\n        uint256 afterDelayedMessagesRead,\n        IGasRefunder gasRefunder,\n        uint256 prevMessageCount,\n        uint256 newMessageCount\n    ) external;\n\n    // ---------- onlyRollupOrOwner functions ----------\n\n    /**\n     * @notice Set max delay for sequencer inbox\n     * @param maxTimeVariation_ the maximum time variation parameters\n     */\n    function setMaxTimeVariation(MaxTimeVariation memory maxTimeVariation_) external;\n\n    /**\n     * @notice Updates whether an address is authorized to be a batch poster at the sequencer inbox\n     * @param addr the address\n     * @param isBatchPoster_ if the specified address should be authorized as a batch poster\n     */\n    function setIsBatchPoster(address addr, bool isBatchPoster_) external;\n\n    /**\n     * @notice Makes Data Availability Service keyset valid\n     * @param keysetBytes bytes of the serialized keyset\n     */\n    function setValidKeyset(bytes calldata keysetBytes) external;\n\n    /**\n     * @notice Invalidates a Data Availability Service keyset\n     * @param ksHash hash of the keyset\n     */\n    function invalidateKeysetHash(bytes32 ksHash) external;\n\n    /**\n     * @notice Updates whether an address is authorized to be a sequencer.\n     * @dev The IsSequencer information is used only off-chain by the nitro node to validate sequencer feed signer.\n     * @param addr the address\n     * @param isSequencer_ if the specified address should be authorized as a sequencer\n     */\n    function setIsSequencer(address addr, bool isSequencer_) external;\n\n    /**\n     * @notice Updates the batch poster manager, the address which has the ability to rotate batch poster keys\n     * @param newBatchPosterManager The new batch poster manager to be set\n     */\n    function setBatchPosterManager(address newBatchPosterManager) external;\n\n    /// @notice Allows the rollup owner to sync the rollup address\n    function updateRollupAddress() external;\n\n    // ---------- initializer ----------\n\n    function initialize(IBridge bridge_, MaxTimeVariation calldata maxTimeVariation_) external;\n}\n"
    },
    "@arbitrum/nitro-contracts/src/libraries/AddressAliasHelper.sol": {
      "content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nlibrary AddressAliasHelper {\n    uint160 internal constant OFFSET = uint160(0x1111000000000000000000000000000000001111);\n\n    /// @notice Utility function that converts the address in the L1 that submitted a tx to\n    /// the inbox to the msg.sender viewed in the L2\n    /// @param l1Address the address in the L1 that triggered the tx to L2\n    /// @return l2Address L2 address as viewed in msg.sender\n    function applyL1ToL2Alias(address l1Address) internal pure returns (address l2Address) {\n        unchecked {\n            l2Address = address(uint160(l1Address) + OFFSET);\n        }\n    }\n\n    /// @notice Utility function that converts the msg.sender viewed in the L2 to the\n    /// address in the L1 that submitted a tx to the inbox\n    /// @param l2Address L2 address as viewed in msg.sender\n    /// @return l1Address the address in the L1 that triggered the tx to L2\n    function undoL1ToL2Alias(address l2Address) internal pure returns (address l1Address) {\n        unchecked {\n            l1Address = address(uint160(l2Address) - OFFSET);\n        }\n    }\n}\n"
    },
    "@arbitrum/nitro-contracts/src/libraries/IGasRefunder.sol": {
      "content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\n// solhint-disable-next-line compiler-version\npragma solidity >=0.6.9 <0.9.0;\n\ninterface IGasRefunder {\n    function onGasSpent(\n        address payable spender,\n        uint256 gasUsed,\n        uint256 calldataSize\n    ) external returns (bool success);\n}\n"
    },
    "@axelar-network/axelar-gmp-sdk-solidity/contracts/executable/AxelarExecutable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IAxelarGateway } from '../interfaces/IAxelarGateway.sol';\nimport { IAxelarExecutable } from '../interfaces/IAxelarExecutable.sol';\n\ncontract AxelarExecutable is IAxelarExecutable {\n    IAxelarGateway public immutable gateway;\n\n    constructor(address gateway_) {\n        if (gateway_ == address(0)) revert InvalidAddress();\n\n        gateway = IAxelarGateway(gateway_);\n    }\n\n    function execute(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload\n    ) external {\n        bytes32 payloadHash = keccak256(payload);\n\n        if (!gateway.validateContractCall(commandId, sourceChain, sourceAddress, payloadHash))\n            revert NotApprovedByGateway();\n\n        _execute(sourceChain, sourceAddress, payload);\n    }\n\n    function executeWithToken(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload,\n        string calldata tokenSymbol,\n        uint256 amount\n    ) external {\n        bytes32 payloadHash = keccak256(payload);\n\n        if (\n            !gateway.validateContractCallAndMint(\n                commandId,\n                sourceChain,\n                sourceAddress,\n                payloadHash,\n                tokenSymbol,\n                amount\n            )\n        ) revert NotApprovedByGateway();\n\n        _executeWithToken(sourceChain, sourceAddress, payload, tokenSymbol, amount);\n    }\n\n    function _execute(\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload\n    ) internal virtual {}\n\n    function _executeWithToken(\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload,\n        string calldata tokenSymbol,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IAxelarExecutable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IAxelarGateway } from './IAxelarGateway.sol';\n\ninterface IAxelarExecutable {\n    error InvalidAddress();\n    error NotApprovedByGateway();\n\n    function gateway() external view returns (IAxelarGateway);\n\n    function execute(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload\n    ) external;\n\n    function executeWithToken(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload,\n        string calldata tokenSymbol,\n        uint256 amount\n    ) external;\n}\n"
    },
    "@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IAxelarGasService.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { GasInfo } from '../types/GasEstimationTypes.sol';\nimport { IInterchainGasEstimation } from './IInterchainGasEstimation.sol';\nimport { IUpgradable } from './IUpgradable.sol';\n\n/**\n * @title IAxelarGasService Interface\n * @notice This is an interface for the AxelarGasService contract which manages gas payments\n * and refunds for cross-chain communication on the Axelar network.\n * @dev This interface inherits IUpgradable\n */\ninterface IAxelarGasService is IInterchainGasEstimation, IUpgradable {\n    error InvalidAddress();\n    error NotCollector();\n    error InvalidAmounts();\n    error InvalidGasUpdates();\n    error InvalidParams();\n    error InsufficientGasPayment(uint256 required, uint256 provided);\n\n    event GasPaidForContractCall(\n        address indexed sourceAddress,\n        string destinationChain,\n        string destinationAddress,\n        bytes32 indexed payloadHash,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    );\n\n    event GasPaidForContractCallWithToken(\n        address indexed sourceAddress,\n        string destinationChain,\n        string destinationAddress,\n        bytes32 indexed payloadHash,\n        string symbol,\n        uint256 amount,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    );\n\n    event NativeGasPaidForContractCall(\n        address indexed sourceAddress,\n        string destinationChain,\n        string destinationAddress,\n        bytes32 indexed payloadHash,\n        uint256 gasFeeAmount,\n        address refundAddress\n    );\n\n    event NativeGasPaidForContractCallWithToken(\n        address indexed sourceAddress,\n        string destinationChain,\n        string destinationAddress,\n        bytes32 indexed payloadHash,\n        string symbol,\n        uint256 amount,\n        uint256 gasFeeAmount,\n        address refundAddress\n    );\n\n    event GasPaidForExpressCall(\n        address indexed sourceAddress,\n        string destinationChain,\n        string destinationAddress,\n        bytes32 indexed payloadHash,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    );\n\n    event GasPaidForExpressCallWithToken(\n        address indexed sourceAddress,\n        string destinationChain,\n        string destinationAddress,\n        bytes32 indexed payloadHash,\n        string symbol,\n        uint256 amount,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    );\n\n    event NativeGasPaidForExpressCall(\n        address indexed sourceAddress,\n        string destinationChain,\n        string destinationAddress,\n        bytes32 indexed payloadHash,\n        uint256 gasFeeAmount,\n        address refundAddress\n    );\n\n    event NativeGasPaidForExpressCallWithToken(\n        address indexed sourceAddress,\n        string destinationChain,\n        string destinationAddress,\n        bytes32 indexed payloadHash,\n        string symbol,\n        uint256 amount,\n        uint256 gasFeeAmount,\n        address refundAddress\n    );\n\n    event GasAdded(\n        bytes32 indexed txHash,\n        uint256 indexed logIndex,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    );\n\n    event NativeGasAdded(bytes32 indexed txHash, uint256 indexed logIndex, uint256 gasFeeAmount, address refundAddress);\n\n    event ExpressGasAdded(\n        bytes32 indexed txHash,\n        uint256 indexed logIndex,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    );\n\n    event NativeExpressGasAdded(\n        bytes32 indexed txHash,\n        uint256 indexed logIndex,\n        uint256 gasFeeAmount,\n        address refundAddress\n    );\n\n    event Refunded(\n        bytes32 indexed txHash,\n        uint256 indexed logIndex,\n        address payable receiver,\n        address token,\n        uint256 amount\n    );\n\n    /**\n     * @notice Pay for gas for any type of contract execution on a destination chain.\n     * @dev This function is called on the source chain before calling the gateway to execute a remote contract.\n     * @dev If estimateOnChain is true, the function will estimate the gas cost and revert if the payment is insufficient.\n     * @param sender The address making the payment\n     * @param destinationChain The target chain where the contract call will be made\n     * @param destinationAddress The target address on the destination chain\n     * @param payload Data payload for the contract call\n     * @param executionGasLimit The gas limit for the contract call\n     * @param estimateOnChain Flag to enable on-chain gas estimation\n     * @param refundAddress The address where refunds, if any, should be sent\n     * @param params Additional parameters for gas payment. This can be left empty for normal contract call payments.\n     */\n    function payGas(\n        address sender,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        uint256 executionGasLimit,\n        bool estimateOnChain,\n        address refundAddress,\n        bytes calldata params\n    ) external payable;\n\n    /**\n     * @notice Pay for gas using ERC20 tokens for a contract call on a destination chain.\n     * @dev This function is called on the source chain before calling the gateway to execute a remote contract.\n     * @param sender The address making the payment\n     * @param destinationChain The target chain where the contract call will be made\n     * @param destinationAddress The target address on the destination chain\n     * @param payload Data payload for the contract call\n     * @param gasToken The address of the ERC20 token used to pay for gas\n     * @param gasFeeAmount The amount of tokens to pay for gas\n     * @param refundAddress The address where refunds, if any, should be sent\n     */\n    function payGasForContractCall(\n        address sender,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    ) external;\n\n    /**\n     * @notice Pay for gas using ERC20 tokens for a contract call with tokens on a destination chain.\n     * @dev This function is called on the source chain before calling the gateway to execute a remote contract.\n     * @param sender The address making the payment\n     * @param destinationChain The target chain where the contract call with tokens will be made\n     * @param destinationAddress The target address on the destination chain\n     * @param payload Data payload for the contract call with tokens\n     * @param symbol The symbol of the token to be sent with the call\n     * @param amount The amount of tokens to be sent with the call\n     * @param gasToken The address of the ERC20 token used to pay for gas\n     * @param gasFeeAmount The amount of tokens to pay for gas\n     * @param refundAddress The address where refunds, if any, should be sent\n     */\n    function payGasForContractCallWithToken(\n        address sender,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        string calldata symbol,\n        uint256 amount,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    ) external;\n\n    /**\n     * @notice Pay for gas using native currency for a contract call on a destination chain.\n     * @dev This function is called on the source chain before calling the gateway to execute a remote contract.\n     * @param sender The address making the payment\n     * @param destinationChain The target chain where the contract call will be made\n     * @param destinationAddress The target address on the destination chain\n     * @param payload Data payload for the contract call\n     * @param refundAddress The address where refunds, if any, should be sent\n     */\n    function payNativeGasForContractCall(\n        address sender,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        address refundAddress\n    ) external payable;\n\n    /**\n     * @notice Pay for gas using native currency for a contract call with tokens on a destination chain.\n     * @dev This function is called on the source chain before calling the gateway to execute a remote contract.\n     * @param sender The address making the payment\n     * @param destinationChain The target chain where the contract call with tokens will be made\n     * @param destinationAddress The target address on the destination chain\n     * @param payload Data payload for the contract call with tokens\n     * @param symbol The symbol of the token to be sent with the call\n     * @param amount The amount of tokens to be sent with the call\n     * @param refundAddress The address where refunds, if any, should be sent\n     */\n    function payNativeGasForContractCallWithToken(\n        address sender,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        string calldata symbol,\n        uint256 amount,\n        address refundAddress\n    ) external payable;\n\n    /**\n     * @notice Pay for gas using ERC20 tokens for an express contract call on a destination chain.\n     * @dev This function is called on the source chain before calling the gateway to express execute a remote contract.\n     * @param sender The address making the payment\n     * @param destinationChain The target chain where the contract call will be made\n     * @param destinationAddress The target address on the destination chain\n     * @param payload Data payload for the contract call\n     * @param gasToken The address of the ERC20 token used to pay for gas\n     * @param gasFeeAmount The amount of tokens to pay for gas\n     * @param refundAddress The address where refunds, if any, should be sent\n     */\n    function payGasForExpressCall(\n        address sender,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    ) external;\n\n    /**\n     * @notice Pay for gas using ERC20 tokens for an express contract call with tokens on a destination chain.\n     * @dev This function is called on the source chain before calling the gateway to express execute a remote contract.\n     * @param sender The address making the payment\n     * @param destinationChain The target chain where the contract call with tokens will be made\n     * @param destinationAddress The target address on the destination chain\n     * @param payload Data payload for the contract call with tokens\n     * @param symbol The symbol of the token to be sent with the call\n     * @param amount The amount of tokens to be sent with the call\n     * @param gasToken The address of the ERC20 token used to pay for gas\n     * @param gasFeeAmount The amount of tokens to pay for gas\n     * @param refundAddress The address where refunds, if any, should be sent\n     */\n    function payGasForExpressCallWithToken(\n        address sender,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        string calldata symbol,\n        uint256 amount,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    ) external;\n\n    /**\n     * @notice Pay for gas using native currency for an express contract call on a destination chain.\n     * @dev This function is called on the source chain before calling the gateway to execute a remote contract.\n     * @param sender The address making the payment\n     * @param destinationChain The target chain where the contract call will be made\n     * @param destinationAddress The target address on the destination chain\n     * @param payload Data payload for the contract call\n     * @param refundAddress The address where refunds, if any, should be sent\n     */\n    function payNativeGasForExpressCall(\n        address sender,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        address refundAddress\n    ) external payable;\n\n    /**\n     * @notice Pay for gas using native currency for an express contract call with tokens on a destination chain.\n     * @dev This function is called on the source chain before calling the gateway to execute a remote contract.\n     * @param sender The address making the payment\n     * @param destinationChain The target chain where the contract call with tokens will be made\n     * @param destinationAddress The target address on the destination chain\n     * @param payload Data payload for the contract call with tokens\n     * @param symbol The symbol of the token to be sent with the call\n     * @param amount The amount of tokens to be sent with the call\n     * @param refundAddress The address where refunds, if any, should be sent\n     */\n    function payNativeGasForExpressCallWithToken(\n        address sender,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        string calldata symbol,\n        uint256 amount,\n        address refundAddress\n    ) external payable;\n\n    /**\n     * @notice Add additional gas payment using ERC20 tokens after initiating a cross-chain call.\n     * @dev This function can be called on the source chain after calling the gateway to execute a remote contract.\n     * @param txHash The transaction hash of the cross-chain call\n     * @param logIndex The log index for the cross-chain call\n     * @param gasToken The ERC20 token address used to add gas\n     * @param gasFeeAmount The amount of tokens to add as gas\n     * @param refundAddress The address where refunds, if any, should be sent\n     */\n    function addGas(\n        bytes32 txHash,\n        uint256 logIndex,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    ) external;\n\n    /**\n     * @notice Add additional gas payment using native currency after initiating a cross-chain call.\n     * @dev This function can be called on the source chain after calling the gateway to execute a remote contract.\n     * @param txHash The transaction hash of the cross-chain call\n     * @param logIndex The log index for the cross-chain call\n     * @param refundAddress The address where refunds, if any, should be sent\n     */\n    function addNativeGas(\n        bytes32 txHash,\n        uint256 logIndex,\n        address refundAddress\n    ) external payable;\n\n    /**\n     * @notice Add additional gas payment using ERC20 tokens after initiating an express cross-chain call.\n     * @dev This function can be called on the source chain after calling the gateway to express execute a remote contract.\n     * @param txHash The transaction hash of the cross-chain call\n     * @param logIndex The log index for the cross-chain call\n     * @param gasToken The ERC20 token address used to add gas\n     * @param gasFeeAmount The amount of tokens to add as gas\n     * @param refundAddress The address where refunds, if any, should be sent\n     */\n    function addExpressGas(\n        bytes32 txHash,\n        uint256 logIndex,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    ) external;\n\n    /**\n     * @notice Add additional gas payment using native currency after initiating an express cross-chain call.\n     * @dev This function can be called on the source chain after calling the gateway to express execute a remote contract.\n     * @param txHash The transaction hash of the cross-chain call\n     * @param logIndex The log index for the cross-chain call\n     * @param refundAddress The address where refunds, if any, should be sent\n     */\n    function addNativeExpressGas(\n        bytes32 txHash,\n        uint256 logIndex,\n        address refundAddress\n    ) external payable;\n\n    /**\n     * @notice Updates the gas price for a specific chain.\n     * @dev This function is called by the gas oracle to update the gas prices for a specific chains.\n     * @param chains Array of chain names\n     * @param gasUpdates Array of gas updates\n     */\n    function updateGasInfo(string[] calldata chains, GasInfo[] calldata gasUpdates) external;\n\n    /**\n     * @notice Allows the gasCollector to collect accumulated fees from the contract.\n     * @dev Use address(0) as the token address for native currency.\n     * @param receiver The address to receive the collected fees\n     * @param tokens Array of token addresses to be collected\n     * @param amounts Array of amounts to be collected for each respective token address\n     */\n    function collectFees(\n        address payable receiver,\n        address[] calldata tokens,\n        uint256[] calldata amounts\n    ) external;\n\n    /**\n     * @notice Refunds gas payment to the receiver in relation to a specific cross-chain transaction.\n     * @dev Only callable by the gasCollector.\n     * @dev Use address(0) as the token address to refund native currency.\n     * @param txHash The transaction hash of the cross-chain call\n     * @param logIndex The log index for the cross-chain call\n     * @param receiver The address to receive the refund\n     * @param token The token address to be refunded\n     * @param amount The amount to refund\n     */\n    function refund(\n        bytes32 txHash,\n        uint256 logIndex,\n        address payable receiver,\n        address token,\n        uint256 amount\n    ) external;\n\n    /**\n     * @notice Returns the address of the designated gas collector.\n     * @return address of the gas collector\n     */\n    function gasCollector() external returns (address);\n}\n"
    },
    "@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IAxelarGateway.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IGovernable } from './IGovernable.sol';\nimport { IImplementation } from './IImplementation.sol';\n\ninterface IAxelarGateway is IImplementation, IGovernable {\n    /**********\\\n    |* Errors *|\n    \\**********/\n\n    error NotSelf();\n    error InvalidCodeHash();\n    error SetupFailed();\n    error InvalidAuthModule();\n    error InvalidTokenDeployer();\n    error InvalidAmount();\n    error InvalidChainId();\n    error InvalidCommands();\n    error TokenDoesNotExist(string symbol);\n    error TokenAlreadyExists(string symbol);\n    error TokenDeployFailed(string symbol);\n    error TokenContractDoesNotExist(address token);\n    error BurnFailed(string symbol);\n    error MintFailed(string symbol);\n    error InvalidSetMintLimitsParams();\n    error ExceedMintLimit(string symbol);\n\n    /**********\\\n    |* Events *|\n    \\**********/\n\n    event TokenSent(\n        address indexed sender,\n        string destinationChain,\n        string destinationAddress,\n        string symbol,\n        uint256 amount\n    );\n\n    event ContractCall(\n        address indexed sender,\n        string destinationChain,\n        string destinationContractAddress,\n        bytes32 indexed payloadHash,\n        bytes payload\n    );\n\n    event ContractCallWithToken(\n        address indexed sender,\n        string destinationChain,\n        string destinationContractAddress,\n        bytes32 indexed payloadHash,\n        bytes payload,\n        string symbol,\n        uint256 amount\n    );\n\n    event Executed(bytes32 indexed commandId);\n\n    event TokenDeployed(string symbol, address tokenAddresses);\n\n    event ContractCallApproved(\n        bytes32 indexed commandId,\n        string sourceChain,\n        string sourceAddress,\n        address indexed contractAddress,\n        bytes32 indexed payloadHash,\n        bytes32 sourceTxHash,\n        uint256 sourceEventIndex\n    );\n\n    event ContractCallApprovedWithMint(\n        bytes32 indexed commandId,\n        string sourceChain,\n        string sourceAddress,\n        address indexed contractAddress,\n        bytes32 indexed payloadHash,\n        string symbol,\n        uint256 amount,\n        bytes32 sourceTxHash,\n        uint256 sourceEventIndex\n    );\n\n    event ContractCallExecuted(bytes32 indexed commandId);\n\n    event TokenMintLimitUpdated(string symbol, uint256 limit);\n\n    event OperatorshipTransferred(bytes newOperatorsData);\n\n    event Upgraded(address indexed implementation);\n\n    /********************\\\n    |* Public Functions *|\n    \\********************/\n\n    function sendToken(\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        string calldata symbol,\n        uint256 amount\n    ) external;\n\n    function callContract(\n        string calldata destinationChain,\n        string calldata contractAddress,\n        bytes calldata payload\n    ) external;\n\n    function callContractWithToken(\n        string calldata destinationChain,\n        string calldata contractAddress,\n        bytes calldata payload,\n        string calldata symbol,\n        uint256 amount\n    ) external;\n\n    function isContractCallApproved(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash\n    ) external view returns (bool);\n\n    function isContractCallAndMintApproved(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash,\n        string calldata symbol,\n        uint256 amount\n    ) external view returns (bool);\n\n    function validateContractCall(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes32 payloadHash\n    ) external returns (bool);\n\n    function validateContractCallAndMint(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes32 payloadHash,\n        string calldata symbol,\n        uint256 amount\n    ) external returns (bool);\n\n    /***********\\\n    |* Getters *|\n    \\***********/\n\n    function authModule() external view returns (address);\n\n    function tokenDeployer() external view returns (address);\n\n    function tokenMintLimit(string memory symbol) external view returns (uint256);\n\n    function tokenMintAmount(string memory symbol) external view returns (uint256);\n\n    function allTokensFrozen() external view returns (bool);\n\n    function implementation() external view returns (address);\n\n    function tokenAddresses(string memory symbol) external view returns (address);\n\n    function tokenFrozen(string memory symbol) external view returns (bool);\n\n    function isCommandExecuted(bytes32 commandId) external view returns (bool);\n\n    /************************\\\n    |* Governance Functions *|\n    \\************************/\n\n    function setTokenMintLimits(string[] calldata symbols, uint256[] calldata limits) external;\n\n    function upgrade(\n        address newImplementation,\n        bytes32 newImplementationCodeHash,\n        bytes calldata setupParams\n    ) external;\n\n    /**********************\\\n    |* External Functions *|\n    \\**********************/\n\n    function execute(bytes calldata input) external;\n}\n"
    },
    "@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IContractIdentifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// General interface for upgradable contracts\ninterface IContractIdentifier {\n    /**\n     * @notice Returns the contract ID. It can be used as a check during upgrades.\n     * @dev Meant to be overridden in derived contracts.\n     * @return bytes32 The contract ID\n     */\n    function contractId() external pure returns (bytes32);\n}\n"
    },
    "@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IGovernable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title IGovernable Interface\n * @notice This is an interface used by the AxelarGateway contract to manage governance and mint limiter roles.\n */\ninterface IGovernable {\n    error NotGovernance();\n    error NotMintLimiter();\n    error InvalidGovernance();\n    error InvalidMintLimiter();\n\n    event GovernanceTransferred(address indexed previousGovernance, address indexed newGovernance);\n    event MintLimiterTransferred(address indexed previousGovernance, address indexed newGovernance);\n\n    /**\n     * @notice Returns the governance address.\n     * @return address of the governance\n     */\n    function governance() external view returns (address);\n\n    /**\n     * @notice Returns the mint limiter address.\n     * @return address of the mint limiter\n     */\n    function mintLimiter() external view returns (address);\n\n    /**\n     * @notice Transfer the governance role to another address.\n     * @param newGovernance The new governance address\n     */\n    function transferGovernance(address newGovernance) external;\n\n    /**\n     * @notice Transfer the mint limiter role to another address.\n     * @param newGovernance The new mint limiter address\n     */\n    function transferMintLimiter(address newGovernance) external;\n}\n"
    },
    "@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IImplementation.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IContractIdentifier } from './IContractIdentifier.sol';\n\ninterface IImplementation is IContractIdentifier {\n    error NotProxy();\n\n    function setup(bytes calldata data) external;\n}\n"
    },
    "@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IInterchainGasEstimation.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { GasEstimationType, GasInfo } from '../types/GasEstimationTypes.sol';\n\n/**\n * @title IInterchainGasEstimation Interface\n * @notice This is an interface for the InterchainGasEstimation contract\n * which allows for estimating gas fees for cross-chain communication on the Axelar network.\n */\ninterface IInterchainGasEstimation {\n    error UnsupportedEstimationType(GasEstimationType gasEstimationType);\n\n    /**\n     * @notice Event emitted when the gas price for a specific chain is updated.\n     * @param chain The name of the chain\n     * @param info The gas info for the chain\n     */\n    event GasInfoUpdated(string chain, GasInfo info);\n\n    /**\n     * @notice Returns the gas price for a specific chain.\n     * @param chain The name of the chain\n     * @return gasInfo The gas info for the chain\n     */\n    function getGasInfo(string calldata chain) external view returns (GasInfo memory);\n\n    /**\n     * @notice Estimates the gas fee for a cross-chain contract call.\n     * @param destinationChain Axelar registered name of the destination chain\n     * @param destinationAddress Destination contract address being called\n     * @param executionGasLimit The gas limit to be used for the destination contract execution,\n     *        e.g. pass in 200k if your app consumes needs upto 200k for this contract call\n     * @param params Additional parameters for the gas estimation\n     * @return gasEstimate The cross-chain gas estimate, in terms of source chain's native gas token that should be forwarded to the gas service.\n     */\n    function estimateGasFee(\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        uint256 executionGasLimit,\n        bytes calldata params\n    ) external view returns (uint256 gasEstimate);\n}\n"
    },
    "@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title IOwnable Interface\n * @notice IOwnable is an interface that abstracts the implementation of a\n * contract with ownership control features. It's commonly used in upgradable\n * contracts and includes the functionality to get current owner, transfer\n * ownership, and propose and accept ownership.\n */\ninterface IOwnable {\n    error NotOwner();\n    error InvalidOwner();\n    error InvalidOwnerAddress();\n\n    event OwnershipTransferStarted(address indexed newOwner);\n    event OwnershipTransferred(address indexed newOwner);\n\n    /**\n     * @notice Returns the current owner of the contract.\n     * @return address The address of the current owner\n     */\n    function owner() external view returns (address);\n\n    /**\n     * @notice Returns the address of the pending owner of the contract.\n     * @return address The address of the pending owner\n     */\n    function pendingOwner() external view returns (address);\n\n    /**\n     * @notice Transfers ownership of the contract to a new address\n     * @param newOwner The address to transfer ownership to\n     */\n    function transferOwnership(address newOwner) external;\n\n    /**\n     * @notice Proposes to transfer the contract's ownership to a new address.\n     * The new owner needs to accept the ownership explicitly.\n     * @param newOwner The address to transfer ownership to\n     */\n    function proposeOwnership(address newOwner) external;\n\n    /**\n     * @notice Transfers ownership to the pending owner.\n     * @dev Can only be called by the pending owner\n     */\n    function acceptOwnership() external;\n}\n"
    },
    "@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IUpgradable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IOwnable } from './IOwnable.sol';\nimport { IImplementation } from './IImplementation.sol';\n\n// General interface for upgradable contracts\ninterface IUpgradable is IOwnable, IImplementation {\n    error InvalidCodeHash();\n    error InvalidImplementation();\n    error SetupFailed();\n\n    event Upgraded(address indexed newImplementation);\n\n    function implementation() external view returns (address);\n\n    function upgrade(\n        address newImplementation,\n        bytes32 newImplementationCodeHash,\n        bytes calldata params\n    ) external;\n}\n"
    },
    "@axelar-network/axelar-gmp-sdk-solidity/contracts/types/GasEstimationTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title GasEstimationType\n * @notice This enum represents the gas estimation types for different chains.\n */\nenum GasEstimationType {\n    Default,\n    OptimismEcotone,\n    OptimismBedrock,\n    Arbitrum,\n    Scroll\n}\n\n/**\n * @title GasInfo\n * @notice This struct represents the gas pricing information for a specific chain.\n * @dev Smaller uint types are used for efficient struct packing to save storage costs.\n */\nstruct GasInfo {\n    /// @dev Custom gas pricing rule, such as L1 data fee on L2s\n    uint64 gasEstimationType;\n    /// @dev Scalar value needed for specific gas estimation types, expected to be less than 1e10\n    uint64 l1FeeScalar;\n    /// @dev Axelar base fee for cross-chain message approval on destination, in terms of source native gas token\n    uint128 axelarBaseFee;\n    /// @dev Gas price of destination chain, in terms of the source chain token, i.e dest_gas_price * dest_token_market_price / src_token_market_price\n    uint128 relativeGasPrice;\n    /// @dev Needed for specific gas estimation types. Blob base fee of destination chain, in terms of the source chain token, i.e dest_blob_base_fee * dest_token_market_price / src_token_market_price\n    uint128 relativeBlobBaseFee;\n    /// @dev Axelar express fee for express execution, in terms of source chain token\n    uint128 expressFee;\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IAny2EVMMessageReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Client} from \"../libraries/Client.sol\";\n\n/// @notice Application contracts that intend to receive messages from\n/// the router should implement this interface.\ninterface IAny2EVMMessageReceiver {\n  /// @notice Called by the Router to deliver a message.\n  /// If this reverts, any token transfers also revert. The message\n  /// will move to a FAILED state and become available for manual execution.\n  /// @param message CCIP Message\n  /// @dev Note ensure you check the msg.sender is the OffRampRouter\n  function ccipReceive(Client.Any2EVMMessage calldata message) external;\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Client} from \"../libraries/Client.sol\";\n\ninterface IRouterClient {\n  error UnsupportedDestinationChain(uint64 destChainSelector);\n  error InsufficientFeeTokenAmount();\n  error InvalidMsgValue();\n\n  /// @notice Checks if the given chain ID is supported for sending/receiving.\n  /// @param chainSelector The chain to check.\n  /// @return supported is true if it is supported, false if not.\n  function isChainSupported(uint64 chainSelector) external view returns (bool supported);\n\n  /// @notice Gets a list of all supported tokens which can be sent or received\n  /// to/from a given chain id.\n  /// @param chainSelector The chainSelector.\n  /// @return tokens The addresses of all tokens that are supported.\n  function getSupportedTokens(uint64 chainSelector) external view returns (address[] memory tokens);\n\n  /// @param destinationChainSelector The destination chainSelector\n  /// @param message The cross-chain CCIP message including data and/or tokens\n  /// @return fee returns guaranteed execution fee for the specified message\n  /// delivery to destination chain\n  /// @dev returns 0 fee on invalid message.\n  function getFee(\n    uint64 destinationChainSelector,\n    Client.EVM2AnyMessage memory message\n  ) external view returns (uint256 fee);\n\n  /// @notice Request a message to be sent to the destination chain\n  /// @param destinationChainSelector The destination chain ID\n  /// @param message The cross-chain CCIP message including data and/or tokens\n  /// @return messageId The message ID\n  /// @dev Note if msg.value is larger than the required fee (from getFee) we accept\n  /// the overpayment with no refund.\n  function ccipSend(\n    uint64 destinationChainSelector,\n    Client.EVM2AnyMessage calldata message\n  ) external payable returns (bytes32);\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// End consumer library.\nlibrary Client {\n  struct EVMTokenAmount {\n    address token; // token address on the local chain.\n    uint256 amount; // Amount of tokens.\n  }\n\n  struct Any2EVMMessage {\n    bytes32 messageId; // MessageId corresponding to ccipSend on source.\n    uint64 sourceChainSelector; // Source chain selector.\n    bytes sender; // abi.decode(sender) if coming from an EVM chain.\n    bytes data; // payload sent in original message.\n    EVMTokenAmount[] destTokenAmounts; // Tokens and their amounts in their destination chain representation.\n  }\n\n  // If extraArgs is empty bytes, the default is 200k gas limit and strict = false.\n  struct EVM2AnyMessage {\n    bytes receiver; // abi.encode(receiver address) for dest EVM chains\n    bytes data; // Data payload\n    EVMTokenAmount[] tokenAmounts; // Token transfers\n    address feeToken; // Address of feeToken. address(0) means you will send msg.value.\n    bytes extraArgs; // Populate this with _argsToBytes(EVMExtraArgsV1)\n  }\n\n  // extraArgs will evolve to support new features\n  // bytes4(keccak256(\"CCIP EVMExtraArgsV1\"));\n  bytes4 public constant EVM_EXTRA_ARGS_V1_TAG = 0x97a657c9;\n  struct EVMExtraArgsV1 {\n    uint256 gasLimit; // ATTENTION!!! MAX GAS LIMIT 4M FOR BETA TESTING\n    bool strict; // See strict sequencing details below.\n  }\n\n  function _argsToBytes(EVMExtraArgsV1 memory extraArgs) internal pure returns (bytes memory bts) {\n    return abi.encodeWithSelector(EVM_EXTRA_ARGS_V1_TAG, extraArgs);\n  }\n}\n"
    },
    "@eth-optimism/contracts/libraries/bridge/ICrossDomainMessenger.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.9.0;\n\n/**\n * @title ICrossDomainMessenger\n */\ninterface ICrossDomainMessenger {\n    /**********\n     * Events *\n     **********/\n\n    event SentMessage(\n        address indexed target,\n        address sender,\n        bytes message,\n        uint256 messageNonce,\n        uint256 gasLimit\n    );\n    event RelayedMessage(bytes32 indexed msgHash);\n    event FailedRelayedMessage(bytes32 indexed msgHash);\n\n    /*************\n     * Variables *\n     *************/\n\n    function xDomainMessageSender() external view returns (address);\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * Sends a cross domain message to the target messenger.\n     * @param _target Target contract address.\n     * @param _message Message to send to the target.\n     * @param _gasLimit Gas limit for the provided message.\n     */\n    function sendMessage(\n        address _target,\n        bytes calldata _message,\n        uint32 _gasLimit\n    ) external;\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/EndpointV2View.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { Proxied } from \"hardhat-deploy/solc_0.8/proxy/Proxied.sol\";\nimport \"./EndpointV2ViewUpgradeable.sol\";\n\ncontract EndpointV2View is EndpointV2ViewUpgradeable, Proxied {\n    function initialize(address _endpoint) external proxied initializer {\n        __EndpointV2View_init(_endpoint);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/EndpointV2ViewUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport \"./interfaces/ILayerZeroEndpointV2.sol\";\n\nenum ExecutionState {\n    NotExecutable, // executor: waits for PayloadVerified event and starts polling for executable\n    VerifiedButNotExecutable, // executor: starts active polling for executable\n    Executable,\n    Executed\n}\n\ncontract EndpointV2ViewUpgradeable is Initializable {\n    bytes32 public constant EMPTY_PAYLOAD_HASH = bytes32(0);\n    bytes32 public constant NIL_PAYLOAD_HASH = bytes32(type(uint256).max);\n\n    ILayerZeroEndpointV2 public endpoint;\n\n    function __EndpointV2View_init(address _endpoint) internal onlyInitializing {\n        __EndpointV2View_init_unchained(_endpoint);\n    }\n\n    function __EndpointV2View_init_unchained(address _endpoint) internal onlyInitializing {\n        endpoint = ILayerZeroEndpointV2(_endpoint);\n    }\n\n    function initializable(Origin memory _origin, address _receiver) public view returns (bool) {\n        try endpoint.initializable(_origin, _receiver) returns (bool _initializable) {\n            return _initializable;\n        } catch {\n            return false;\n        }\n    }\n\n    /// @dev check if a message is verifiable.\n    function verifiable(\n        Origin memory _origin,\n        address _receiver,\n        address _receiveLib,\n        bytes32 _payloadHash\n    ) public view returns (bool) {\n        if (!endpoint.isValidReceiveLibrary(_receiver, _origin.srcEid, _receiveLib)) return false;\n\n        if (!endpoint.verifiable(_origin, _receiver)) return false;\n\n        // checked in _inbound for verify\n        if (_payloadHash == EMPTY_PAYLOAD_HASH) return false;\n\n        return true;\n    }\n\n    /// @dev check if a message is executable.\n    /// @return ExecutionState of Executed, Executable, or NotExecutable\n    function executable(Origin memory _origin, address _receiver) public view returns (ExecutionState) {\n        bytes32 payloadHash = endpoint.inboundPayloadHash(_receiver, _origin.srcEid, _origin.sender, _origin.nonce);\n\n        // executed if the payload hash has been cleared and the nonce is less than or equal to lazyInboundNonce\n        if (\n            payloadHash == EMPTY_PAYLOAD_HASH &&\n            _origin.nonce <= endpoint.lazyInboundNonce(_receiver, _origin.srcEid, _origin.sender)\n        ) {\n            return ExecutionState.Executed;\n        }\n\n        // executable if nonce has not been executed and has not been nilified and nonce is less than or equal to inboundNonce\n        if (\n            payloadHash != NIL_PAYLOAD_HASH &&\n            _origin.nonce <= endpoint.inboundNonce(_receiver, _origin.srcEid, _origin.sender)\n        ) {\n            return ExecutionState.Executable;\n        }\n\n        // only start active executable polling if payload hash is not empty nor nil\n        if (payloadHash != EMPTY_PAYLOAD_HASH && payloadHash != NIL_PAYLOAD_HASH) {\n            return ExecutionState.VerifiedButNotExecutable;\n        }\n\n        // return NotExecutable as a catch-all\n        return ExecutionState.NotExecutable;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport { IMessageLibManager } from \"./IMessageLibManager.sol\";\nimport { IMessagingComposer } from \"./IMessagingComposer.sol\";\nimport { IMessagingChannel } from \"./IMessagingChannel.sol\";\nimport { IMessagingContext } from \"./IMessagingContext.sol\";\n\nstruct MessagingParams {\n    uint32 dstEid;\n    bytes32 receiver;\n    bytes message;\n    bytes options;\n    bool payInLzToken;\n}\n\nstruct MessagingReceipt {\n    bytes32 guid;\n    uint64 nonce;\n    MessagingFee fee;\n}\n\nstruct MessagingFee {\n    uint256 nativeFee;\n    uint256 lzTokenFee;\n}\n\nstruct Origin {\n    uint32 srcEid;\n    bytes32 sender;\n    uint64 nonce;\n}\n\ninterface ILayerZeroEndpointV2 is IMessageLibManager, IMessagingComposer, IMessagingChannel, IMessagingContext {\n    event PacketSent(bytes encodedPayload, bytes options, address sendLibrary);\n\n    event PacketVerified(Origin origin, address receiver, bytes32 payloadHash);\n\n    event PacketDelivered(Origin origin, address receiver);\n\n    event LzReceiveAlert(\n        address indexed receiver,\n        address indexed executor,\n        Origin origin,\n        bytes32 guid,\n        uint256 gas,\n        uint256 value,\n        bytes message,\n        bytes extraData,\n        bytes reason\n    );\n\n    event LzTokenSet(address token);\n\n    event DelegateSet(address sender, address delegate);\n\n    function quote(MessagingParams calldata _params, address _sender) external view returns (MessagingFee memory);\n\n    function send(\n        MessagingParams calldata _params,\n        address _refundAddress\n    ) external payable returns (MessagingReceipt memory);\n\n    function verify(Origin calldata _origin, address _receiver, bytes32 _payloadHash) external;\n\n    function verifiable(Origin calldata _origin, address _receiver) external view returns (bool);\n\n    function initializable(Origin calldata _origin, address _receiver) external view returns (bool);\n\n    function lzReceive(\n        Origin calldata _origin,\n        address _receiver,\n        bytes32 _guid,\n        bytes calldata _message,\n        bytes calldata _extraData\n    ) external payable;\n\n    // oapp can burn messages partially by calling this function with its own business logic if messages are verified in order\n    function clear(address _oapp, Origin calldata _origin, bytes32 _guid, bytes calldata _message) external;\n\n    function setLzToken(address _lzToken) external;\n\n    function lzToken() external view returns (address);\n\n    function nativeToken() external view returns (address);\n\n    function setDelegate(address _delegate) external;\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessageLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport { SetConfigParam } from \"./IMessageLibManager.sol\";\n\nenum MessageLibType {\n    Send,\n    Receive,\n    SendAndReceive\n}\n\ninterface IMessageLib is IERC165 {\n    function setConfig(address _oapp, SetConfigParam[] calldata _config) external;\n\n    function getConfig(uint32 _eid, address _oapp, uint32 _configType) external view returns (bytes memory config);\n\n    function isSupportedEid(uint32 _eid) external view returns (bool);\n\n    // message libs of same major version are compatible\n    function version() external view returns (uint64 major, uint8 minor, uint8 endpointVersion);\n\n    function messageLibType() external view returns (MessageLibType);\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessageLibManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nstruct SetConfigParam {\n    uint32 eid;\n    uint32 configType;\n    bytes config;\n}\n\ninterface IMessageLibManager {\n    struct Timeout {\n        address lib;\n        uint256 expiry;\n    }\n\n    event LibraryRegistered(address newLib);\n    event DefaultSendLibrarySet(uint32 eid, address newLib);\n    event DefaultReceiveLibrarySet(uint32 eid, address newLib);\n    event DefaultReceiveLibraryTimeoutSet(uint32 eid, address oldLib, uint256 expiry);\n    event SendLibrarySet(address sender, uint32 eid, address newLib);\n    event ReceiveLibrarySet(address receiver, uint32 eid, address newLib);\n    event ReceiveLibraryTimeoutSet(address receiver, uint32 eid, address oldLib, uint256 timeout);\n\n    function registerLibrary(address _lib) external;\n\n    function isRegisteredLibrary(address _lib) external view returns (bool);\n\n    function getRegisteredLibraries() external view returns (address[] memory);\n\n    function setDefaultSendLibrary(uint32 _eid, address _newLib) external;\n\n    function defaultSendLibrary(uint32 _eid) external view returns (address);\n\n    function setDefaultReceiveLibrary(uint32 _eid, address _newLib, uint256 _gracePeriod) external;\n\n    function defaultReceiveLibrary(uint32 _eid) external view returns (address);\n\n    function setDefaultReceiveLibraryTimeout(uint32 _eid, address _lib, uint256 _expiry) external;\n\n    function defaultReceiveLibraryTimeout(uint32 _eid) external view returns (address lib, uint256 expiry);\n\n    function isSupportedEid(uint32 _eid) external view returns (bool);\n\n    function isValidReceiveLibrary(address _receiver, uint32 _eid, address _lib) external view returns (bool);\n\n    /// ------------------- OApp interfaces -------------------\n    function setSendLibrary(address _oapp, uint32 _eid, address _newLib) external;\n\n    function getSendLibrary(address _sender, uint32 _eid) external view returns (address lib);\n\n    function isDefaultSendLibrary(address _sender, uint32 _eid) external view returns (bool);\n\n    function setReceiveLibrary(address _oapp, uint32 _eid, address _newLib, uint256 _gracePeriod) external;\n\n    function getReceiveLibrary(address _receiver, uint32 _eid) external view returns (address lib, bool isDefault);\n\n    function setReceiveLibraryTimeout(address _oapp, uint32 _eid, address _lib, uint256 _expiry) external;\n\n    function receiveLibraryTimeout(address _receiver, uint32 _eid) external view returns (address lib, uint256 expiry);\n\n    function setConfig(address _oapp, address _lib, SetConfigParam[] calldata _params) external;\n\n    function getConfig(\n        address _oapp,\n        address _lib,\n        uint32 _eid,\n        uint32 _configType\n    ) external view returns (bytes memory config);\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingChannel.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface IMessagingChannel {\n    event InboundNonceSkipped(uint32 srcEid, bytes32 sender, address receiver, uint64 nonce);\n    event PacketNilified(uint32 srcEid, bytes32 sender, address receiver, uint64 nonce, bytes32 payloadHash);\n    event PacketBurnt(uint32 srcEid, bytes32 sender, address receiver, uint64 nonce, bytes32 payloadHash);\n\n    function eid() external view returns (uint32);\n\n    // this is an emergency function if a message cannot be verified for some reasons\n    // required to provide _nextNonce to avoid race condition\n    function skip(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce) external;\n\n    function nilify(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce, bytes32 _payloadHash) external;\n\n    function burn(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce, bytes32 _payloadHash) external;\n\n    function nextGuid(address _sender, uint32 _dstEid, bytes32 _receiver) external view returns (bytes32);\n\n    function inboundNonce(address _receiver, uint32 _srcEid, bytes32 _sender) external view returns (uint64);\n\n    function outboundNonce(address _sender, uint32 _dstEid, bytes32 _receiver) external view returns (uint64);\n\n    function inboundPayloadHash(\n        address _receiver,\n        uint32 _srcEid,\n        bytes32 _sender,\n        uint64 _nonce\n    ) external view returns (bytes32);\n\n    function lazyInboundNonce(address _receiver, uint32 _srcEid, bytes32 _sender) external view returns (uint64);\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingComposer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface IMessagingComposer {\n    event ComposeSent(address from, address to, bytes32 guid, uint16 index, bytes message);\n    event ComposeDelivered(address from, address to, bytes32 guid, uint16 index);\n    event LzComposeAlert(\n        address indexed from,\n        address indexed to,\n        address indexed executor,\n        bytes32 guid,\n        uint16 index,\n        uint256 gas,\n        uint256 value,\n        bytes message,\n        bytes extraData,\n        bytes reason\n    );\n\n    function composeQueue(\n        address _from,\n        address _to,\n        bytes32 _guid,\n        uint16 _index\n    ) external view returns (bytes32 messageHash);\n\n    function sendCompose(address _to, bytes32 _guid, uint16 _index, bytes calldata _message) external;\n\n    function lzCompose(\n        address _from,\n        address _to,\n        bytes32 _guid,\n        uint16 _index,\n        bytes calldata _message,\n        bytes calldata _extraData\n    ) external payable;\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingContext.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface IMessagingContext {\n    function isSendingMessage() external view returns (bool);\n\n    function getSendContext() external view returns (uint32 dstEid, address sender);\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ISendLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport { MessagingFee } from \"./ILayerZeroEndpointV2.sol\";\nimport { IMessageLib } from \"./IMessageLib.sol\";\n\nstruct Packet {\n    uint64 nonce;\n    uint32 srcEid;\n    address sender;\n    uint32 dstEid;\n    bytes32 receiver;\n    bytes32 guid;\n    bytes message;\n}\n\ninterface ISendLib is IMessageLib {\n    function send(\n        Packet calldata _packet,\n        bytes calldata _options,\n        bool _payInLzToken\n    ) external returns (MessagingFee memory, bytes memory encodedPacket);\n\n    function quote(\n        Packet calldata _packet,\n        bytes calldata _options,\n        bool _payInLzToken\n    ) external view returns (MessagingFee memory);\n\n    function setTreasury(address _treasury) external;\n\n    function withdrawFee(address _to, uint256 _amount) external;\n\n    function withdrawLzTokenFee(address _lzToken, address _to, uint256 _amount) external;\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/libs/AddressCast.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nlibrary AddressCast {\n    error AddressCast_InvalidSizeForAddress();\n    error AddressCast_InvalidAddress();\n\n    function toBytes32(bytes calldata _addressBytes) internal pure returns (bytes32 result) {\n        if (_addressBytes.length > 32) revert AddressCast_InvalidAddress();\n        result = bytes32(_addressBytes);\n        unchecked {\n            uint256 offset = 32 - _addressBytes.length;\n            result = result >> (offset * 8);\n        }\n    }\n\n    function toBytes32(address _address) internal pure returns (bytes32 result) {\n        result = bytes32(uint256(uint160(_address)));\n    }\n\n    function toBytes(bytes32 _addressBytes32, uint256 _size) internal pure returns (bytes memory result) {\n        if (_size == 0 || _size > 32) revert AddressCast_InvalidSizeForAddress();\n        result = new bytes(_size);\n        unchecked {\n            uint256 offset = 256 - _size * 8;\n            assembly {\n                mstore(add(result, 32), shl(offset, _addressBytes32))\n            }\n        }\n    }\n\n    function toAddress(bytes32 _addressBytes32) internal pure returns (address result) {\n        result = address(uint160(uint256(_addressBytes32)));\n    }\n\n    function toAddress(bytes calldata _addressBytes) internal pure returns (address result) {\n        if (_addressBytes.length != 20) revert AddressCast_InvalidAddress();\n        result = address(bytes20(_addressBytes));\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/libs/CalldataBytesLib.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nlibrary CalldataBytesLib {\n    function toU8(bytes calldata _bytes, uint256 _start) internal pure returns (uint8) {\n        return uint8(_bytes[_start]);\n    }\n\n    function toU16(bytes calldata _bytes, uint256 _start) internal pure returns (uint16) {\n        unchecked {\n            uint256 end = _start + 2;\n            return uint16(bytes2(_bytes[_start:end]));\n        }\n    }\n\n    function toU32(bytes calldata _bytes, uint256 _start) internal pure returns (uint32) {\n        unchecked {\n            uint256 end = _start + 4;\n            return uint32(bytes4(_bytes[_start:end]));\n        }\n    }\n\n    function toU64(bytes calldata _bytes, uint256 _start) internal pure returns (uint64) {\n        unchecked {\n            uint256 end = _start + 8;\n            return uint64(bytes8(_bytes[_start:end]));\n        }\n    }\n\n    function toU128(bytes calldata _bytes, uint256 _start) internal pure returns (uint128) {\n        unchecked {\n            uint256 end = _start + 16;\n            return uint128(bytes16(_bytes[_start:end]));\n        }\n    }\n\n    function toU256(bytes calldata _bytes, uint256 _start) internal pure returns (uint256) {\n        unchecked {\n            uint256 end = _start + 32;\n            return uint256(bytes32(_bytes[_start:end]));\n        }\n    }\n\n    function toAddr(bytes calldata _bytes, uint256 _start) internal pure returns (address) {\n        unchecked {\n            uint256 end = _start + 20;\n            return address(bytes20(_bytes[_start:end]));\n        }\n    }\n\n    function toB32(bytes calldata _bytes, uint256 _start) internal pure returns (bytes32) {\n        unchecked {\n            uint256 end = _start + 32;\n            return bytes32(_bytes[_start:end]);\n        }\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/libs/GUID.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { AddressCast } from \"./AddressCast.sol\";\n\nlibrary GUID {\n    using AddressCast for address;\n\n    function generate(\n        uint64 _nonce,\n        uint32 _srcEid,\n        address _sender,\n        uint32 _dstEid,\n        bytes32 _receiver\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_nonce, _srcEid, _sender.toBytes32(), _dstEid, _receiver));\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/libs/Transfer.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nlibrary Transfer {\n    using SafeERC20 for IERC20;\n\n    address internal constant ADDRESS_ZERO = address(0);\n\n    error Transfer_NativeFailed(address _to, uint256 _value);\n    error Transfer_ToAddressIsZero();\n\n    function native(address _to, uint256 _value) internal {\n        if (_to == ADDRESS_ZERO) revert Transfer_ToAddressIsZero();\n        (bool success, ) = _to.call{ value: _value }(\"\");\n        if (!success) revert Transfer_NativeFailed(_to, _value);\n    }\n\n    function token(address _token, address _to, uint256 _value) internal {\n        if (_to == ADDRESS_ZERO) revert Transfer_ToAddressIsZero();\n        IERC20(_token).safeTransfer(_to, _value);\n    }\n\n    function nativeOrToken(address _token, address _to, uint256 _value) internal {\n        if (_token == ADDRESS_ZERO) {\n            native(_to, _value);\n        } else {\n            token(_token, _to, _value);\n        }\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/BitMaps.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// modified from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/structs/BitMaps.sol\npragma solidity ^0.8.20;\n\ntype BitMap256 is uint256;\n\nusing BitMaps for BitMap256 global;\n\nlibrary BitMaps {\n    /**\n     * @dev Returns whether the bit at `index` is set.\n     */\n    function get(BitMap256 bitmap, uint8 index) internal pure returns (bool) {\n        uint256 mask = 1 << index;\n        return BitMap256.unwrap(bitmap) & mask != 0;\n    }\n\n    /**\n     * @dev Sets the bit at `index`.\n     */\n    function set(BitMap256 bitmap, uint8 index) internal pure returns (BitMap256) {\n        uint256 mask = 1 << index;\n        return BitMap256.wrap(BitMap256.unwrap(bitmap) | mask);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/ExecutorOptions.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { CalldataBytesLib } from \"../../libs/CalldataBytesLib.sol\";\n\nlibrary ExecutorOptions {\n    using CalldataBytesLib for bytes;\n\n    uint8 internal constant WORKER_ID = 1;\n\n    uint8 internal constant OPTION_TYPE_LZRECEIVE = 1;\n    uint8 internal constant OPTION_TYPE_NATIVE_DROP = 2;\n    uint8 internal constant OPTION_TYPE_LZCOMPOSE = 3;\n    uint8 internal constant OPTION_TYPE_ORDERED_EXECUTION = 4;\n\n    error Executor_InvalidLzReceiveOption();\n    error Executor_InvalidNativeDropOption();\n    error Executor_InvalidLzComposeOption();\n\n    /// @dev decode the next executor option from the options starting from the specified cursor\n    /// @param _options [executor_id][executor_option][executor_id][executor_option]...\n    ///        executor_option = [option_size][option_type][option]\n    ///        option_size = len(option_type) + len(option)\n    ///        executor_id: uint8, option_size: uint16, option_type: uint8, option: bytes\n    /// @param _cursor the cursor to start decoding from\n    /// @return optionType the type of the option\n    /// @return option the option of the executor\n    /// @return cursor the cursor to start decoding the next executor option\n    function nextExecutorOption(\n        bytes calldata _options,\n        uint256 _cursor\n    ) internal pure returns (uint8 optionType, bytes calldata option, uint256 cursor) {\n        unchecked {\n            // skip worker id\n            cursor = _cursor + 1;\n\n            // read option size\n            uint16 size = _options.toU16(cursor);\n            cursor += 2;\n\n            // read option type\n            optionType = _options.toU8(cursor);\n\n            // startCursor and endCursor are used to slice the option from _options\n            uint256 startCursor = cursor + 1; // skip option type\n            uint256 endCursor = cursor + size;\n            option = _options[startCursor:endCursor];\n            cursor += size;\n        }\n    }\n\n    function decodeLzReceiveOption(bytes calldata _option) internal pure returns (uint128 gas, uint128 value) {\n        if (_option.length != 16 && _option.length != 32) revert Executor_InvalidLzReceiveOption();\n        gas = _option.toU128(0);\n        value = _option.length == 32 ? _option.toU128(16) : 0;\n    }\n\n    function decodeNativeDropOption(bytes calldata _option) internal pure returns (uint128 amount, bytes32 receiver) {\n        if (_option.length != 48) revert Executor_InvalidNativeDropOption();\n        amount = _option.toU128(0);\n        receiver = _option.toB32(16);\n    }\n\n    function decodeLzComposeOption(\n        bytes calldata _option\n    ) internal pure returns (uint16 index, uint128 gas, uint128 value) {\n        if (_option.length != 18 && _option.length != 34) revert Executor_InvalidLzComposeOption();\n        index = _option.toU16(0);\n        gas = _option.toU128(2);\n        value = _option.length == 34 ? _option.toU128(18) : 0;\n    }\n\n    function encodeLzReceiveOption(uint128 _gas, uint128 _value) internal pure returns (bytes memory) {\n        return _value == 0 ? abi.encodePacked(_gas) : abi.encodePacked(_gas, _value);\n    }\n\n    function encodeNativeDropOption(uint128 _amount, bytes32 _receiver) internal pure returns (bytes memory) {\n        return abi.encodePacked(_amount, _receiver);\n    }\n\n    function encodeLzComposeOption(uint16 _index, uint128 _gas, uint128 _value) internal pure returns (bytes memory) {\n        return _value == 0 ? abi.encodePacked(_index, _gas) : abi.encodePacked(_index, _gas, _value);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/PacketV1Codec.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { Packet } from \"../../interfaces/ISendLib.sol\";\nimport { AddressCast } from \"../../libs/AddressCast.sol\";\n\nlibrary PacketV1Codec {\n    using AddressCast for address;\n    using AddressCast for bytes32;\n\n    uint8 internal constant PACKET_VERSION = 1;\n\n    // header (version + nonce + path)\n    // version\n    uint256 private constant PACKET_VERSION_OFFSET = 0;\n    //    nonce\n    uint256 private constant NONCE_OFFSET = 1;\n    //    path\n    uint256 private constant SRC_EID_OFFSET = 9;\n    uint256 private constant SENDER_OFFSET = 13;\n    uint256 private constant DST_EID_OFFSET = 45;\n    uint256 private constant RECEIVER_OFFSET = 49;\n    // payload (guid + message)\n    uint256 private constant GUID_OFFSET = 81; // keccak256(nonce + path)\n    uint256 private constant MESSAGE_OFFSET = 113;\n\n    function encode(Packet memory _packet) internal pure returns (bytes memory encodedPacket) {\n        encodedPacket = abi.encodePacked(\n            PACKET_VERSION,\n            _packet.nonce,\n            _packet.srcEid,\n            _packet.sender.toBytes32(),\n            _packet.dstEid,\n            _packet.receiver,\n            _packet.guid,\n            _packet.message\n        );\n    }\n\n    function encodePacketHeader(Packet memory _packet) internal pure returns (bytes memory) {\n        return\n            abi.encodePacked(\n                PACKET_VERSION,\n                _packet.nonce,\n                _packet.srcEid,\n                _packet.sender.toBytes32(),\n                _packet.dstEid,\n                _packet.receiver\n            );\n    }\n\n    function encodePayload(Packet memory _packet) internal pure returns (bytes memory) {\n        return abi.encodePacked(_packet.guid, _packet.message);\n    }\n\n    function header(bytes calldata _packet) internal pure returns (bytes calldata) {\n        return _packet[0:GUID_OFFSET];\n    }\n\n    function version(bytes calldata _packet) internal pure returns (uint8) {\n        return uint8(bytes1(_packet[PACKET_VERSION_OFFSET:NONCE_OFFSET]));\n    }\n\n    function nonce(bytes calldata _packet) internal pure returns (uint64) {\n        return uint64(bytes8(_packet[NONCE_OFFSET:SRC_EID_OFFSET]));\n    }\n\n    function srcEid(bytes calldata _packet) internal pure returns (uint32) {\n        return uint32(bytes4(_packet[SRC_EID_OFFSET:SENDER_OFFSET]));\n    }\n\n    function sender(bytes calldata _packet) internal pure returns (bytes32) {\n        return bytes32(_packet[SENDER_OFFSET:DST_EID_OFFSET]);\n    }\n\n    function senderAddressB20(bytes calldata _packet) internal pure returns (address) {\n        return sender(_packet).toAddress();\n    }\n\n    function dstEid(bytes calldata _packet) internal pure returns (uint32) {\n        return uint32(bytes4(_packet[DST_EID_OFFSET:RECEIVER_OFFSET]));\n    }\n\n    function receiver(bytes calldata _packet) internal pure returns (bytes32) {\n        return bytes32(_packet[RECEIVER_OFFSET:GUID_OFFSET]);\n    }\n\n    function receiverB20(bytes calldata _packet) internal pure returns (address) {\n        return receiver(_packet).toAddress();\n    }\n\n    function guid(bytes calldata _packet) internal pure returns (bytes32) {\n        return bytes32(_packet[GUID_OFFSET:MESSAGE_OFFSET]);\n    }\n\n    function message(bytes calldata _packet) internal pure returns (bytes calldata) {\n        return bytes(_packet[MESSAGE_OFFSET:]);\n    }\n\n    function payload(bytes calldata _packet) internal pure returns (bytes calldata) {\n        return bytes(_packet[GUID_OFFSET:]);\n    }\n\n    function payloadHash(bytes calldata _packet) internal pure returns (bytes32) {\n        return keccak256(payload(_packet));\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/interfaces/ILayerZeroEndpoint.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.5.0;\n\nimport \"./ILayerZeroUserApplicationConfig.sol\";\n\ninterface ILayerZeroEndpoint is ILayerZeroUserApplicationConfig {\n    // @notice send a LayerZero message to the specified address at a LayerZero endpoint.\n    // @param _dstChainId - the destination chain identifier\n    // @param _destination - the address on destination chain (in bytes). address length/format may vary by chains\n    // @param _payload - a custom bytes payload to send to the destination contract\n    // @param _refundAddress - if the source transaction is cheaper than the amount of value passed, refund the additional amount to this address\n    // @param _zroPaymentAddress - the address of the ZRO token holder who would pay for the transaction\n    // @param _adapterParams - parameters for custom functionality. e.g. receive airdropped native gas from the relayer on destination\n    function send(\n        uint16 _dstChainId,\n        bytes calldata _destination,\n        bytes calldata _payload,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes calldata _adapterParams\n    ) external payable;\n\n    // @notice used by the messaging library to publish verified payload\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source contract (as bytes) at the source chain\n    // @param _dstAddress - the address on destination chain\n    // @param _nonce - the unbound message ordering nonce\n    // @param _gasLimit - the gas limit for external contract execution\n    // @param _payload - verified payload to send to the destination contract\n    function receivePayload(\n        uint16 _srcChainId,\n        bytes calldata _srcAddress,\n        address _dstAddress,\n        uint64 _nonce,\n        uint _gasLimit,\n        bytes calldata _payload\n    ) external;\n\n    // @notice get the inboundNonce of a receiver from a source chain which could be EVM or non-EVM chain\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    function getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (uint64);\n\n    // @notice get the outboundNonce from this source chain which, consequently, is always an EVM\n    // @param _srcAddress - the source chain contract address\n    function getOutboundNonce(uint16 _dstChainId, address _srcAddress) external view returns (uint64);\n\n    // @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\n    // @param _dstChainId - the destination chain identifier\n    // @param _userApplication - the user app address on this EVM chain\n    // @param _payload - the custom message to send over LayerZero\n    // @param _payInZRO - if false, user app pays the protocol fee in native token\n    // @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain\n    function estimateFees(\n        uint16 _dstChainId,\n        address _userApplication,\n        bytes calldata _payload,\n        bool _payInZRO,\n        bytes calldata _adapterParam\n    ) external view returns (uint nativeFee, uint zroFee);\n\n    // @notice get this Endpoint's immutable source identifier\n    function getChainId() external view returns (uint16);\n\n    // @notice the interface to retry failed message on this Endpoint destination\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    // @param _payload - the payload to be retried\n    function retryPayload(uint16 _srcChainId, bytes calldata _srcAddress, bytes calldata _payload) external;\n\n    // @notice query if any STORED payload (message blocking) at the endpoint.\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool);\n\n    // @notice query if the _libraryAddress is valid for sending msgs.\n    // @param _userApplication - the user app address on this EVM chain\n    function getSendLibraryAddress(address _userApplication) external view returns (address);\n\n    // @notice query if the _libraryAddress is valid for receiving msgs.\n    // @param _userApplication - the user app address on this EVM chain\n    function getReceiveLibraryAddress(address _userApplication) external view returns (address);\n\n    // @notice query if the non-reentrancy guard for send() is on\n    // @return true if the guard is on. false otherwise\n    function isSendingPayload() external view returns (bool);\n\n    // @notice query if the non-reentrancy guard for receive() is on\n    // @return true if the guard is on. false otherwise\n    function isReceivingPayload() external view returns (bool);\n\n    // @notice get the configuration of the LayerZero messaging library of the specified version\n    // @param _version - messaging library version\n    // @param _chainId - the chainId for the pending config change\n    // @param _userApplication - the contract address of the user application\n    // @param _configType - type of configuration. every messaging library has its own convention.\n    function getConfig(\n        uint16 _version,\n        uint16 _chainId,\n        address _userApplication,\n        uint _configType\n    ) external view returns (bytes memory);\n\n    // @notice get the send() LayerZero messaging library version\n    // @param _userApplication - the contract address of the user application\n    function getSendVersion(address _userApplication) external view returns (uint16);\n\n    // @notice get the lzReceive() LayerZero messaging library version\n    // @param _userApplication - the contract address of the user application\n    function getReceiveVersion(address _userApplication) external view returns (uint16);\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/interfaces/ILayerZeroMessagingLibrary.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.7.0;\n\nimport \"./ILayerZeroUserApplicationConfig.sol\";\n\ninterface ILayerZeroMessagingLibrary {\n    // send(), messages will be inflight.\n    function send(\n        address _userApplication,\n        uint64 _lastNonce,\n        uint16 _chainId,\n        bytes calldata _destination,\n        bytes calldata _payload,\n        address payable refundAddress,\n        address _zroPaymentAddress,\n        bytes calldata _adapterParams\n    ) external payable;\n\n    // estimate native fee at the send side\n    function estimateFees(\n        uint16 _chainId,\n        address _userApplication,\n        bytes calldata _payload,\n        bool _payInZRO,\n        bytes calldata _adapterParam\n    ) external view returns (uint nativeFee, uint zroFee);\n\n    //---------------------------------------------------------------------------\n    // setConfig / getConfig are User Application (UA) functions to specify Oracle, Relayer, blockConfirmations, libraryVersion\n    function setConfig(uint16 _chainId, address _userApplication, uint _configType, bytes calldata _config) external;\n\n    function getConfig(\n        uint16 _chainId,\n        address _userApplication,\n        uint _configType\n    ) external view returns (bytes memory);\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/interfaces/ILayerZeroUltraLightNodeV2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.7.0;\npragma abicoder v2;\n\ninterface ILayerZeroUltraLightNodeV2 {\n    // Relayer functions\n    function validateTransactionProof(\n        uint16 _srcChainId,\n        address _dstAddress,\n        uint _gasLimit,\n        bytes32 _lookupHash,\n        bytes32 _blockData,\n        bytes calldata _transactionProof\n    ) external;\n\n    // an Oracle delivers the block data using updateHash()\n    function updateHash(uint16 _srcChainId, bytes32 _lookupHash, uint _confirmations, bytes32 _blockData) external;\n\n    // can only withdraw the receivable of the msg.sender\n    function withdrawNative(address payable _to, uint _amount) external;\n\n    function withdrawZRO(address _to, uint _amount) external;\n\n    // view functions\n    function getAppConfig(\n        uint16 _remoteChainId,\n        address _userApplicationAddress\n    ) external view returns (ApplicationConfiguration memory);\n\n    function accruedNativeFee(address _address) external view returns (uint);\n\n    struct ApplicationConfiguration {\n        uint16 inboundProofLibraryVersion;\n        uint64 inboundBlockConfirmations;\n        address relayer;\n        uint16 outboundProofType;\n        uint64 outboundBlockConfirmations;\n        address oracle;\n    }\n\n    event HashReceived(\n        uint16 indexed srcChainId,\n        address indexed oracle,\n        bytes32 lookupHash,\n        bytes32 blockData,\n        uint confirmations\n    );\n    event RelayerParams(bytes adapterParams, uint16 outboundProofType);\n    event Packet(bytes payload);\n    event InvalidDst(\n        uint16 indexed srcChainId,\n        bytes srcAddress,\n        address indexed dstAddress,\n        uint64 nonce,\n        bytes32 payloadHash\n    );\n    event PacketReceived(\n        uint16 indexed srcChainId,\n        bytes srcAddress,\n        address indexed dstAddress,\n        uint64 nonce,\n        bytes32 payloadHash\n    );\n    event AppConfigUpdated(address indexed userApplication, uint indexed configType, bytes newConfig);\n    event AddInboundProofLibraryForChain(uint16 indexed chainId, address lib);\n    event EnableSupportedOutboundProof(uint16 indexed chainId, uint16 proofType);\n    event SetChainAddressSize(uint16 indexed chainId, uint size);\n    event SetDefaultConfigForChainId(\n        uint16 indexed chainId,\n        uint16 inboundProofLib,\n        uint64 inboundBlockConfirm,\n        address relayer,\n        uint16 outboundProofType,\n        uint64 outboundBlockConfirm,\n        address oracle\n    );\n    event SetDefaultAdapterParamsForChainId(uint16 indexed chainId, uint16 indexed proofType, bytes adapterParams);\n    event SetLayerZeroToken(address indexed tokenAddress);\n    event SetRemoteUln(uint16 indexed chainId, bytes32 uln);\n    event SetTreasury(address indexed treasuryAddress);\n    event WithdrawZRO(address indexed msgSender, address indexed to, uint amount);\n    event WithdrawNative(address indexed msgSender, address indexed to, uint amount);\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/interfaces/ILayerZeroUserApplicationConfig.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.5.0;\n\ninterface ILayerZeroUserApplicationConfig {\n    // @notice set the configuration of the LayerZero messaging library of the specified version\n    // @param _version - messaging library version\n    // @param _chainId - the chainId for the pending config change\n    // @param _configType - type of configuration. every messaging library has its own convention.\n    // @param _config - configuration in the bytes. can encode arbitrary content.\n    function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external;\n\n    // @notice set the send() LayerZero messaging library version to _version\n    // @param _version - new messaging library version\n    function setSendVersion(uint16 _version) external;\n\n    // @notice set the lzReceive() LayerZero messaging library version to _version\n    // @param _version - new messaging library version\n    function setReceiveVersion(uint16 _version) external;\n\n    // @notice Only when the UA needs to resume the message flow in blocking mode and clear the stored payload\n    // @param _srcChainId - the chainId of the source chain\n    // @param _srcAddress - the contract address of the source contract at the source chain\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../utils/StringsUpgradeable.sol\";\nimport \"../utils/introspection/ERC165Upgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        StringsUpgradeable.toHexString(account),\n                        \" is missing role \",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControlUpgradeable {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary MathUpgradeable {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/SignedMathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMathUpgradeable {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/MathUpgradeable.sol\";\nimport \"./math/SignedMathUpgradeable.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = MathUpgradeable.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMathUpgradeable.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(account),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1967.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC1967.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\n *\n * _Available since v4.8.3._\n */\ninterface IERC1967 {\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Proxy.sol\";\nimport \"./ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializing the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../interfaces/IERC1967.sol\";\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n */\nabstract contract ERC1967Upgrade is IERC1967 {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overridden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV // Deprecated in v4.8\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, \"\\x19\\x01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\n     * `validator` and `data` according to the version 0 of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x00\", validator, data));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 248 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 240 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 232 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 224 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 216 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 208 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 200 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 192 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 184 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 176 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 168 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 160 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 152 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 144 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 136 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 128 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 120 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 112 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 104 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 96 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 88 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 80 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 72 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 64 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 56 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 48 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 40 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 32 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 24 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 16 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 8 bits\");\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\n * _Available since v4.9 for `string`, `bytes`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\nimport \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "contracts/messagelib/contracts/decompressor/DecompressorExtension.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title DecompressorExtension\n * @dev A contract that implements a decompression algorithm to be used in conjunction with compressed data.\n * You should implement in your contract a function that makes use of the internal methods `_setData`, `_setDataArray` for data addition to the dictionary.\n * NOTE: It is important to implement a delay when using the `_setData` and `_setDataArray` methods in your transactions. This delay helps to guard against the possibility of frontrunning, which can occur when the state of the dictionary changes during the execution of a transaction.\n * @notice This extension could result in a much higher gas consumption than expected and could potentially lead to significant memory expansion costs. Be sure to properly estimate these aspects to avoid unforeseen expenses.\n */\nabstract contract DecompressorExtension {\n    /**\n     * @dev Emitted when an offset is used incorrectly, either because it is too small, or because its sum with a dict data's length exceeds a certain limit.\n     * @param value The incorrect value used as an offset or as the sum of the offset and a dict data's length.\n     */\n    error IncorrectDictAccess(uint256 value);\n\n    uint256 public constant MAX_DICT_LEN = 1_048_576; // 2 ** 20\n    uint256 public constant RESERVE_DICT_LEN = 2; // 0: msg.sender; 1: address(this)\n\n    /**\n     * @dev The dictionary mapping storage slots to their associated compressed data.\n     */\n    bytes32[MAX_DICT_LEN] private _dict;\n\n    /**\n     * @dev Ensures the provided value is correctly used as an offset. This includes checks for the offset being too small or its sum with an dict data's length exceeding a certain limit. Value less `RESERVE_DICT_LEN` are reserved.\n     * @param value The value used as an offset or as the sum of the offset and an array's length.\n     */\n    modifier validDictAccess(uint256 value) {\n        if (value < RESERVE_DICT_LEN || value >= MAX_DICT_LEN) revert IncorrectDictAccess(value);\n        _;\n    }\n\n    /**\n     * @dev Returns the data stored in the dictionary in the specified range.\n     * @param begin The starting index of the data range to return. First 2 positions are reserved, so it should be greater than 1.\n     * @param end The ending index of the data range to return.\n     * @return res An array of bytes32 values containing the data in the specified range.\n     */\n    function getData(\n        uint256 begin,\n        uint256 end\n    ) external view validDictAccess(begin) validDictAccess(end) returns (bytes32[] memory res) {\n        unchecked {\n            if (begin < end) {\n                res = new bytes32[](end - begin);\n                for (uint256 i = begin; i < end; i++) {\n                    res[i - begin] = _dict[i];\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Sets the data at the specified dictionary offset.\n     * @param offset The dictionary offset to set the data at. First 2 positions are reserved, so it should be greater than 1.\n     * @param data The data to be stored at the specified offset.\n     */\n    function _setData(uint256 offset, bytes32 data) internal validDictAccess(offset) {\n        unchecked {\n            _dict[offset] = data;\n        }\n    }\n\n    /**\n     * @dev Sets an array of data starting at the specified dictionary offset.\n     * @param offset The starting dictionary offset to set the data at. First 2 positions are reserved, so it should be greater than 1.\n     * @param dataArray The array of data to be stored starting at the specified offset.\n     */\n    function _setDataArray(\n        uint256 offset,\n        bytes32[] calldata dataArray\n    ) internal validDictAccess(offset) validDictAccess(offset + dataArray.length) {\n        unchecked {\n            for (uint256 i = 0; i < dataArray.length; i++) {\n                _dict[offset + i] = dataArray[i];\n            }\n        }\n    }\n\n    /**\n     * @dev Decompresses the compressed data (N bytes) passed to the function using the _delegatecall function.\n     */\n    function decompress() external payable {\n        _delegatecall(decompressed());\n    }\n\n    /**\n     * @dev Calculates and returns the decompressed data from the compressed calldata.\n     * @return raw The decompressed raw data.\n     */\n    function decompressed() public view returns (bytes memory raw) {\n        return _decompressed(msg.data[4:]);\n    }\n\n    /**\n     * @dev Calculates and returns the decompressed raw data from the compressed data passed as an argument.\n     * @param cd The compressed data to be decompressed.\n     * @return raw The decompressed raw data.\n     */\n    function _decompressed(bytes calldata cd) internal view returns (bytes memory raw) {\n        assembly (\"memory-safe\") {\n            // solhint-disable-line no-inline-assembly\n            raw := mload(0x40)\n            let outptr := add(raw, 0x20)\n            let end := add(cd.offset, cd.length)\n            for {\n                let inptr := cd.offset\n            } lt(inptr, end) {\n\n            } {\n                // solhint-disable-line no-empty-blocks\n                let data := calldataload(inptr)\n\n                let key\n\n                // 00XXXXXX - insert X+1 zero bytes\n                // 01PXXXXX - copy X+1 bytes calldata (P means padding to 32 bytes or not)\n                // 10BBXXXX XXXXXXXX - use 12 bits as key for [32,20,4,31][B] bytes from storage X\n                // 11BBXXXX XXXXXXXX XXXXXXXX - use 20 bits as [32,20,4,31][B] bytes from storage X\n                switch shr(254, data)\n                case 0 {\n                    let size := add(byte(0, data), 1)\n                    calldatacopy(outptr, calldatasize(), size)\n                    inptr := add(inptr, 1)\n                    outptr := add(outptr, size)\n                    continue\n                }\n                case 1 {\n                    let size := add(and(0x1F, byte(0, data)), 1)\n                    if and(data, 0x2000000000000000000000000000000000000000000000000000000000000000) {\n                        mstore(outptr, 0)\n                        outptr := add(outptr, sub(32, size))\n                    }\n                    calldatacopy(outptr, add(inptr, 1), size)\n                    inptr := add(inptr, add(1, size))\n                    outptr := add(outptr, size)\n                    continue\n                }\n                case 2 {\n                    key := shr(244, shl(4, data))\n                    inptr := add(inptr, 2)\n                    // fallthrough\n                }\n                case 3 {\n                    key := shr(236, shl(4, data))\n                    inptr := add(inptr, 3)\n                    // fallthrough\n                }\n\n                // TODO: check sload argument\n                let value\n                switch key\n                case 0 {\n                    value := caller()\n                }\n                case 1 {\n                    value := address()\n                }\n                default {\n                    value := sload(add(_dict.slot, key))\n                }\n\n                switch shr(254, shl(2, data))\n                case 0 {\n                    mstore(outptr, value)\n                    outptr := add(outptr, 32)\n                }\n                case 1 {\n                    mstore(outptr, shl(96, value))\n                    outptr := add(outptr, 20)\n                }\n                case 2 {\n                    mstore(outptr, shl(224, value))\n                    outptr := add(outptr, 4)\n                }\n                default {\n                    mstore(outptr, shl(8, value))\n                    outptr := add(outptr, 31)\n                }\n            }\n            mstore(raw, sub(sub(outptr, raw), 0x20))\n            mstore(0x40, outptr)\n        }\n    }\n\n    /**\n     * @dev Executes a delegate call to the raw data calculated by the _decompressed function.\n     * @param raw The raw data to execute the delegate call with.\n     */\n    function _delegatecall(bytes memory raw) internal {\n        assembly (\"memory-safe\") {\n            // solhint-disable-line no-inline-assembly\n            let success := delegatecall(gas(), address(), add(raw, 0x20), mload(raw), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            if success {\n                return(0, returndatasize())\n            }\n            revert(0, returndatasize())\n        }\n    }\n}\n"
    },
    "contracts/messagelib/contracts/decompressor/DVNDecoder.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport { ExecuteParam } from \"../uln/dvn/DVN.sol\";\n\nlibrary DVNDecoder {\n    uint8 internal constant DVN_INDEX_SIZE = 2; // uint16\n    uint8 internal constant PARAMS_LENGTH_SIZE = 1; // uint8\n    uint8 internal constant TARGET_INDEX_SIZE = 1; // uint8\n    uint8 internal constant EXPIRATION_SIZE = 16; // uint128\n    uint8 internal constant SIGNATURES_LENGTH_SIZE = 2; // uint16\n    uint8 internal constant CALL_DATA_LENGTH_SIZE = 8; // uint64\n\n    function execute(\n        bytes calldata _encoded,\n        uint32 _vid,\n        mapping(uint8 index => address target) storage _targets\n    ) internal view returns (uint16 dvnIndex, ExecuteParam[] memory params) {\n        uint256 cursor = 0;\n\n        dvnIndex = uint16(bytes2(_encoded[cursor:cursor + DVN_INDEX_SIZE]));\n        cursor += DVN_INDEX_SIZE;\n\n        uint8 length = uint8(bytes1(_encoded[cursor:cursor + PARAMS_LENGTH_SIZE]));\n        cursor += PARAMS_LENGTH_SIZE;\n\n        params = new ExecuteParam[](length);\n\n        for (uint256 i = 0; i < length; i++) {\n            uint8 targetIndex = uint8(bytes1(_encoded[cursor:cursor + TARGET_INDEX_SIZE]));\n            cursor += TARGET_INDEX_SIZE;\n\n            uint128 expiration = uint128(bytes16(_encoded[cursor:cursor + EXPIRATION_SIZE]));\n            cursor += EXPIRATION_SIZE;\n\n            uint16 signaturesLength = uint16(bytes2(_encoded[cursor:cursor + SIGNATURES_LENGTH_SIZE]));\n            cursor += SIGNATURES_LENGTH_SIZE;\n\n            bytes memory signatures = _encoded[cursor:cursor + signaturesLength];\n            cursor += signaturesLength;\n\n            uint64 callDataLength = uint64(bytes8(_encoded[cursor:cursor + CALL_DATA_LENGTH_SIZE]));\n            cursor += CALL_DATA_LENGTH_SIZE;\n\n            bytes memory callData = _encoded[cursor:cursor + callDataLength];\n            cursor += callDataLength;\n\n            params[i] = ExecuteParam(_vid, _targets[targetIndex], callData, expiration, signatures);\n        }\n    }\n}\n"
    },
    "contracts/messagelib/contracts/decompressor/DVNDecompressor.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.22;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport { DVN, ExecuteParam } from \"../uln/dvn/DVN.sol\";\nimport { DVNDecoder } from \"./DVNDecoder.sol\";\nimport { DecompressorExtension } from \"./DecompressorExtension.sol\";\n\nstruct TargetParam {\n    uint8 idx;\n    address addr;\n}\n\nstruct DVNParam {\n    uint16 idx;\n    address addr;\n}\n\ncontract DVNDecompressor is Ownable, DecompressorExtension {\n    uint32 public immutable vid;\n\n    mapping(uint16 index => address dvn) public dvns;\n    mapping(uint8 index => address target) public targets;\n\n    constructor(uint32 _vid, DVNParam[] memory _dvns, TargetParam[] memory _targets) {\n        vid = _vid;\n\n        for (uint256 i = 0; i < _dvns.length; i++) {\n            DVNParam memory param = _dvns[i];\n            dvns[param.idx] = param.addr;\n        }\n\n        for (uint256 i = 0; i < _targets.length; i++) {\n            TargetParam memory param = _targets[i];\n            targets[param.idx] = param.addr;\n        }\n    }\n\n    function addTargets(TargetParam[] memory _targets) external onlyOwner {\n        for (uint256 i = 0; i < _targets.length; i++) {\n            targets[_targets[i].idx] = _targets[i].addr;\n        }\n    }\n\n    function removeTargets(uint8[] memory _idx) external onlyOwner {\n        for (uint256 i = 0; i < _idx.length; i++) {\n            delete targets[_idx[i]];\n        }\n    }\n\n    function addDVNs(DVNParam[] memory _dvns) external onlyOwner {\n        for (uint256 i = 0; i < _dvns.length; i++) {\n            dvns[_dvns[i].idx] = _dvns[i].addr;\n        }\n    }\n\n    function removeDVNs(uint16[] memory _idx) external onlyOwner {\n        for (uint256 i = 0; i < _idx.length; i++) {\n            delete dvns[_idx[i]];\n        }\n    }\n\n    function execute(bytes calldata _encoded) external onlyOwner {\n        (uint16 dvnIndex, ExecuteParam[] memory params) = DVNDecoder.execute(_encoded, vid, targets);\n\n        DVN(dvns[dvnIndex]).execute(params);\n    }\n}\n"
    },
    "contracts/messagelib/contracts/decompressor/ExecutorDecoder.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { Origin } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\nimport { IExecutor } from \"../interfaces/IExecutor.sol\";\n\nlibrary ExecutorDecoder {\n    uint8 internal constant NATIVE_DROP_GAS_LIMIT_OFFSET = 0; // uint32\n    uint8 internal constant SRC_EID_OFFSET = 4; // uint32\n    uint8 internal constant SENDER_OFFSET = 8; // bytes32\n    uint8 internal constant NONCE_OFFSET = 40; // uint64\n    uint8 internal constant RECEIVER_OFFSET = 48; // address\n\n    uint8 internal constant NATIVEDROP_DST_EID_OFFSET = 68; // uint32\n    uint8 internal constant DST_EID_SIZE = 4; // uint32\n    function nativeDrop(\n        bytes calldata _encoded\n    )\n        internal\n        pure\n        returns (\n            Origin memory origin,\n            uint32 dstEid,\n            address receiver,\n            IExecutor.NativeDropParams[] memory nativeDropParams,\n            uint256 nativeDropGasLimit\n        )\n    {\n        nativeDropGasLimit = uint256(uint32(bytes4(_encoded[NATIVE_DROP_GAS_LIMIT_OFFSET:SRC_EID_OFFSET])));\n        origin.srcEid = uint32(bytes4(_encoded[SRC_EID_OFFSET:SENDER_OFFSET]));\n        origin.sender = bytes32(_encoded[SENDER_OFFSET:NONCE_OFFSET]);\n        origin.nonce = uint64(bytes8(_encoded[NONCE_OFFSET:RECEIVER_OFFSET]));\n        receiver = address(bytes20(_encoded[RECEIVER_OFFSET:NATIVEDROP_DST_EID_OFFSET]));\n\n        uint8 nativeDropOffset = NATIVEDROP_DST_EID_OFFSET + DST_EID_SIZE;\n        dstEid = uint32(bytes4(_encoded[NATIVEDROP_DST_EID_OFFSET:nativeDropOffset]));\n\n        nativeDropParams = _nativeDrop(_encoded[nativeDropOffset:]);\n    }\n\n    uint8 internal constant EXECUTE301_GAS_LIMIT_OFFSET = 0; // uint64\n    uint8 internal constant EXECUTE301_PACKET_OFFSET = 8; // uint64\n    function execute301(bytes calldata encoded) internal pure returns (bytes memory packet, uint256 gasLimit) {\n        gasLimit = uint256(uint64(bytes8(encoded[EXECUTE301_GAS_LIMIT_OFFSET:EXECUTE301_PACKET_OFFSET])));\n        packet = encoded[EXECUTE301_PACKET_OFFSET:];\n    }\n\n    uint8 internal constant NATIVEDROP_AND_EXECUTE301_GAS_LIMIT_OFFSET = 48; // uint64\n    uint8 internal constant NATIVEDROP_AND_EXECUTE301_PACKET_LENGTH_OFFSET = 56; // uint64\n    uint8 internal constant NATIVEDROP_AND_EXECUTE301_PACKET_OFFSET = 64; // uint64\n    function nativeDropAndExecute301(\n        bytes calldata _encoded\n    )\n        internal\n        pure\n        returns (\n            Origin memory origin,\n            IExecutor.NativeDropParams[] memory nativeDropParams,\n            uint256 nativeDropGasLimit,\n            bytes memory packet,\n            uint256 gasLimit\n        )\n    {\n        nativeDropGasLimit = uint256(uint32(bytes4(_encoded[NATIVE_DROP_GAS_LIMIT_OFFSET:SRC_EID_OFFSET])));\n        origin.srcEid = uint32(bytes4(_encoded[SRC_EID_OFFSET:SENDER_OFFSET]));\n        origin.sender = bytes32(_encoded[SENDER_OFFSET:NONCE_OFFSET]);\n        origin.nonce = uint64(bytes8(_encoded[NONCE_OFFSET:NATIVEDROP_AND_EXECUTE301_GAS_LIMIT_OFFSET]));\n\n        gasLimit = uint256(\n            uint64(\n                bytes8(\n                    _encoded[NATIVEDROP_AND_EXECUTE301_GAS_LIMIT_OFFSET:NATIVEDROP_AND_EXECUTE301_PACKET_LENGTH_OFFSET]\n                )\n            )\n        );\n\n        uint64 packetLength = uint64(\n            bytes8(_encoded[NATIVEDROP_AND_EXECUTE301_PACKET_LENGTH_OFFSET:NATIVEDROP_AND_EXECUTE301_PACKET_OFFSET])\n        );\n\n        uint256 cursor = NATIVEDROP_AND_EXECUTE301_PACKET_OFFSET;\n\n        packet = _encoded[cursor:cursor + packetLength];\n        cursor += packetLength;\n\n        nativeDropParams = _nativeDrop(_encoded[cursor:]);\n    }\n\n    uint8 internal constant EXECUTE302_GUID_OFFSET = 68; // bytes32\n    uint8 internal constant EXECUTE302_GAS_LIMIT_OFFSET = 100; // uint64\n    uint8 internal constant EXECUTE302_MESSAGE_LENGTH_OFFSET = 108; // uint64\n    uint8 internal constant EXECUTE302_MESSAGE_OFFSET = 116; // uint64\n    uint8 internal constant EXTRA_DATA_LENGTH_SIZE = 8; // uint64\n    function nativeDropAndExecute302(\n        bytes calldata _encoded\n    )\n        internal\n        pure\n        returns (\n            IExecutor.NativeDropParams[] memory nativeDropParams,\n            uint256 nativeDropGasLimit,\n            IExecutor.ExecutionParams memory executionParams\n        )\n    {\n        nativeDropGasLimit = uint256(uint32(bytes4(_encoded[NATIVE_DROP_GAS_LIMIT_OFFSET:SRC_EID_OFFSET])));\n        executionParams.origin.srcEid = uint32(bytes4(_encoded[SRC_EID_OFFSET:SENDER_OFFSET]));\n        executionParams.origin.sender = bytes32(_encoded[SENDER_OFFSET:NONCE_OFFSET]);\n        executionParams.origin.nonce = uint64(bytes8(_encoded[NONCE_OFFSET:RECEIVER_OFFSET]));\n        executionParams.receiver = address(bytes20(_encoded[RECEIVER_OFFSET:EXECUTE302_GUID_OFFSET]));\n        executionParams.guid = bytes32(_encoded[EXECUTE302_GUID_OFFSET:EXECUTE302_GAS_LIMIT_OFFSET]);\n        executionParams.gasLimit = uint256(\n            uint64(bytes8(_encoded[EXECUTE302_GAS_LIMIT_OFFSET:EXECUTE302_MESSAGE_LENGTH_OFFSET]))\n        );\n\n        uint64 messageLength = uint64(bytes8(_encoded[EXECUTE302_MESSAGE_LENGTH_OFFSET:EXECUTE302_MESSAGE_OFFSET]));\n        uint256 cursor = EXECUTE302_MESSAGE_OFFSET;\n\n        executionParams.message = _encoded[cursor:cursor + messageLength];\n        cursor += messageLength;\n\n        uint64 extraDataLength = uint64(bytes8(_encoded[cursor:cursor + EXTRA_DATA_LENGTH_SIZE]));\n        cursor += EXTRA_DATA_LENGTH_SIZE;\n\n        executionParams.extraData = _encoded[cursor:cursor + extraDataLength];\n        cursor += extraDataLength;\n\n        nativeDropParams = _nativeDrop(_encoded[cursor:]);\n    }\n\n    uint8 internal constant NATIVE_DROP_RECEIVER_SIZE = 20; // address\n    uint8 internal constant NATIVE_DROP_AMOUNT_SIZE = 9; // uint72\n    uint8 internal constant NATIVE_DROP_PARAM_SIZE = 29; // 20 + 9\n    function _nativeDrop(\n        bytes calldata _encoded\n    ) internal pure returns (IExecutor.NativeDropParams[] memory nativeDropParams) {\n        uint256 cursor = 0;\n        uint256 nativeDropParamsLength = _encoded.length / NATIVE_DROP_PARAM_SIZE;\n\n        nativeDropParams = new IExecutor.NativeDropParams[](nativeDropParamsLength);\n        for (uint256 i = 0; i < nativeDropParamsLength; i++) {\n            nativeDropParams[i].receiver = address(bytes20(_encoded[cursor:cursor + NATIVE_DROP_RECEIVER_SIZE]));\n            cursor += NATIVE_DROP_RECEIVER_SIZE;\n            nativeDropParams[i].amount = uint256(uint72(bytes9(_encoded[cursor:cursor + NATIVE_DROP_AMOUNT_SIZE])));\n            cursor += NATIVE_DROP_AMOUNT_SIZE;\n        }\n    }\n}\n"
    },
    "contracts/messagelib/contracts/decompressor/ExecutorDecompressor.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.22;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { Origin } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\n\nimport { Executor } from \"../Executor.sol\";\nimport { ExecutorDecoder } from \"./ExecutorDecoder.sol\";\nimport { DecompressorExtension } from \"./DecompressorExtension.sol\";\n\ncontract ExecutorDecompressor is Ownable, DecompressorExtension {\n    Executor public immutable executor;\n\n    constructor(Executor _executor) {\n        executor = _executor;\n    }\n\n    function nativeDrop(bytes calldata _encoded) external onlyOwner {\n        (\n            Origin memory origin,\n            uint32 dstEid,\n            address oapp,\n            Executor.NativeDropParams[] memory nativeDropParams,\n            uint256 nativeDropGasLimit\n        ) = ExecutorDecoder.nativeDrop(_encoded);\n\n        executor.nativeDrop(origin, dstEid, oapp, nativeDropParams, nativeDropGasLimit);\n    }\n\n    function execute301(bytes calldata _encoded) external onlyOwner {\n        (bytes memory packet, uint256 gasLimit) = ExecutorDecoder.execute301(_encoded);\n\n        executor.execute301(packet, gasLimit);\n    }\n\n    function nativeDropAndExecute301(bytes calldata _encoded) external onlyOwner {\n        (\n            Origin memory origin,\n            Executor.NativeDropParams[] memory nativeDropParams,\n            uint256 nativeDropGasLimit,\n            bytes memory packet,\n            uint256 gasLimit\n        ) = ExecutorDecoder.nativeDropAndExecute301(_encoded);\n\n        executor.nativeDropAndExecute301(origin, nativeDropParams, nativeDropGasLimit, packet, gasLimit);\n    }\n\n    function nativeDropAndExecute302(bytes calldata _encoded) external onlyOwner {\n        (\n            Executor.NativeDropParams[] memory nativeDropParams,\n            uint256 nativeDropGasLimit,\n            Executor.ExecutionParams memory executionParams\n        ) = ExecutorDecoder.nativeDropAndExecute302(_encoded);\n\n        executor.nativeDropAndExecute302(nativeDropParams, nativeDropGasLimit, executionParams);\n    }\n}\n"
    },
    "contracts/messagelib/contracts/Executor.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport { Proxied } from \"hardhat-deploy/solc_0.8/proxy/Proxied.sol\";\n\nimport { Origin } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\nimport { PacketV1Codec } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/PacketV1Codec.sol\";\n\nimport { IUltraLightNode301 } from \"./uln/uln301/interfaces/IUltraLightNode301.sol\";\nimport { IExecutor } from \"./interfaces/IExecutor.sol\";\nimport { IExecutorFeeLib } from \"./interfaces/IExecutorFeeLib.sol\";\nimport { WorkerUpgradeable } from \"./upgradeable/WorkerUpgradeable.sol\";\n\ninterface ILayerZeroEndpointV2 {\n    function eid() external view returns (uint32);\n\n    function lzReceive(\n        Origin calldata _origin,\n        address _receiver,\n        bytes32 _guid,\n        bytes calldata _message,\n        bytes calldata _extraData\n    ) external payable;\n\n    function lzReceiveAlert(\n        Origin calldata _origin,\n        address _receiver,\n        bytes32 _guid,\n        uint256 _gas,\n        uint256 _value,\n        bytes calldata _message,\n        bytes calldata _extraData,\n        bytes calldata _reason\n    ) external;\n\n    function lzCompose(\n        address _from,\n        address _to,\n        bytes32 _guid,\n        uint16 _index,\n        bytes calldata _message,\n        bytes calldata _extraData\n    ) external payable;\n\n    function lzComposeAlert(\n        address _from,\n        address _to,\n        bytes32 _guid,\n        uint16 _index,\n        uint256 _gas,\n        uint256 _value,\n        bytes calldata _message,\n        bytes calldata _extraData,\n        bytes calldata _reason\n    ) external;\n}\n\ncontract Executor is WorkerUpgradeable, ReentrancyGuardUpgradeable, Proxied, IExecutor {\n    using PacketV1Codec for bytes;\n\n    mapping(uint32 dstEid => DstConfig) public dstConfig;\n\n    // endpoint v2\n    address public endpoint;\n    uint32 public localEid;\n\n    // endpoint v1\n    address public receiveUln301;\n\n    function initialize(\n        address _endpoint,\n        address _receiveUln301,\n        address[] memory _messageLibs,\n        address _priceFeed,\n        address _roleAdmin,\n        address[] memory _admins\n    ) external proxied initializer {\n        __ReentrancyGuard_init();\n        __Worker_init(_messageLibs, _priceFeed, 12000, _roleAdmin, _admins);\n        endpoint = _endpoint;\n        localEid = ILayerZeroEndpointV2(_endpoint).eid();\n        receiveUln301 = _receiveUln301;\n    }\n\n    function onUpgrade(address _receiveUln301) external proxied {\n        receiveUln301 = _receiveUln301;\n    }\n\n    // --- Admin ---\n    function setDstConfig(DstConfigParam[] memory _params) external onlyRole(ADMIN_ROLE) {\n        for (uint256 i = 0; i < _params.length; i++) {\n            DstConfigParam memory param = _params[i];\n            dstConfig[param.dstEid] = DstConfig(\n                param.lzReceiveBaseGas,\n                param.multiplierBps,\n                param.floorMarginUSD,\n                param.nativeCap,\n                param.lzComposeBaseGas\n            );\n        }\n        emit DstConfigSet(_params);\n    }\n\n    function nativeDrop(\n        Origin calldata _origin,\n        uint32 _dstEid,\n        address _oapp,\n        NativeDropParams[] calldata _nativeDropParams,\n        uint256 _nativeDropGasLimit\n    ) external payable onlyRole(ADMIN_ROLE) nonReentrant {\n        _nativeDrop(_origin, _dstEid, _oapp, _nativeDropParams, _nativeDropGasLimit);\n    }\n\n    function nativeDropAndExecute301(\n        Origin calldata _origin,\n        NativeDropParams[] calldata _nativeDropParams,\n        uint256 _nativeDropGasLimit,\n        bytes calldata _packet,\n        uint256 _gasLimit\n    ) external payable onlyRole(ADMIN_ROLE) nonReentrant {\n        _nativeDrop(_origin, _packet.dstEid(), _packet.receiverB20(), _nativeDropParams, _nativeDropGasLimit);\n        IUltraLightNode301(receiveUln301).commitVerification(_packet, _gasLimit);\n    }\n\n    function execute301(bytes calldata _packet, uint256 _gasLimit) external onlyRole(ADMIN_ROLE) nonReentrant {\n        IUltraLightNode301(receiveUln301).commitVerification(_packet, _gasLimit);\n    }\n\n    function execute302(ExecutionParams calldata _executionParams) external payable onlyRole(ADMIN_ROLE) nonReentrant {\n        try\n            ILayerZeroEndpointV2(endpoint).lzReceive{ value: msg.value, gas: _executionParams.gasLimit }(\n                _executionParams.origin,\n                _executionParams.receiver,\n                _executionParams.guid,\n                _executionParams.message,\n                _executionParams.extraData\n            )\n        {\n            // do nothing\n        } catch (bytes memory reason) {\n            ILayerZeroEndpointV2(endpoint).lzReceiveAlert(\n                _executionParams.origin,\n                _executionParams.receiver,\n                _executionParams.guid,\n                _executionParams.gasLimit,\n                msg.value,\n                _executionParams.message,\n                _executionParams.extraData,\n                reason\n            );\n        }\n    }\n\n    function compose302(\n        address _from,\n        address _to,\n        bytes32 _guid,\n        uint16 _index,\n        bytes calldata _message,\n        bytes calldata _extraData,\n        uint256 _gasLimit\n    ) external payable onlyRole(ADMIN_ROLE) nonReentrant {\n        try\n            ILayerZeroEndpointV2(endpoint).lzCompose{ value: msg.value, gas: _gasLimit }(\n                _from,\n                _to,\n                _guid,\n                _index,\n                _message,\n                _extraData\n            )\n        {\n            // do nothing\n        } catch (bytes memory reason) {\n            ILayerZeroEndpointV2(endpoint).lzComposeAlert(\n                _from,\n                _to,\n                _guid,\n                _index,\n                _gasLimit,\n                msg.value,\n                _message,\n                _extraData,\n                reason\n            );\n        }\n    }\n\n    function nativeDropAndExecute302(\n        NativeDropParams[] calldata _nativeDropParams,\n        uint256 _nativeDropGasLimit,\n        ExecutionParams calldata _executionParams\n    ) external payable onlyRole(ADMIN_ROLE) nonReentrant {\n        uint256 spent = _nativeDrop(\n            _executionParams.origin,\n            localEid,\n            _executionParams.receiver,\n            _nativeDropParams,\n            _nativeDropGasLimit\n        );\n\n        uint256 value = msg.value - spent;\n        try\n            ILayerZeroEndpointV2(endpoint).lzReceive{ value: value, gas: _executionParams.gasLimit }(\n                _executionParams.origin,\n                _executionParams.receiver,\n                _executionParams.guid,\n                _executionParams.message,\n                _executionParams.extraData\n            )\n        {\n            // do nothing\n        } catch (bytes memory reason) {\n            ILayerZeroEndpointV2(endpoint).lzReceiveAlert(\n                _executionParams.origin,\n                _executionParams.receiver,\n                _executionParams.guid,\n                _executionParams.gasLimit,\n                value,\n                _executionParams.message,\n                _executionParams.extraData,\n                reason\n            );\n        }\n    }\n\n    // --- Message Lib ---\n    function assignJob(\n        uint32 _dstEid,\n        address _sender,\n        uint256 _calldataSize,\n        bytes calldata _options\n    ) external onlyRole(MESSAGE_LIB_ROLE) onlyAcl(_sender) whenNotPaused returns (uint256 fee) {\n        IExecutorFeeLib.FeeParams memory params = IExecutorFeeLib.FeeParams(\n            priceFeed,\n            _dstEid,\n            _sender,\n            _calldataSize,\n            defaultMultiplierBps\n        );\n        fee = IExecutorFeeLib(workerFeeLib).getFeeOnSend(params, dstConfig[_dstEid], _options);\n    }\n\n    // --- Only ACL ---\n    function getFee(\n        uint32 _dstEid,\n        address _sender,\n        uint256 _calldataSize,\n        bytes calldata _options\n    ) external view onlyAcl(_sender) whenNotPaused returns (uint256 fee) {\n        IExecutorFeeLib.FeeParams memory params = IExecutorFeeLib.FeeParams(\n            priceFeed,\n            _dstEid,\n            _sender,\n            _calldataSize,\n            defaultMultiplierBps\n        );\n        fee = IExecutorFeeLib(workerFeeLib).getFee(params, dstConfig[_dstEid], _options);\n    }\n\n    function _nativeDrop(\n        Origin calldata _origin,\n        uint32 _dstEid,\n        address _oapp,\n        NativeDropParams[] calldata _nativeDropParams,\n        uint256 _nativeDropGasLimit\n    ) internal returns (uint256 spent) {\n        bool[] memory success = new bool[](_nativeDropParams.length);\n        for (uint256 i = 0; i < _nativeDropParams.length; i++) {\n            NativeDropParams memory param = _nativeDropParams[i];\n\n            (bool sent, ) = param.receiver.call{ value: param.amount, gas: _nativeDropGasLimit }(\"\");\n\n            success[i] = sent;\n            spent += param.amount;\n        }\n        emit NativeDropApplied(_origin, _dstEid, _oapp, _nativeDropParams, success);\n    }\n}\n"
    },
    "contracts/messagelib/contracts/ExecutorFeeLib.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport { Transfer } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/Transfer.sol\";\nimport { ExecutorOptions } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/ExecutorOptions.sol\";\n\nimport { ILayerZeroPriceFeed } from \"./interfaces/ILayerZeroPriceFeed.sol\";\nimport { IExecutor } from \"./interfaces/IExecutor.sol\";\nimport { IExecutorFeeLib } from \"./interfaces/IExecutorFeeLib.sol\";\n\ncontract ExecutorFeeLib is Ownable, IExecutorFeeLib {\n    using ExecutorOptions for bytes;\n\n    uint256 private immutable nativeDecimalsRate;\n\n    constructor(uint256 _nativeDecimalsRate) {\n        nativeDecimalsRate = _nativeDecimalsRate;\n    }\n\n    // ================================ OnlyOwner ================================\n    function withdrawToken(address _token, address _to, uint256 _amount) external onlyOwner {\n        // transfers native if _token is address(0x0)\n        Transfer.nativeOrToken(_token, _to, _amount);\n    }\n\n    // ================================ External ================================\n    function getFeeOnSend(\n        FeeParams calldata _params,\n        IExecutor.DstConfig calldata _dstConfig,\n        bytes calldata _options\n    ) external returns (uint256 fee) {\n        if (_dstConfig.lzReceiveBaseGas == 0) revert Executor_EidNotSupported(_params.dstEid);\n\n        (uint256 totalDstAmount, uint256 totalGas) = _decodeExecutorOptions(\n            _isV1Eid(_params.dstEid),\n            _dstConfig.lzReceiveBaseGas,\n            _dstConfig.lzComposeBaseGas,\n            _dstConfig.nativeCap,\n            _options\n        );\n\n        // for future versions where priceFeed charges a fee\n        (\n            uint256 totalGasFee,\n            uint128 priceRatio,\n            uint128 priceRatioDenominator,\n            uint128 nativePriceUSD\n        ) = ILayerZeroPriceFeed(_params.priceFeed).estimateFeeOnSend(_params.dstEid, _params.calldataSize, totalGas);\n\n        uint16 multiplierBps = _dstConfig.multiplierBps == 0 ? _params.defaultMultiplierBps : _dstConfig.multiplierBps;\n\n        fee = _applyPremiumToGas(totalGasFee, multiplierBps, _dstConfig.floorMarginUSD, nativePriceUSD);\n        fee += _convertAndApplyPremiumToValue(totalDstAmount, priceRatio, priceRatioDenominator, multiplierBps);\n    }\n\n    // ================================ View ================================\n    function getFee(\n        FeeParams calldata _params,\n        IExecutor.DstConfig calldata _dstConfig,\n        bytes calldata _options\n    ) external view returns (uint256 fee) {\n        if (_dstConfig.lzReceiveBaseGas == 0) revert Executor_EidNotSupported(_params.dstEid);\n\n        (uint256 totalDstAmount, uint256 totalGas) = _decodeExecutorOptions(\n            _isV1Eid(_params.dstEid),\n            _dstConfig.lzReceiveBaseGas,\n            _dstConfig.lzComposeBaseGas,\n            _dstConfig.nativeCap,\n            _options\n        );\n\n        (\n            uint256 totalGasFee,\n            uint128 priceRatio,\n            uint128 priceRatioDenominator,\n            uint128 nativePriceUSD\n        ) = ILayerZeroPriceFeed(_params.priceFeed).estimateFeeByEid(_params.dstEid, _params.calldataSize, totalGas);\n\n        uint16 multiplierBps = _dstConfig.multiplierBps == 0 ? _params.defaultMultiplierBps : _dstConfig.multiplierBps;\n\n        fee = _applyPremiumToGas(totalGasFee, multiplierBps, _dstConfig.floorMarginUSD, nativePriceUSD);\n        fee += _convertAndApplyPremiumToValue(totalDstAmount, priceRatio, priceRatioDenominator, multiplierBps);\n    }\n\n    // ================================ Internal ================================\n    // @dev decode executor options into dstAmount and totalGas\n    function _decodeExecutorOptions(\n        bool _v1Eid,\n        uint64 _lzReceiveBaseGas,\n        uint64 _lzComposeBaseGas,\n        uint128 _nativeCap,\n        bytes calldata _options\n    ) internal pure returns (uint256 dstAmount, uint256 totalGas) {\n        if (_options.length == 0) {\n            revert Executor_NoOptions();\n        }\n\n        uint256 cursor = 0;\n        bool ordered = false;\n        totalGas = _lzReceiveBaseGas; // lz receive only called once\n\n        bool v1Eid = _v1Eid; // stack too deep\n        uint256 lzReceiveGas;\n        while (cursor < _options.length) {\n            (uint8 optionType, bytes calldata option, uint256 newCursor) = _options.nextExecutorOption(cursor);\n            cursor = newCursor;\n\n            if (optionType == ExecutorOptions.OPTION_TYPE_LZRECEIVE) {\n                (uint128 gas, uint128 value) = ExecutorOptions.decodeLzReceiveOption(option);\n\n                // endpoint v1 does not support lzReceive with value\n                if (v1Eid && value > 0) revert Executor_UnsupportedOptionType(optionType);\n\n                dstAmount += value;\n                lzReceiveGas += gas;\n            } else if (optionType == ExecutorOptions.OPTION_TYPE_NATIVE_DROP) {\n                (uint128 nativeDropAmount, ) = ExecutorOptions.decodeNativeDropOption(option);\n                dstAmount += nativeDropAmount;\n            } else if (optionType == ExecutorOptions.OPTION_TYPE_LZCOMPOSE) {\n                // endpoint v1 does not support lzCompose\n                if (v1Eid) revert Executor_UnsupportedOptionType(optionType);\n\n                (, uint128 gas, uint128 value) = ExecutorOptions.decodeLzComposeOption(option);\n                if (gas == 0) revert Executor_ZeroLzComposeGasProvided();\n\n                dstAmount += value;\n                // lz compose can be called multiple times, based on unique index\n                // to simplify the quoting, we add lzComposeBaseGas for each lzComposeOption received\n                // if the same index has multiple compose options, the gas will be added multiple times\n                totalGas += gas + _lzComposeBaseGas;\n            } else if (optionType == ExecutorOptions.OPTION_TYPE_ORDERED_EXECUTION) {\n                ordered = true;\n            } else {\n                revert Executor_UnsupportedOptionType(optionType);\n            }\n        }\n        if (cursor != _options.length) revert Executor_InvalidExecutorOptions(cursor);\n        if (dstAmount > _nativeCap) revert Executor_NativeAmountExceedsCap(dstAmount, _nativeCap);\n        if (lzReceiveGas == 0) revert Executor_ZeroLzReceiveGasProvided();\n        totalGas += lzReceiveGas;\n\n        if (ordered) {\n            totalGas = (totalGas * 102) / 100;\n        }\n    }\n\n    function _applyPremiumToGas(\n        uint256 _fee,\n        uint16 _multiplierBps,\n        uint128 _marginUSD,\n        uint128 _nativePriceUSD\n    ) internal view returns (uint256) {\n        uint256 feeWithMultiplier = (_fee * _multiplierBps) / 10000;\n\n        if (_nativePriceUSD == 0 || _marginUSD == 0) {\n            return feeWithMultiplier;\n        }\n        uint256 feeWithMargin = (_marginUSD * nativeDecimalsRate) / _nativePriceUSD + _fee;\n        return feeWithMargin > feeWithMultiplier ? feeWithMargin : feeWithMultiplier;\n    }\n\n    // includes value and nativeDrop\n    function _convertAndApplyPremiumToValue(\n        uint256 _value,\n        uint128 _ratio,\n        uint128 _denom,\n        uint16 _multiplierBps\n    ) internal pure returns (uint256 fee) {\n        if (_value > 0) {\n            fee = (((_value * _ratio) / _denom) * _multiplierBps) / 10000;\n        }\n    }\n\n    function _isV1Eid(uint32 _eid) internal pure virtual returns (bool) {\n        // v1 eid is < 30000\n        return _eid < 30000;\n    }\n\n    // send funds here to pay for price feed directly\n    receive() external payable {}\n}\n"
    },
    "contracts/messagelib/contracts/interfaces/IExecutor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport { Origin } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\n\nimport { IWorker } from \"./IWorker.sol\";\nimport { ILayerZeroExecutor } from \"./ILayerZeroExecutor.sol\";\n\ninterface IExecutor is IWorker, ILayerZeroExecutor {\n    struct DstConfigParam {\n        uint32 dstEid;\n        uint64 lzReceiveBaseGas;\n        uint64 lzComposeBaseGas;\n        uint16 multiplierBps;\n        uint128 floorMarginUSD;\n        uint128 nativeCap;\n    }\n\n    struct DstConfig {\n        uint64 lzReceiveBaseGas;\n        uint16 multiplierBps;\n        uint128 floorMarginUSD; // uses priceFeed PRICE_RATIO_DENOMINATOR\n        uint128 nativeCap;\n        uint64 lzComposeBaseGas;\n    }\n\n    struct ExecutionParams {\n        address receiver;\n        Origin origin;\n        bytes32 guid;\n        bytes message;\n        bytes extraData;\n        uint256 gasLimit;\n    }\n\n    struct NativeDropParams {\n        address receiver;\n        uint256 amount;\n    }\n\n    event DstConfigSet(DstConfigParam[] params);\n    event NativeDropApplied(Origin origin, uint32 dstEid, address oapp, NativeDropParams[] params, bool[] success);\n\n    function dstConfig(uint32 _dstEid) external view returns (uint64, uint16, uint128, uint128, uint64);\n}\n"
    },
    "contracts/messagelib/contracts/interfaces/IExecutorFeeLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport { IExecutor } from \"./IExecutor.sol\";\n\ninterface IExecutorFeeLib {\n    struct FeeParams {\n        address priceFeed;\n        uint32 dstEid;\n        address sender;\n        uint256 calldataSize;\n        uint16 defaultMultiplierBps;\n    }\n\n    error Executor_NoOptions();\n    error Executor_NativeAmountExceedsCap(uint256 amount, uint256 cap);\n    error Executor_UnsupportedOptionType(uint8 optionType);\n    error Executor_InvalidExecutorOptions(uint256 cursor);\n    error Executor_ZeroLzReceiveGasProvided();\n    error Executor_ZeroLzComposeGasProvided();\n    error Executor_EidNotSupported(uint32 eid);\n\n    function getFeeOnSend(\n        FeeParams calldata _params,\n        IExecutor.DstConfig calldata _dstConfig,\n        bytes calldata _options\n    ) external returns (uint256 fee);\n\n    function getFee(\n        FeeParams calldata _params,\n        IExecutor.DstConfig calldata _dstConfig,\n        bytes calldata _options\n    ) external view returns (uint256 fee);\n}\n"
    },
    "contracts/messagelib/contracts/interfaces/ILayerZeroExecutor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface ILayerZeroExecutor {\n    // @notice query price and assign jobs at the same time\n    // @param _dstEid - the destination endpoint identifier\n    // @param _sender - the source sending contract address. executors may apply price discrimination to senders\n    // @param _calldataSize - dynamic data size of message + caller params\n    // @param _options - optional parameters for extra service plugins, e.g. sending dust tokens at the destination chain\n    function assignJob(\n        uint32 _dstEid,\n        address _sender,\n        uint256 _calldataSize,\n        bytes calldata _options\n    ) external returns (uint256 price);\n\n    // @notice query the executor price for relaying the payload and its proof to the destination chain\n    // @param _dstEid - the destination endpoint identifier\n    // @param _sender - the source sending contract address. executors may apply price discrimination to senders\n    // @param _calldataSize - dynamic data size of message + caller params\n    // @param _options - optional parameters for extra service plugins, e.g. sending dust tokens at the destination chain\n    function getFee(\n        uint32 _dstEid,\n        address _sender,\n        uint256 _calldataSize,\n        bytes calldata _options\n    ) external view returns (uint256 price);\n}\n"
    },
    "contracts/messagelib/contracts/interfaces/ILayerZeroPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface ILayerZeroPriceFeed {\n    /**\n     * @dev\n     * priceRatio: (USD price of 1 unit of remote native token in unit of local native token) * PRICE_RATIO_DENOMINATOR\n     */\n\n    struct Price {\n        uint128 priceRatio; // float value * 10 ^ 20, decimal awared. for aptos to evm, the basis would be (10^18 / 10^8) * 10 ^20 = 10 ^ 30.\n        uint64 gasPriceInUnit; // for evm, it is in wei, for aptos, it is in octas.\n        uint32 gasPerByte;\n    }\n\n    struct UpdatePrice {\n        uint32 eid;\n        Price price;\n    }\n\n    /**\n     * @dev\n     *    ArbGasInfo.go:GetPricesInArbGas\n     *\n     */\n    struct ArbitrumPriceExt {\n        uint64 gasPerL2Tx; // L2 overhead\n        uint32 gasPerL1CallDataByte;\n    }\n\n    struct UpdatePriceExt {\n        uint32 eid;\n        Price price;\n        ArbitrumPriceExt extend;\n    }\n\n    error LZ_PriceFeed_OnlyPriceUpdater();\n    error LZ_PriceFeed_InsufficientFee(uint256 provided, uint256 required);\n    error LZ_PriceFeed_NotAnOPStack(uint32 l2Eid);\n\n    function nativeTokenPriceUSD() external view returns (uint128);\n\n    function getFee(uint32 _dstEid, uint256 _callDataSize, uint256 _gas) external view returns (uint256);\n\n    function getPrice(uint32 _dstEid) external view returns (Price memory);\n\n    function getPriceRatioDenominator() external view returns (uint128);\n\n    function estimateFeeByEid(\n        uint32 _dstEid,\n        uint256 _callDataSize,\n        uint256 _gas\n    ) external view returns (uint256 fee, uint128 priceRatio, uint128 priceRatioDenominator, uint128 nativePriceUSD);\n\n    function estimateFeeOnSend(\n        uint32 _dstEid,\n        uint256 _callDataSize,\n        uint256 _gas\n    ) external payable returns (uint256 fee, uint128 priceRatio, uint128 priceRatioDenominator, uint128 nativePriceUSD);\n}\n"
    },
    "contracts/messagelib/contracts/interfaces/ILayerZeroTreasury.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface ILayerZeroTreasury {\n    function getFee(\n        address _sender,\n        uint32 _dstEid,\n        uint256 _totalNativeFee,\n        bool _payInLzToken\n    ) external view returns (uint256 fee);\n\n    function payFee(\n        address _sender,\n        uint32 _dstEid,\n        uint256 _totalNativeFee,\n        bool _payInLzToken\n    ) external payable returns (uint256 fee);\n}\n"
    },
    "contracts/messagelib/contracts/interfaces/IWorker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface IWorker {\n    event SetWorkerLib(address workerLib);\n    event SetPriceFeed(address priceFeed);\n    event SetDefaultMultiplierBps(uint16 multiplierBps);\n    event SetSupportedOptionTypes(uint32 dstEid, uint8[] optionTypes);\n    event Withdraw(address lib, address to, uint256 amount);\n\n    error Worker_NotAllowed();\n    error Worker_OnlyMessageLib();\n    error Worker_RoleRenouncingDisabled();\n\n    function setPriceFeed(address _priceFeed) external;\n\n    function priceFeed() external view returns (address);\n\n    function setDefaultMultiplierBps(uint16 _multiplierBps) external;\n\n    function defaultMultiplierBps() external view returns (uint16);\n\n    function withdrawFee(address _lib, address _to, uint256 _amount) external;\n\n    function setSupportedOptionTypes(uint32 _eid, uint8[] calldata _optionTypes) external;\n\n    function getSupportedOptionTypes(uint32 _eid) external view returns (uint8[] memory);\n}\n"
    },
    "contracts/messagelib/contracts/libs/SafeCall.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.20;\n\n/// @dev copied from https://github.com/nomad-xyz/ExcessivelySafeCall/blob/main/src/ExcessivelySafeCall.sol.\nlibrary SafeCall {\n    /// @notice calls a contract with a specified gas limit and value and captures the return data\n    /// @param _target The address to call\n    /// @param _gas The amount of gas to forward to the remote contract\n    /// @param _value The value in wei to send to the remote contract\n    /// to memory.\n    /// @param _maxCopy The maximum number of bytes of returndata to copy\n    /// to memory.\n    /// @param _calldata The data to send to the remote contract\n    /// @return success and returndata, as `.call()`. Returndata is capped to\n    /// `_maxCopy` bytes.\n    function safeCall(\n        address _target,\n        uint256 _gas,\n        uint256 _value,\n        uint16 _maxCopy,\n        bytes memory _calldata\n    ) internal returns (bool, bytes memory) {\n        // check that target has code\n        uint size;\n        assembly {\n            size := extcodesize(_target)\n        }\n        if (size == 0) {\n            return (false, new bytes(0));\n        }\n\n        // set up for assembly call\n        uint256 _toCopy;\n        bool _success;\n        bytes memory _returnData = new bytes(_maxCopy);\n        // dispatch message to recipient\n        // by assembly calling \"handle\" function\n        // we call via assembly to avoid memcopying a very large returndata\n        // returned by a malicious contract\n        assembly {\n            _success := call(\n                _gas, // gas\n                _target, // recipient\n                _value, // ether value\n                add(_calldata, 0x20), // inloc\n                mload(_calldata), // inlen\n                0, // outloc\n                0 // outlen\n            )\n            // limit our copy to 100 bytes\n            _toCopy := returndatasize()\n            if gt(_toCopy, _maxCopy) {\n                _toCopy := _maxCopy\n            }\n            // Store the length of the copied bytes\n            mstore(_returnData, _toCopy)\n            // copy the bytes from returndata[0:_toCopy]\n            returndatacopy(add(_returnData, 0x20), 0, _toCopy)\n        }\n        return (_success, _returnData);\n    }\n\n    /// @notice Use when you _really_ really _really_ don't trust the called\n    /// contract. This prevents the called contract from causing reversion of\n    /// the caller in as many ways as we can.\n    /// @dev The main difference between this and a solidity low-level call is\n    /// that we limit the number of bytes that the callee can cause to be\n    /// copied to caller memory. This prevents stupid things like malicious\n    /// contracts returning 10,000,000 bytes causing a local OOG when copying\n    /// to memory.\n    /// @param _target The address to call\n    /// @param _gas The amount of gas to forward to the remote contract\n    /// @param _maxCopy The maximum number of bytes of returndata to copy\n    /// to memory.\n    /// @param _calldata The data to send to the remote contract\n    /// @return success and returndata, as `.call()`. Returndata is capped to\n    /// `_maxCopy` bytes.\n    function safeStaticCall(\n        address _target,\n        uint256 _gas,\n        uint16 _maxCopy,\n        bytes memory _calldata\n    ) internal view returns (bool, bytes memory) {\n        // check that target has code\n        uint size;\n        assembly {\n            size := extcodesize(_target)\n        }\n        if (size == 0) {\n            return (false, new bytes(0));\n        }\n\n        // set up for assembly call\n        uint256 _toCopy;\n        bool _success;\n        bytes memory _returnData = new bytes(_maxCopy);\n        // dispatch message to recipient\n        // by assembly calling \"handle\" function\n        // we call via assembly to avoid memcopying a very large returndata\n        // returned by a malicious contract\n        assembly {\n            _success := staticcall(\n                _gas, // gas\n                _target, // recipient\n                add(_calldata, 0x20), // inloc\n                mload(_calldata), // inlen\n                0, // outloc\n                0 // outlen\n            )\n            // limit our copy to 256 bytes\n            _toCopy := returndatasize()\n            if gt(_toCopy, _maxCopy) {\n                _toCopy := _maxCopy\n            }\n            // Store the length of the copied bytes\n            mstore(_returnData, _toCopy)\n            // copy the bytes from returndata[0:_toCopy]\n            returndatacopy(add(_returnData, 0x20), 0, _toCopy)\n        }\n        return (_success, _returnData);\n    }\n}\n"
    },
    "contracts/messagelib/contracts/MessageLibBase.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\n/// @dev simply a container of endpoint address and local eid\nabstract contract MessageLibBase {\n    address internal immutable endpoint;\n    uint32 internal immutable localEid;\n\n    error LZ_MessageLib_OnlyEndpoint();\n\n    modifier onlyEndpoint() {\n        if (endpoint != msg.sender) revert LZ_MessageLib_OnlyEndpoint();\n        _;\n    }\n\n    constructor(address _endpoint, uint32 _localEid) {\n        endpoint = _endpoint;\n        localEid = _localEid;\n    }\n}\n"
    },
    "contracts/messagelib/contracts/mocks/DVNMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.22;\n\nimport { ExecuteParam } from \"../uln/dvn/DVN.sol\";\n\ncontract DVNMock {\n    event Executed(uint32 vid, address target, bytes callData, uint256 expiration, bytes signatures);\n\n    uint32 public immutable vid;\n\n    constructor(uint32 _vid) {\n        vid = _vid;\n    }\n\n    function execute(ExecuteParam[] calldata _params) external {\n        for (uint256 i = 0; i < _params.length; i++) {\n            emit Executed(\n                _params[i].vid,\n                _params[i].target,\n                _params[i].callData,\n                _params[i].expiration,\n                _params[i].signatures\n            );\n        }\n    }\n\n    function verify(bytes calldata _packetHeader, bytes32 _payloadHash, uint64 _confirmations) external {}\n}\n"
    },
    "contracts/messagelib/contracts/mocks/ExecutorMock.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { Origin } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\nimport { PacketV1Codec } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/PacketV1Codec.sol\";\nimport { IExecutor } from \"../../contracts/interfaces/IExecutor.sol\";\n\ncontract ExecutorMock {\n    using PacketV1Codec for bytes;\n\n    event NativeDropMeta(\n        uint32 srcEid,\n        bytes32 sender,\n        uint64 nonce,\n        uint32 dstEid,\n        address oapp,\n        uint256 nativeDropGasLimit\n    );\n    event NativeDropped(address receiver, uint256 amount);\n    event Executed301(bytes packet, uint256 gasLimit);\n    event Executed302(\n        uint32 srcEid,\n        bytes32 sender,\n        uint64 nonce,\n        address receiver,\n        bytes32 guid,\n        bytes message,\n        bytes extraData,\n        uint256 gasLimit\n    );\n\n    uint32 public immutable dstEid;\n\n    constructor(uint32 _dstEid) {\n        dstEid = _dstEid;\n    }\n\n    function nativeDrop(\n        Origin calldata _origin,\n        uint32 _dstEid,\n        address _oapp,\n        IExecutor.NativeDropParams[] calldata _nativeDropParams,\n        uint256 _nativeDropGasLimit\n    ) external payable {\n        _nativeDrop(_origin, _dstEid, _oapp, _nativeDropParams, _nativeDropGasLimit);\n    }\n\n    function nativeDropAndExecute301(\n        Origin calldata _origin,\n        IExecutor.NativeDropParams[] calldata _nativeDropParams,\n        uint256 _nativeDropGasLimit,\n        bytes calldata _packet,\n        uint256 _gasLimit\n    ) external payable {\n        _nativeDrop(_origin, _packet.dstEid(), _packet.receiverB20(), _nativeDropParams, _nativeDropGasLimit);\n        emit Executed301(_packet, _gasLimit);\n    }\n\n    function execute301(bytes calldata _packet, uint256 _gasLimit) external {\n        emit Executed301(_packet, _gasLimit);\n    }\n\n    function nativeDropAndExecute302(\n        IExecutor.NativeDropParams[] calldata _nativeDropParams,\n        uint256 _nativeDropGasLimit,\n        IExecutor.ExecutionParams calldata _executionParams\n    ) external payable {\n        _nativeDrop(_executionParams.origin, dstEid, _executionParams.receiver, _nativeDropParams, _nativeDropGasLimit);\n\n        emit Executed302(\n            _executionParams.origin.srcEid,\n            _executionParams.origin.sender,\n            _executionParams.origin.nonce,\n            _executionParams.receiver,\n            _executionParams.guid,\n            _executionParams.message,\n            _executionParams.extraData,\n            _executionParams.gasLimit\n        );\n    }\n\n    function _nativeDrop(\n        Origin calldata _origin,\n        uint32 _dstEid,\n        address _oapp,\n        IExecutor.NativeDropParams[] calldata _nativeDropParams,\n        uint256 _nativeDropGasLimit\n    ) internal {\n        for (uint256 i = 0; i < _nativeDropParams.length; i++) {\n            emit NativeDropped(_nativeDropParams[i].receiver, _nativeDropParams[i].amount);\n        }\n        emit NativeDropMeta(_origin.srcEid, _origin.sender, _origin.nonce, _dstEid, _oapp, _nativeDropGasLimit);\n    }\n}\n"
    },
    "contracts/messagelib/contracts/PriceFeed.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { OwnableUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport { Proxied } from \"hardhat-deploy/solc_0.8/proxy/Proxied.sol\";\n\nimport { ILayerZeroEndpointV2 } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\nimport { Transfer } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/Transfer.sol\";\n\nimport { ILayerZeroPriceFeed } from \"./interfaces/ILayerZeroPriceFeed.sol\";\n\nenum ModelType {\n    DEFAULT,\n    ARB_STACK,\n    OP_STACK\n}\n\nstruct SetEidToModelTypeParam {\n    uint32 dstEid;\n    ModelType modelType;\n}\n\n// PriceFeed is updated based on v1 eids\n// v2 eids will fall to the convention of v1 eid + 30,000\ncontract PriceFeed is ILayerZeroPriceFeed, OwnableUpgradeable, Proxied {\n    uint128 internal PRICE_RATIO_DENOMINATOR;\n\n    // sets pricing\n    mapping(address updater => bool active) public priceUpdater;\n\n    mapping(uint32 dstEid => Price) internal _defaultModelPrice;\n    ArbitrumPriceExt internal _arbitrumPriceExt;\n\n    uint128 internal _nativePriceUSD; // uses PRICE_RATIO_DENOMINATOR\n\n    // upgrade: arbitrum compression - percentage of callDataSize after brotli compression\n    uint128 public ARBITRUM_COMPRESSION_PERCENT;\n\n    ILayerZeroEndpointV2 public endpoint;\n\n    // for the destination endpoint id, return the fee model type\n    mapping(uint32 => ModelType) public eidToModelType;\n\n    // ============================ Constructor ===================================\n\n    function initialize(address _priceUpdater) public proxied initializer {\n        __Ownable_init();\n        priceUpdater[_priceUpdater] = true;\n        PRICE_RATIO_DENOMINATOR = 1e20;\n        ARBITRUM_COMPRESSION_PERCENT = 47;\n    }\n\n    // ============================ Modifier ======================================\n\n    // owner is always approved\n    modifier onlyPriceUpdater() {\n        if (owner() != msg.sender) {\n            if (!priceUpdater[msg.sender]) {\n                revert LZ_PriceFeed_OnlyPriceUpdater();\n            }\n        }\n        _;\n    }\n\n    // ============================ OnlyOwner =====================================\n\n    function setPriceUpdater(address _addr, bool _active) external onlyOwner {\n        priceUpdater[_addr] = _active;\n    }\n\n    function setPriceRatioDenominator(uint128 _denominator) external onlyOwner {\n        PRICE_RATIO_DENOMINATOR = _denominator;\n    }\n\n    function setArbitrumCompressionPercent(uint128 _compressionPercent) external onlyOwner {\n        ARBITRUM_COMPRESSION_PERCENT = _compressionPercent;\n    }\n\n    // set the fee ModelType for the destination eid\n    function setEidToModelType(SetEidToModelTypeParam[] calldata _params) external onlyOwner {\n        for (uint i = 0; i < _params.length; i++) {\n            eidToModelType[_params[i].dstEid] = _params[i].modelType;\n        }\n    }\n\n    function setEndpoint(address _endpoint) external onlyOwner {\n        endpoint = ILayerZeroEndpointV2(_endpoint);\n    }\n\n    function withdrawFee(address _to, uint256 _amount) external onlyOwner {\n        Transfer.native(_to, _amount);\n    }\n\n    // ============================ OnlyPriceUpdater =====================================\n\n    function setPrice(UpdatePrice[] calldata _price) external onlyPriceUpdater {\n        for (uint256 i = 0; i < _price.length; i++) {\n            UpdatePrice calldata _update = _price[i];\n            _setPrice(_update.eid, _update.price);\n        }\n    }\n\n    function setPriceForArbitrum(UpdatePriceExt calldata _update) external onlyPriceUpdater {\n        _setPrice(_update.eid, _update.price);\n\n        uint64 gasPerL2Tx = _update.extend.gasPerL2Tx;\n        uint32 gasPerL1CalldataByte = _update.extend.gasPerL1CallDataByte;\n\n        _arbitrumPriceExt.gasPerL2Tx = gasPerL2Tx;\n        _arbitrumPriceExt.gasPerL1CallDataByte = gasPerL1CalldataByte;\n    }\n\n    function setNativeTokenPriceUSD(uint128 _nativeTokenPriceUSD) external onlyPriceUpdater {\n        _nativePriceUSD = _nativeTokenPriceUSD;\n    }\n\n    // ============================ External =====================================\n\n    function estimateFeeOnSend(\n        uint32 _dstEid,\n        uint256 _callDataSize,\n        uint256 _gas\n    ) external payable returns (uint256, uint128, uint128, uint128) {\n        uint256 fee = getFee(_dstEid, _callDataSize, _gas);\n        if (msg.value < fee) revert LZ_PriceFeed_InsufficientFee(msg.value, fee);\n        return _estimateFeeByEid(_dstEid, _callDataSize, _gas);\n    }\n\n    // ============================ View ==========================================\n\n    // get fee for calling estimateFeeOnSend\n    function getFee(uint32 /*_dstEid*/, uint256 /*_callDataSize*/, uint256 /*_gas*/) public pure returns (uint256) {\n        return 0;\n    }\n\n    function getPriceRatioDenominator() external view returns (uint128) {\n        return PRICE_RATIO_DENOMINATOR;\n    }\n\n    // NOTE: to be reverted when endpoint is in sendContext\n    function nativeTokenPriceUSD() external view returns (uint128) {\n        return _nativePriceUSD;\n    }\n\n    // NOTE: to be reverted when endpoint is in sendContext\n    function arbitrumPriceExt() external view returns (ArbitrumPriceExt memory) {\n        return _arbitrumPriceExt;\n    }\n\n    // NOTE: to be reverted when endpoint is in sendContext\n    function getPrice(uint32 _dstEid) external view returns (Price memory price) {\n        price = _defaultModelPrice[_dstEid];\n    }\n\n    // NOTE: to be reverted when endpoint is in sendContext\n    function estimateFeeByEid(\n        uint32 _dstEid,\n        uint256 _callDataSize,\n        uint256 _gas\n    ) external view returns (uint256, uint128, uint128, uint128) {\n        return _estimateFeeByEid(_dstEid, _callDataSize, _gas);\n    }\n\n    // NOTE: to be reverted when endpoint is in sendContext\n    // NOTE: to support legacy\n    function getPrice(uint16 _dstEid) external view returns (Price memory price) {\n        price = _defaultModelPrice[_dstEid];\n    }\n\n    // NOTE: to be reverted when endpoint is in sendContext\n    // NOTE: to support legacy\n    function estimateFeeByChain(\n        uint16 _dstEid,\n        uint256 _callDataSize,\n        uint256 _gas\n    ) external view returns (uint256 fee, uint128 priceRatio) {\n        // legacy if-statement uses very little gas, can keep using it until future upgrade\n        if (_dstEid == 110 || _dstEid == 10143 || _dstEid == 20143) {\n            return _estimateFeeWithArbitrumModel(_dstEid, _callDataSize, _gas);\n        } else if (_dstEid == 111 || _dstEid == 10132 || _dstEid == 20132) {\n            return _estimateFeeWithOptimismModel(_dstEid, _callDataSize, _gas);\n        }\n\n        // fee model type is configured per eid\n        ModelType _modelType = eidToModelType[_dstEid];\n        if (_modelType == ModelType.OP_STACK) {\n            return _estimateFeeWithOptimismModel(_dstEid, _callDataSize, _gas);\n        } else if (_modelType == ModelType.ARB_STACK) {\n            return _estimateFeeWithArbitrumModel(_dstEid, _callDataSize, _gas);\n        } else {\n            return _estimateFeeWithDefaultModel(_dstEid, _callDataSize, _gas);\n        }\n    }\n\n    // ============================ Internal ==========================================\n\n    function _setPrice(uint32 _dstEid, Price memory _price) internal {\n        uint128 priceRatio = _price.priceRatio;\n        uint64 gasPriceInUnit = _price.gasPriceInUnit;\n        uint32 gasPerByte = _price.gasPerByte;\n        _defaultModelPrice[_dstEid] = Price(priceRatio, gasPriceInUnit, gasPerByte);\n    }\n\n    function _getL1LookupIdForOptimismModel(uint32 _l2Eid) internal view returns (uint32) {\n        uint32 l2Eid = _l2Eid % 30_000;\n        if (l2Eid == 111) {\n            return 101;\n        } else if (l2Eid == 10132) {\n            return 10121; // ethereum-goerli\n        } else if (l2Eid == 20132) {\n            return 20121; // ethereum-goerli\n        }\n\n        if (eidToModelType[l2Eid] != ModelType.OP_STACK) revert LZ_PriceFeed_NotAnOPStack(_l2Eid);\n        if (l2Eid < 10000) {\n            return 101;\n        } else if (l2Eid < 20000) {\n            return 10161; // ethereum-sepolia\n        } else {\n            return 20121; // ethereum-goerli\n        }\n    }\n\n    function _estimateFeeWithDefaultModel(\n        uint32 _dstEid,\n        uint256 _callDataSize,\n        uint256 _gas\n    ) internal view returns (uint256 fee, uint128 priceRatio) {\n        Price storage remotePrice = _defaultModelPrice[_dstEid];\n\n        // assuming the _gas includes (1) the 21,000 overhead and (2) not the calldata gas\n        uint256 gasForCallData = _callDataSize * remotePrice.gasPerByte;\n        uint256 remoteFee = (gasForCallData + _gas) * remotePrice.gasPriceInUnit;\n        return ((remoteFee * remotePrice.priceRatio) / PRICE_RATIO_DENOMINATOR, remotePrice.priceRatio);\n    }\n\n    function _estimateFeeByEid(\n        uint32 _dstEid,\n        uint256 _callDataSize,\n        uint256 _gas\n    ) internal view returns (uint256 fee, uint128 priceRatio, uint128 priceRatioDenominator, uint128 priceUSD) {\n        uint32 dstEid = _dstEid % 30_000;\n        if (dstEid == 110 || dstEid == 10143 || dstEid == 20143) {\n            (fee, priceRatio) = _estimateFeeWithArbitrumModel(dstEid, _callDataSize, _gas);\n        } else if (dstEid == 111 || dstEid == 10132 || dstEid == 20132) {\n            (fee, priceRatio) = _estimateFeeWithOptimismModel(dstEid, _callDataSize, _gas);\n        }\n\n        // lookup map stuff\n        ModelType _modelType = eidToModelType[dstEid];\n        if (_modelType == ModelType.OP_STACK) {\n            (fee, priceRatio) = _estimateFeeWithOptimismModel(dstEid, _callDataSize, _gas);\n        } else if (_modelType == ModelType.ARB_STACK) {\n            (fee, priceRatio) = _estimateFeeWithArbitrumModel(dstEid, _callDataSize, _gas);\n        } else {\n            (fee, priceRatio) = _estimateFeeWithDefaultModel(dstEid, _callDataSize, _gas);\n        }\n\n        priceRatioDenominator = PRICE_RATIO_DENOMINATOR;\n        priceUSD = _nativePriceUSD;\n    }\n\n    function _estimateFeeWithOptimismModel(\n        uint32 _dstEid,\n        uint256 _callDataSize,\n        uint256 _gas\n    ) internal view returns (uint256 fee, uint128 priceRatio) {\n        uint32 ethereumId = _getL1LookupIdForOptimismModel(_dstEid);\n\n        // L1 fee\n        Price storage ethereumPrice = _defaultModelPrice[ethereumId];\n        uint256 gasForL1CallData = (_callDataSize * ethereumPrice.gasPerByte) + 3188; // 2100 + 68 * 16\n        uint256 l1Fee = gasForL1CallData * ethereumPrice.gasPriceInUnit;\n\n        // L2 fee\n        Price storage optimismPrice = _defaultModelPrice[_dstEid];\n        uint256 gasForL2CallData = _callDataSize * optimismPrice.gasPerByte;\n        uint256 l2Fee = (gasForL2CallData + _gas) * optimismPrice.gasPriceInUnit;\n\n        uint256 l1FeeInSrcPrice = (l1Fee * ethereumPrice.priceRatio) / PRICE_RATIO_DENOMINATOR;\n        uint256 l2FeeInSrcPrice = (l2Fee * optimismPrice.priceRatio) / PRICE_RATIO_DENOMINATOR;\n        uint256 gasFee = l1FeeInSrcPrice + l2FeeInSrcPrice;\n        return (gasFee, optimismPrice.priceRatio);\n    }\n\n    function _estimateFeeWithArbitrumModel(\n        uint32 _dstEid,\n        uint256 _callDataSize,\n        uint256 _gas\n    ) internal view returns (uint256 fee, uint128 priceRatio) {\n        Price storage arbitrumPrice = _defaultModelPrice[_dstEid];\n\n        // L1 fee\n        uint256 gasForL1CallData = ((_callDataSize * ARBITRUM_COMPRESSION_PERCENT) / 100) *\n            _arbitrumPriceExt.gasPerL1CallDataByte;\n        // L2 Fee\n        uint256 gasForL2CallData = _callDataSize * arbitrumPrice.gasPerByte;\n        uint256 gasFee = (_gas + _arbitrumPriceExt.gasPerL2Tx + gasForL1CallData + gasForL2CallData) *\n            arbitrumPrice.gasPriceInUnit;\n\n        return ((gasFee * arbitrumPrice.priceRatio) / PRICE_RATIO_DENOMINATOR, arbitrumPrice.priceRatio);\n    }\n}\n"
    },
    "contracts/messagelib/contracts/ReceiveLibBaseE2.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport { ERC165 } from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\nimport { ILayerZeroEndpointV2, Origin } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\nimport { IMessageLib, MessageLibType } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessageLib.sol\";\nimport { PacketV1Codec } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/PacketV1Codec.sol\";\n\nimport { MessageLibBase } from \"./MessageLibBase.sol\";\n\n/// @dev receive-side message library base contract on endpoint v2.\n/// it does not have the complication as the one of endpoint v1, such as nonce, executor whitelist, etc.\nabstract contract ReceiveLibBaseE2 is MessageLibBase, ERC165, IMessageLib {\n    using PacketV1Codec for bytes;\n\n    constructor(address _endpoint) MessageLibBase(_endpoint, ILayerZeroEndpointV2(_endpoint).eid()) {}\n\n    function supportsInterface(bytes4 _interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return _interfaceId == type(IMessageLib).interfaceId || super.supportsInterface(_interfaceId);\n    }\n\n    function messageLibType() external pure virtual override returns (MessageLibType) {\n        return MessageLibType.Receive;\n    }\n}\n"
    },
    "contracts/messagelib/contracts/SendLibBase.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { Transfer } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/Transfer.sol\";\n\nimport { ILayerZeroExecutor } from \"./interfaces/ILayerZeroExecutor.sol\";\nimport { ILayerZeroTreasury } from \"./interfaces/ILayerZeroTreasury.sol\";\nimport { SafeCall } from \"./libs/SafeCall.sol\";\nimport { MessageLibBase } from \"./MessageLibBase.sol\";\n\nstruct WorkerOptions {\n    uint8 workerId;\n    bytes options;\n}\n\nstruct SetDefaultExecutorConfigParam {\n    uint32 eid;\n    ExecutorConfig config;\n}\n\nstruct ExecutorConfig {\n    uint32 maxMessageSize;\n    address executor;\n}\n\n/// @dev base contract for both SendLibBaseE1 and SendLibBaseE2\nabstract contract SendLibBase is MessageLibBase, Ownable {\n    using SafeCall for address;\n\n    address private constant DEFAULT_CONFIG = address(0);\n    uint16 internal constant TREASURY_MAX_COPY = 32;\n\n    uint256 internal immutable treasuryGasLimit;\n    uint256 internal treasuryNativeFeeCap;\n\n    // config\n    address public treasury;\n    mapping(address oapp => mapping(uint32 eid => ExecutorConfig)) public executorConfigs;\n\n    // accumulated fees for workers and treasury\n    mapping(address worker => uint256) public fees;\n\n    event ExecutorFeePaid(address executor, uint256 fee);\n    event TreasurySet(address treasury);\n    event DefaultExecutorConfigsSet(SetDefaultExecutorConfigParam[] params);\n    event ExecutorConfigSet(address oapp, uint32 eid, ExecutorConfig config);\n    event TreasuryNativeFeeCapSet(uint256 newTreasuryNativeFeeCap);\n\n    error LZ_MessageLib_InvalidMessageSize(uint256 actual, uint256 max);\n    error LZ_MessageLib_InvalidAmount(uint256 requested, uint256 available);\n    error LZ_MessageLib_TransferFailed();\n    error LZ_MessageLib_InvalidExecutor();\n    error LZ_MessageLib_ZeroMessageSize();\n\n    constructor(\n        address _endpoint,\n        uint32 _localEid,\n        uint256 _treasuryGasLimit,\n        uint256 _treasuryNativeFeeCap\n    ) MessageLibBase(_endpoint, _localEid) {\n        treasuryGasLimit = _treasuryGasLimit;\n        treasuryNativeFeeCap = _treasuryNativeFeeCap;\n    }\n\n    function setDefaultExecutorConfigs(SetDefaultExecutorConfigParam[] calldata _params) external onlyOwner {\n        for (uint256 i = 0; i < _params.length; ++i) {\n            SetDefaultExecutorConfigParam calldata param = _params[i];\n\n            if (param.config.executor == address(0x0)) revert LZ_MessageLib_InvalidExecutor();\n            if (param.config.maxMessageSize == 0) revert LZ_MessageLib_ZeroMessageSize();\n\n            executorConfigs[DEFAULT_CONFIG][param.eid] = param.config;\n        }\n        emit DefaultExecutorConfigsSet(_params);\n    }\n\n    /// @dev the new value can not be greater than the old value, i.e. down only\n    function setTreasuryNativeFeeCap(uint256 _newTreasuryNativeFeeCap) external onlyOwner {\n        // assert the new value is no greater than the old value\n        if (_newTreasuryNativeFeeCap > treasuryNativeFeeCap)\n            revert LZ_MessageLib_InvalidAmount(_newTreasuryNativeFeeCap, treasuryNativeFeeCap);\n        treasuryNativeFeeCap = _newTreasuryNativeFeeCap;\n        emit TreasuryNativeFeeCapSet(_newTreasuryNativeFeeCap);\n    }\n\n    // ============================ View ===================================\n    // @dev get the executor config and if not set, return the default config\n    function getExecutorConfig(address _oapp, uint32 _remoteEid) public view returns (ExecutorConfig memory rtnConfig) {\n        ExecutorConfig storage defaultConfig = executorConfigs[DEFAULT_CONFIG][_remoteEid];\n        ExecutorConfig storage customConfig = executorConfigs[_oapp][_remoteEid];\n\n        uint32 maxMessageSize = customConfig.maxMessageSize;\n        rtnConfig.maxMessageSize = maxMessageSize != 0 ? maxMessageSize : defaultConfig.maxMessageSize;\n\n        address executor = customConfig.executor;\n        rtnConfig.executor = executor != address(0x0) ? executor : defaultConfig.executor;\n    }\n\n    // ======================= Internal =======================\n    function _assertMessageSize(uint256 _actual, uint256 _max) internal pure {\n        if (_actual > _max) revert LZ_MessageLib_InvalidMessageSize(_actual, _max);\n    }\n\n    function _payExecutor(\n        address _executor,\n        uint32 _dstEid,\n        address _sender,\n        uint256 _msgSize,\n        bytes memory _executorOptions\n    ) internal returns (uint256 executorFee) {\n        executorFee = ILayerZeroExecutor(_executor).assignJob(_dstEid, _sender, _msgSize, _executorOptions);\n        if (executorFee > 0) {\n            fees[_executor] += executorFee;\n        }\n        emit ExecutorFeePaid(_executor, executorFee);\n    }\n\n    function _payTreasury(\n        address _sender,\n        uint32 _dstEid,\n        uint256 _totalNativeFee,\n        bool _payInLzToken\n    ) internal returns (uint256 treasuryNativeFee, uint256 lzTokenFee) {\n        if (treasury != address(0x0)) {\n            bytes memory callData = abi.encodeCall(\n                ILayerZeroTreasury.payFee,\n                (_sender, _dstEid, _totalNativeFee, _payInLzToken)\n            );\n            (bool success, bytes memory result) = treasury.safeCall(treasuryGasLimit, 0, TREASURY_MAX_COPY, callData);\n\n            (treasuryNativeFee, lzTokenFee) = _parseTreasuryResult(_totalNativeFee, _payInLzToken, success, result);\n            // fee should be in lzTokenFee if payInLzToken, otherwise in native\n            if (treasuryNativeFee > 0) {\n                fees[treasury] += treasuryNativeFee;\n            }\n        }\n    }\n\n    /// @dev the abstract process for quote() is:\n    /// 0/ split out the executor options and options of other workers\n    /// 1/ quote workers\n    /// 2/ quote executor\n    /// 3/ quote treasury\n    /// @return nativeFee, lzTokenFee\n    function _quote(\n        address _sender,\n        uint32 _dstEid,\n        uint256 _msgSize,\n        bool _payInLzToken,\n        bytes calldata _options\n    ) internal view returns (uint256, uint256) {\n        (bytes memory executorOptions, WorkerOptions[] memory validationOptions) = _splitOptions(_options);\n\n        // quote the verifier used in the library. for ULN, it is a list of DVNs\n        uint256 nativeFee = _quoteVerifier(_sender, _dstEid, validationOptions);\n\n        // quote executor\n        ExecutorConfig memory config = getExecutorConfig(_sender, _dstEid);\n        // assert msg size\n        _assertMessageSize(_msgSize, config.maxMessageSize);\n\n        nativeFee += ILayerZeroExecutor(config.executor).getFee(_dstEid, _sender, _msgSize, executorOptions);\n\n        // quote treasury\n        (uint256 treasuryNativeFee, uint256 lzTokenFee) = _quoteTreasury(_sender, _dstEid, nativeFee, _payInLzToken);\n        nativeFee += treasuryNativeFee;\n\n        return (nativeFee, lzTokenFee);\n    }\n\n    /// @dev this interface should be DoS-free if the user is paying with native. properties\n    /// 1/ treasury can return an overly high lzToken fee\n    /// 2/ if treasury returns an overly high native fee, it will be capped by maxNativeFee,\n    ///    which can be reasoned with the configurations\n    /// 3/ the owner can not configure the treasury in a way that force this function to revert\n    function _quoteTreasury(\n        address _sender,\n        uint32 _dstEid,\n        uint256 _totalNativeFee,\n        bool _payInLzToken\n    ) internal view returns (uint256 nativeFee, uint256 lzTokenFee) {\n        // treasury must be set, and it has to be a contract\n        if (treasury != address(0x0)) {\n            bytes memory callData = abi.encodeCall(\n                ILayerZeroTreasury.getFee,\n                (_sender, _dstEid, _totalNativeFee, _payInLzToken)\n            );\n            (bool success, bytes memory result) = treasury.safeStaticCall(\n                treasuryGasLimit,\n                TREASURY_MAX_COPY,\n                callData\n            );\n\n            return _parseTreasuryResult(_totalNativeFee, _payInLzToken, success, result);\n        }\n    }\n\n    function _parseTreasuryResult(\n        uint256 _totalNativeFee,\n        bool _payInLzToken,\n        bool _success,\n        bytes memory _result\n    ) internal view returns (uint256 nativeFee, uint256 lzTokenFee) {\n        // failure, charges nothing\n        if (!_success || _result.length < TREASURY_MAX_COPY) return (0, 0);\n\n        // parse the result\n        uint256 treasureFeeQuote = abi.decode(_result, (uint256));\n        if (_payInLzToken) {\n            lzTokenFee = treasureFeeQuote;\n        } else {\n            // pay in native\n            // we must prevent high-treasuryFee Dos attack\n            // nativeFee = min(treasureFeeQuote, maxNativeFee)\n            // opportunistically raise the maxNativeFee to be the same as _totalNativeFee\n            // can't use the _totalNativeFee alone because the oapp can use custom workers to force the fee to 0.\n            // maxNativeFee = max (_totalNativeFee, treasuryNativeFeeCap)\n            uint256 maxNativeFee = _totalNativeFee > treasuryNativeFeeCap ? _totalNativeFee : treasuryNativeFeeCap;\n\n            // min (treasureFeeQuote, nativeFeeCap)\n            nativeFee = treasureFeeQuote > maxNativeFee ? maxNativeFee : treasureFeeQuote;\n        }\n    }\n\n    /// @dev authenticated by msg.sender only\n    function _debitFee(uint256 _amount) internal {\n        uint256 fee = fees[msg.sender];\n        if (_amount > fee) revert LZ_MessageLib_InvalidAmount(_amount, fee);\n        unchecked {\n            fees[msg.sender] = fee - _amount;\n        }\n    }\n\n    function _setTreasury(address _treasury) internal {\n        treasury = _treasury;\n        emit TreasurySet(_treasury);\n    }\n\n    function _setExecutorConfig(uint32 _remoteEid, address _oapp, ExecutorConfig memory _config) internal {\n        executorConfigs[_oapp][_remoteEid] = _config;\n        emit ExecutorConfigSet(_oapp, _remoteEid, _config);\n    }\n\n    // ======================= Virtual =======================\n    /// @dev these two functions will be overridden with specific logics of the library function\n    function _quoteVerifier(\n        address _oapp,\n        uint32 _eid,\n        WorkerOptions[] memory _options\n    ) internal view virtual returns (uint256 nativeFee);\n\n    /// @dev this function will split the options into executorOptions and validationOptions\n    function _splitOptions(\n        bytes calldata _options\n    ) internal view virtual returns (bytes memory executorOptions, WorkerOptions[] memory validationOptions);\n}\n"
    },
    "contracts/messagelib/contracts/SendLibBaseE2.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport { ERC165 } from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\nimport { ILayerZeroEndpointV2, MessagingFee } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\nimport { IMessageLib, MessageLibType } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessageLib.sol\";\nimport { ISendLib, Packet } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ISendLib.sol\";\nimport { Transfer } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/Transfer.sol\";\n\nimport { SendLibBase, WorkerOptions, ExecutorConfig } from \"./SendLibBase.sol\";\n\n/// @dev send-side message library base contract on endpoint v2.\n/// design: the high level logic is the same as SendLibBaseE1\n/// 1/ with added interfaces\n/// 2/ adapt the functions to the new types, like uint32 for eid, address for sender.\nabstract contract SendLibBaseE2 is SendLibBase, ERC165, ISendLib {\n    event NativeFeeWithdrawn(address worker, address receiver, uint256 amount);\n    event LzTokenFeeWithdrawn(address lzToken, address receiver, uint256 amount);\n\n    error LZ_MessageLib_NotTreasury();\n    error LZ_MessageLib_CannotWithdrawAltToken();\n\n    constructor(\n        address _endpoint,\n        uint256 _treasuryGasLimit,\n        uint256 _treasuryNativeFeeCap\n    ) SendLibBase(_endpoint, ILayerZeroEndpointV2(_endpoint).eid(), _treasuryGasLimit, _treasuryNativeFeeCap) {}\n\n    function supportsInterface(bytes4 _interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            _interfaceId == type(IMessageLib).interfaceId ||\n            _interfaceId == type(ISendLib).interfaceId ||\n            super.supportsInterface(_interfaceId);\n    }\n\n    // ========================= OnlyEndpoint =========================\n    // @dev this function is marked as virtual and public for testing purpose\n    function send(\n        Packet calldata _packet,\n        bytes calldata _options,\n        bool _payInLzToken\n    ) public virtual onlyEndpoint returns (MessagingFee memory, bytes memory) {\n        (bytes memory encodedPacket, uint256 totalNativeFee) = _payWorkers(_packet, _options);\n\n        (uint256 treasuryNativeFee, uint256 lzTokenFee) = _payTreasury(\n            _packet.sender,\n            _packet.dstEid,\n            totalNativeFee,\n            _payInLzToken\n        );\n        totalNativeFee += treasuryNativeFee;\n\n        return (MessagingFee(totalNativeFee, lzTokenFee), encodedPacket);\n    }\n\n    // ========================= OnlyOwner =========================\n    function setTreasury(address _treasury) external onlyOwner {\n        _setTreasury(_treasury);\n    }\n\n    // ========================= External =========================\n    /// @dev E2 only\n    function withdrawFee(address _to, uint256 _amount) external {\n        _debitFee(_amount);\n        address nativeToken = ILayerZeroEndpointV2(endpoint).nativeToken();\n        // transfers native if nativeToken == address(0x0)\n        Transfer.nativeOrToken(nativeToken, _to, _amount);\n        emit NativeFeeWithdrawn(msg.sender, _to, _amount);\n    }\n\n    /// @dev _lzToken is a user-supplied value because lzToken might change in the endpoint before all lzToken can be taken out\n    /// @dev E2 only\n    /// @dev treasury only function\n    function withdrawLzTokenFee(address _lzToken, address _to, uint256 _amount) external {\n        if (msg.sender != treasury) revert LZ_MessageLib_NotTreasury();\n\n        // lz token cannot be the same as the native token\n        if (ILayerZeroEndpointV2(endpoint).nativeToken() == _lzToken) revert LZ_MessageLib_CannotWithdrawAltToken();\n\n        Transfer.token(_lzToken, _to, _amount);\n\n        emit LzTokenFeeWithdrawn(_lzToken, _to, _amount);\n    }\n\n    // ========================= View =========================\n    function quote(\n        Packet calldata _packet,\n        bytes calldata _options,\n        bool _payInLzToken\n    ) external view returns (MessagingFee memory) {\n        (uint256 nativeFee, uint256 lzTokenFee) = _quote(\n            _packet.sender,\n            _packet.dstEid,\n            _packet.message.length,\n            _payInLzToken,\n            _options\n        );\n        return MessagingFee(nativeFee, lzTokenFee);\n    }\n\n    function messageLibType() external pure virtual override returns (MessageLibType) {\n        return MessageLibType.Send;\n    }\n\n    // ========================= Internal =========================\n    /// 1/ handle executor\n    /// 2/ handle other workers\n    function _payWorkers(\n        Packet calldata _packet,\n        bytes calldata _options\n    ) internal returns (bytes memory encodedPacket, uint256 totalNativeFee) {\n        // split workers options\n        (bytes memory executorOptions, WorkerOptions[] memory validationOptions) = _splitOptions(_options);\n\n        // handle executor\n        ExecutorConfig memory config = getExecutorConfig(_packet.sender, _packet.dstEid);\n        uint256 msgSize = _packet.message.length;\n        _assertMessageSize(msgSize, config.maxMessageSize);\n        totalNativeFee += _payExecutor(config.executor, _packet.dstEid, _packet.sender, msgSize, executorOptions);\n\n        // handle other workers\n        (uint256 verifierFee, bytes memory packetBytes) = _payVerifier(_packet, validationOptions); //for ULN, it will be dvns\n        totalNativeFee += verifierFee;\n\n        encodedPacket = packetBytes;\n    }\n\n    // ======================= Virtual =======================\n    // For implementation to override\n    function _payVerifier(\n        Packet calldata _packet,\n        WorkerOptions[] memory _options\n    ) internal virtual returns (uint256 otherWorkerFees, bytes memory encodedPacket);\n\n    // receive native token from endpoint\n    receive() external payable virtual {}\n}\n"
    },
    "contracts/messagelib/contracts/Treasury.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport { ISendLib } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ISendLib.sol\";\nimport { Transfer } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/Transfer.sol\";\n\nimport { ILayerZeroTreasury } from \"./interfaces/ILayerZeroTreasury.sol\";\n\ncontract Treasury is Ownable, ILayerZeroTreasury {\n    uint256 public nativeBP;\n    uint256 public lzTokenFee;\n    bool public lzTokenEnabled;\n\n    error LZ_Treasury_LzTokenNotEnabled();\n\n    function getFee(\n        address /*_sender*/,\n        uint32 /*_eid*/,\n        uint256 _totalFee,\n        bool _payInLzToken\n    ) external view override returns (uint256) {\n        return _getFee(_totalFee, _payInLzToken);\n    }\n\n    function payFee(\n        address /*_sender*/,\n        uint32 /*_eid*/,\n        uint256 _totalFee,\n        bool _payInLzToken\n    ) external payable override returns (uint256) {\n        return _getFee(_totalFee, _payInLzToken);\n    }\n\n    function setLzTokenEnabled(bool _lzTokenEnabled) external onlyOwner {\n        lzTokenEnabled = _lzTokenEnabled;\n    }\n\n    function setNativeFeeBP(uint256 _nativeBP) external onlyOwner {\n        nativeBP = _nativeBP;\n    }\n\n    function setLzTokenFee(uint256 _lzTokenFee) external onlyOwner {\n        lzTokenFee = _lzTokenFee;\n    }\n\n    function withdrawLzToken(address _messageLib, address _lzToken, address _to, uint256 _amount) external onlyOwner {\n        ISendLib(_messageLib).withdrawLzTokenFee(_lzToken, _to, _amount);\n    }\n\n    function withdrawNativeFee(address _messageLib, address payable _to, uint256 _amount) external onlyOwner {\n        ISendLib(_messageLib).withdrawFee(_to, _amount);\n    }\n\n    // this is for withdrawing lz token sent to this contract by uln301 and fee handler\n    // and to withdraw any native sent over via payFee\n    function withdrawToken(address _token, address _to, uint256 _amount) external onlyOwner {\n        // transfers native if _token is address(0x0)\n        Transfer.nativeOrToken(_token, _to, _amount);\n    }\n\n    // ======================= Internal =======================\n\n    function _getFee(uint256 _totalFee, bool _payInLzToken) internal view returns (uint256) {\n        if (_payInLzToken) {\n            if (!lzTokenEnabled) revert LZ_Treasury_LzTokenNotEnabled();\n            return lzTokenFee;\n        } else {\n            return (_totalFee * nativeBP) / 10000;\n        }\n    }\n}\n"
    },
    "contracts/messagelib/contracts/uln/dvn/adapters/arbitrum/ArbitrumDVNAdapterL1.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.20;\n\nimport { IInbox } from \"@arbitrum/nitro-contracts/src/bridge/IInbox.sol\";\n\nimport { ArbitrumDVNAdapterL2 } from \"./ArbitrumDVNAdapterL2.sol\";\nimport { DVNAdapterBase } from \"../DVNAdapterBase.sol\";\nimport { DVNAdapterMessageCodec } from \"../libs/DVNAdapterMessageCodec.sol\";\n\ncontract ArbitrumDVNAdapterL1 is DVNAdapterBase {\n    // --- Config Struct ---\n    struct DstConfig {\n        uint16 multiplierBps;\n        uint256 maxSubmissionCost;\n        uint256 gasLimit;\n        uint256 maxFeePerGas;\n    }\n\n    // --- Events ---\n    event RetryableTicketCreated(uint256 indexed ticketId);\n    error OnlyArbitrum();\n\n    uint32 public immutable arbitrumEid; // eid % 30000 (v1 eid)\n    IInbox public immutable inbox;\n\n    address public peer; // L2 adapter\n    DstConfig public dstConfig;\n\n    constructor(\n        address[] memory _admins,\n        uint32 _arbitrumEid,\n        address _inbox\n    ) DVNAdapterBase(msg.sender, _admins, 12000) {\n        arbitrumEid = _arbitrumEid; // eid % 30000 (v1 eid)\n        inbox = IInbox(_inbox);\n    }\n\n    // --- Admin ---\n    function setPeer(address _peer) external onlyRole(ADMIN_ROLE) {\n        peer = _peer;\n    }\n\n    function setDstConfig(\n        uint16 _multiplierBps,\n        uint256 _maxSubmissionCost,\n        uint256 _gasLimit,\n        uint256 _maxFeePerGas\n    ) external onlyRole(ADMIN_ROLE) {\n        dstConfig = DstConfig({\n            multiplierBps: _multiplierBps,\n            maxSubmissionCost: _maxSubmissionCost,\n            gasLimit: _gasLimit,\n            maxFeePerGas: _maxFeePerGas\n        });\n    }\n\n    // --- Send ---\n    function assignJob(\n        AssignJobParam calldata _param,\n        bytes calldata /*_options*/\n    ) external payable override onlyRole(MESSAGE_LIB_ROLE) onlyAcl(_param.sender) returns (uint256 fee) {\n        DstConfig storage config = dstConfig;\n        fee = _getArbitrumFee(_param.dstEid, config);\n\n        bytes memory payload = abi.encodeWithSelector(\n            ArbitrumDVNAdapterL2.verify.selector,\n            DVNAdapterMessageCodec.encode(\n                receiveLibs[msg.sender][_param.dstEid],\n                _param.packetHeader,\n                _param.payloadHash\n            )\n        );\n\n        // fee estimation: https://github.com/OffchainLabs/arbitrum-sdk/blob/main/src/lib/message/L1ToL2MessageCreator.ts#L52\n        uint256 ticketID = inbox.createRetryableTicket{ value: fee }(\n            peer,\n            0,\n            config.maxSubmissionCost,\n            peer,\n            peer,\n            config.gasLimit,\n            config.maxFeePerGas,\n            payload\n        );\n        emit RetryableTicketCreated(ticketID);\n\n        // adjust fee based on multiplier\n        //        if (workerFeeLib != address(0)) {\n        //            fee = IDVNAdapterFeeLib(workerFeeLib).getFee(\n        //                _param.dstEid,\n        //                _param.sender,\n        //                defaultMultiplierBps,\n        //                config.multiplierBps,\n        //                fee\n        //            );\n        //        }\n    }\n\n    // --- View ---\n    function getFee(\n        uint32 _dstEid,\n        uint64 /*_confirmations*/,\n        address _sender,\n        bytes calldata /*_options*/\n    ) public view override onlyAcl(_sender) returns (uint256 fee) {\n        DstConfig storage config = dstConfig;\n        fee = _getArbitrumFee(_dstEid, config);\n\n        // adjust fee based on multiplier\n        //        if (workerFeeLib != address(0)) {\n        //            fee = IDVNAdapterFeeLib(workerFeeLib).getFee(\n        //                _dstEid,\n        //                _sender,\n        //                defaultMultiplierBps,\n        //                config.multiplierBps,\n        //                fee\n        //            );\n        //        }\n    }\n\n    function _getArbitrumFee(uint32 _dstEid, DstConfig storage _dstConfig) internal view returns (uint256 fee) {\n        if (_dstEid % 30000 != arbitrumEid) revert OnlyArbitrum();\n        fee = _dstConfig.maxSubmissionCost + _dstConfig.gasLimit * _dstConfig.maxFeePerGas;\n    }\n}\n"
    },
    "contracts/messagelib/contracts/uln/dvn/adapters/arbitrum/ArbitrumDVNAdapterL2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.20;\n\nimport { AddressAliasHelper } from \"@arbitrum/nitro-contracts/src/libraries/AddressAliasHelper.sol\";\n\nimport { DVNAdapterBase } from \"../DVNAdapterBase.sol\";\n\ncontract ArbitrumDVNAdapterL2 is DVNAdapterBase {\n    // --- Errors ---\n    error UntrustedPeer(address peer);\n\n    // --- Events ---\n    event PeerSet(address peer);\n\n    // --- Variables ---\n    address public peer; // L1 adapter\n\n    constructor(address[] memory _admins) DVNAdapterBase(msg.sender, _admins, 12000) {}\n\n    // --- Admin ---\n    function setPeer(address _peer) external onlyRole(ADMIN_ROLE) {\n        peer = _peer;\n        emit PeerSet(_peer);\n    }\n\n    // --- Send ---\n    function assignJob(\n        AssignJobParam calldata /*_param*/,\n        bytes calldata /*_options*/\n    ) external payable override returns (uint256) {\n        revert DVNAdapter_NotImplemented();\n    }\n\n    function getFee(\n        uint32 /*_dstEid*/,\n        uint64 /*_confirmations*/,\n        address /*_sender*/,\n        bytes calldata /*_options*/\n    ) external pure override returns (uint256) {\n        revert DVNAdapter_NotImplemented();\n    }\n\n    // --- Receive ---\n    function verify(bytes calldata _payload) external {\n        // To check that message came from L1, we check that the sender is the L1 contract's L2 alias.\n        if (msg.sender != AddressAliasHelper.applyL1ToL2Alias(peer)) revert UntrustedPeer(msg.sender);\n        _decodeAndVerify(0, _payload); //todo: fix\n    }\n}\n"
    },
    "contracts/messagelib/contracts/uln/dvn/adapters/axelar/AxelarDVNAdapter.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { AxelarExecutable } from \"@axelar-network/axelar-gmp-sdk-solidity/contracts/executable/AxelarExecutable.sol\";\nimport { ISendLib } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ISendLib.sol\";\n\nimport { DVNAdapterBase } from \"../DVNAdapterBase.sol\";\nimport { IAxelarDVNAdapter } from \"../../../interfaces/adapters/IAxelarDVNAdapter.sol\";\nimport { IAxelarDVNAdapterFeeLib } from \"../../../interfaces/adapters/IAxelarDVNAdapterFeeLib.sol\";\n\ninterface ISendLibBase {\n    function fees(address _worker) external view returns (uint256);\n}\n\n/// @title AxelarDVNAdapter\n/// @dev How Axelar DVN Adapter works:\n///  1. Estimate gas fee off-chain using the Axelar SDK.\n///     refer to https://docs.axelar.dev/dev/axelarjs-sdk/axelar-query-api#estimategasfee\n///  2. Pay gas fee by calling `payNativeGasForContractCall` on the AxelarGasService contract.\n///     refer to https://docs.axelar.dev/dev/general-message-passing/gas-services/pay-gas#paynativegasforcontractcall\n///  3. Send message by calling `callContract` on the AxelarGateway contract.\n///     refer to https://docs.axelar.dev/dev/general-message-passing/gmp-messages#call-a-contract-on-chain-b-from-chain-a\n///  4. Refund surplus gas fee asynchronously.\n///     refer to https://docs.axelar.dev/dev/general-message-passing/gas-services/refund\n/// @dev Recovery:\n///  1. If not enough gas fee is paid, the message will be hangup on source chain and can `add gas` to retry.\n///     refer to https://docs.axelar.dev/dev/general-message-passing/recovery#increase-gas-payment-to-the-gas-receiver-on-the-source-chain\n///  2. If the message is not executed on the destination chain, you can manually retry by calling `execute` on the `ReceiveAxelarDVNAdapter` contract.\n///     refer to https://docs.axelar.dev/dev/general-message-passing/recovery#manually-execute-a-transfer\n/// @dev As the Gas is estimated off-chain, we need to update the gas fee periodically on-chain by calling `setNativeGasFee` with the new fee.\ncontract AxelarDVNAdapter is DVNAdapterBase, AxelarExecutable, IAxelarDVNAdapter {\n    mapping(string srcChainName => SrcConfig) public srcConfig; // by chain name\n    mapping(uint32 dstEid => DstConfig) public dstConfig; // by dstEid\n\n    // set default multiplier to 2.5x\n    constructor(\n        address[] memory _admins,\n        address _gateway\n    ) AxelarExecutable(_gateway) DVNAdapterBase(msg.sender, _admins, 10000) {}\n\n    // ========================= OnlyAdmin =========================\n    function setDstConfig(DstConfigParam[] calldata _params) external onlyRole(ADMIN_ROLE) {\n        for (uint256 i = 0; i < _params.length; i++) {\n            DstConfigParam calldata param = _params[i];\n\n            uint32 eid = param.eid % 30000;\n\n            // set once per chainName\n            // only one adapter per dvn that services both endpoint v1 and v2\n            // we standardize the eid stored here with mod 30000\n            if (bytes(dstConfig[eid].chainName).length == 0) {\n                dstConfig[eid].chainName = param.chainName;\n                dstConfig[eid].peer = param.peer;\n                srcConfig[param.chainName].eid = eid;\n                srcConfig[param.chainName].peer = param.peer;\n            }\n\n            dstConfig[eid].multiplierBps = param.multiplierBps;\n            dstConfig[eid].nativeGasFee = param.nativeGasFee;\n        }\n\n        emit DstConfigSet(_params);\n    }\n\n    /// @notice sets message fee in native gas for destination chains.\n    /// @dev Axelar does not support quoting fee on-chain. Instead, the fee needs to be obtained off-chain by querying through the Axelar SDK.\n    /// @dev The fee may change over time when token prices change, requiring admins to monitor and make necessary updates to reflect the actual fee.\n    /// @dev Adding a buffer to the required fee is advisable. Any surplus fee will be refunded asynchronously if it exceeds the necessary amount.\n    /// https://docs.axelar.dev/dev/general-message-passing/gas-services/pay-gas\n    /// https://github.com/axelarnetwork/axelarjs/blob/070c8fe061f1082e79772fdc5c4675c0237bbba2/packages/api/src/axelar-query/isomorphic.ts#L54\n    /// https://github.com/axelarnetwork/axelar-cgp-solidity/blob/d4536599321774927bf9716178a9e360f8e0efac/contracts/gas-service/AxelarGasService.sol#L403\n    function setNativeGasFee(NativeGasFeeParam[] calldata _params) external onlyRole(ADMIN_ROLE) {\n        for (uint256 i = 0; i < _params.length; i++) {\n            NativeGasFeeParam calldata param = _params[i];\n            dstConfig[param.dstEid % 30000].nativeGasFee = param.nativeGasFee;\n        }\n        emit NativeGasFeeSet(_params);\n    }\n\n    // ========================= OnlyWorkerFeeLib =========================\n    function withdrawToFeeLib(address _sendLib) external {\n        if (msg.sender != workerFeeLib) revert AxelarDVNAdapter_OnlyWorkerFeeLib();\n\n        _withdrawFeeFromSendLib(_sendLib, workerFeeLib);\n    }\n\n    // ========================= OnlyMessageLib =========================\n    function assignJob(\n        AssignJobParam calldata _param,\n        bytes calldata _options\n    ) external payable override onlyAcl(_param.sender) returns (uint totalFee) {\n        bytes32 receiveLib = _getAndAssertReceiveLib(msg.sender, _param.dstEid);\n\n        IAxelarDVNAdapterFeeLib.Param memory feeLibParam = IAxelarDVNAdapterFeeLib.Param({\n            dstEid: _param.dstEid,\n            confirmations: _param.confirmations,\n            sender: _param.sender,\n            defaultMultiplierBps: defaultMultiplierBps\n        });\n        DstConfig memory config = dstConfig[_param.dstEid % 30000];\n\n        bytes memory payload = _encode(receiveLib, _param.packetHeader, _param.payloadHash);\n\n        totalFee = IAxelarDVNAdapterFeeLib(workerFeeLib).getFeeOnSend(\n            feeLibParam,\n            config,\n            payload,\n            _options,\n            msg.sender\n        );\n\n        gateway.callContract(config.chainName, config.peer, payload);\n    }\n\n    // ========================= View =========================\n    function getFee(\n        uint32 _dstEid,\n        uint64 _confirmations,\n        address _sender,\n        bytes calldata _options\n    ) external view override returns (uint256 totalFee) {\n        IAxelarDVNAdapterFeeLib.Param memory feeLibParam = IAxelarDVNAdapterFeeLib.Param(\n            _dstEid,\n            _confirmations,\n            _sender,\n            defaultMultiplierBps\n        );\n\n        totalFee = IAxelarDVNAdapterFeeLib(workerFeeLib).getFee(feeLibParam, dstConfig[_dstEid % 30000], _options);\n    }\n\n    // ========================= Internal =========================\n    function _execute(\n        string calldata _sourceChain,\n        string calldata _sourceAddress,\n        bytes calldata _payload\n    ) internal override {\n        SrcConfig memory config = srcConfig[_sourceChain];\n\n        // assert peer is the same as the source chain\n        _assertPeer(_sourceChain, _sourceAddress, config.peer);\n\n        _decodeAndVerify(config.eid, _payload);\n    }\n\n    function _assertPeer(string memory _sourceChain, string memory _sourceAddress, string memory peer) private pure {\n        if (keccak256(bytes(_sourceAddress)) != keccak256(bytes(peer))) {\n            revert AxelarDVNAdapter_UntrustedPeer(_sourceChain, _sourceAddress);\n        }\n    }\n}\n"
    },
    "contracts/messagelib/contracts/uln/dvn/adapters/axelar/AxelarDVNAdapterFeeLib.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { Proxied } from \"hardhat-deploy/solc_0.8/proxy/Proxied.sol\";\nimport { OwnableUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport { IAxelarGasService } from \"@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IAxelarGasService.sol\";\nimport { Transfer } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/Transfer.sol\";\n\nimport { IAxelarDVNAdapter } from \"../../../interfaces/adapters/IAxelarDVNAdapter.sol\";\nimport { IAxelarDVNAdapterFeeLib } from \"../../../interfaces/adapters/IAxelarDVNAdapterFeeLib.sol\";\nimport { ILayerZeroPriceFeed } from \"../../../../interfaces/ILayerZeroPriceFeed.sol\";\n\ncontract AxelarDVNAdapterFeeLib is OwnableUpgradeable, Proxied, IAxelarDVNAdapterFeeLib {\n    uint16 internal constant BPS_DENOMINATOR = 10000;\n\n    /// @dev to be applied to native gas fee before sending to Axelar Gas Service\n    uint16 public nativeGasFeeMultiplierBps;\n\n    IAxelarDVNAdapter public dvn;\n    IAxelarGasService public gasService;\n    ILayerZeroPriceFeed public priceFeed;\n\n    mapping(uint32 dstEid => DstConfig) public dstConfig;\n\n    function initialize(\n        address _gasService,\n        address _dvn,\n        uint16 _nativeGasFeeMultiplierBps\n    ) external proxied initializer {\n        __Ownable_init();\n        gasService = IAxelarGasService(_gasService);\n        dvn = IAxelarDVNAdapter(_dvn);\n        nativeGasFeeMultiplierBps = _nativeGasFeeMultiplierBps;\n    }\n\n    // ================================ OnlyOwner ================================\n    function withdrawToken(address _token, address _to, uint256 _amount) external onlyOwner {\n        // transfers native if _token is address(0x0)\n        Transfer.nativeOrToken(_token, _to, _amount);\n        emit TokenWithdrawn(_token, _to, _amount);\n    }\n\n    function setGasService(address _gasService) external onlyOwner {\n        gasService = IAxelarGasService(_gasService);\n        emit GasServiceSet(_gasService);\n    }\n\n    function setPriceFeed(address _priceFeed) external onlyOwner {\n        priceFeed = ILayerZeroPriceFeed(_priceFeed);\n        emit PriceFeedSet(_priceFeed);\n    }\n\n    function setDstConfig(DstConfigParam[] calldata _param) external onlyOwner {\n        for (uint256 i = 0; i < _param.length; i++) {\n            DstConfigParam calldata param = _param[i];\n            dstConfig[param.dstEid] = DstConfig({ gas: param.gas, floorMarginUSD: param.floorMarginUSD });\n        }\n        emit DstConfigSet(_param);\n    }\n\n    function setNativeGasFeeMultiplierBps(uint16 _multiplierBps) external onlyOwner {\n        nativeGasFeeMultiplierBps = _multiplierBps;\n        emit NativeGasFeeMultiplierBpsSet(_multiplierBps);\n    }\n\n    // ================================ External ================================\n    function getFeeOnSend(\n        Param calldata _param,\n        IAxelarDVNAdapter.DstConfig calldata _dstConfig,\n        bytes memory _payload,\n        bytes calldata _options,\n        address _sendLib\n    ) external payable returns (uint256 totalFee) {\n        if (_dstConfig.nativeGasFee == 0) revert AxelarDVNAdapter_EidNotSupported(_param.dstEid);\n        if (_options.length > 0) revert AxelarDVNAdapter_OptionsUnsupported();\n\n        totalFee = _applyPremium(_dstConfig.multiplierBps, _param.defaultMultiplierBps, _dstConfig.nativeGasFee);\n\n        uint256 feeToAxelar = _getAxelarFeeWithBuffer(_dstConfig.nativeGasFee);\n        // withdraw from uln to fee lib if not enough balance\n        uint256 balance = address(this).balance;\n        if (balance < feeToAxelar) {\n            dvn.withdrawToFeeLib(_sendLib);\n\n            // revert if still not enough\n            balance = address(this).balance;\n            if (balance < feeToAxelar) revert AxelarDVNAdapter_InsufficientBalance(balance, feeToAxelar);\n        }\n\n        // pay axelar gas service\n        gasService.payNativeGasForContractCall{ value: feeToAxelar }(\n            msg.sender, // sender\n            _dstConfig.chainName, // destinationChain\n            _dstConfig.peer, // destinationAddress\n            _payload, // payload\n            address(this) // refundAddress\n        );\n    }\n\n    function getFee(\n        Param calldata _param,\n        IAxelarDVNAdapter.DstConfig calldata _dstConfig,\n        bytes calldata _options\n    ) external pure returns (uint256 totalFee) {\n        if (_dstConfig.nativeGasFee == 0) revert AxelarDVNAdapter_EidNotSupported(_param.dstEid);\n        if (_options.length > 0) revert AxelarDVNAdapter_OptionsUnsupported();\n\n        totalFee = _applyPremium(_dstConfig.multiplierBps, _param.defaultMultiplierBps, _dstConfig.nativeGasFee);\n    }\n\n    // ================================ Internal ================================\n    function _getAxelarFeeWithBuffer(uint256 _nativeGasFee) internal view returns (uint256) {\n        return (_nativeGasFee * nativeGasFeeMultiplierBps) / BPS_DENOMINATOR;\n    }\n\n    function _applyPremium(\n        uint16 multiplierBps,\n        uint16 defaultMultiplierBps,\n        uint256 fee\n    ) internal pure returns (uint256) {\n        uint256 multiplier = multiplierBps == 0 ? defaultMultiplierBps : multiplierBps;\n        return (fee * multiplier) / BPS_DENOMINATOR;\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts/messagelib/contracts/uln/dvn/adapters/CCIP/CCIPDVNAdapter.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { IRouterClient } from \"@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol\";\nimport { IAny2EVMMessageReceiver } from \"@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IAny2EVMMessageReceiver.sol\";\nimport { Client } from \"@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol\";\n\nimport { DVNAdapterBase } from \"../DVNAdapterBase.sol\";\nimport { ICCIPDVNAdapter } from \"../../../interfaces/adapters/ICCIPDVNAdapter.sol\";\nimport { ICCIPDVNAdapterFeeLib } from \"../../../interfaces/adapters/ICCIPDVNAdapterFeeLib.sol\";\n\n/// @title CCIPDVNAdapter\n/// @dev How CCIP DVN Adapter works:\n/// 1. Estimate gas cost for the message on-chain by calling `getFee` on the Router contract.\n///     refer to https://docs.chain.link/ccip/api-reference/i-router-client#getfee\n/// 2. Call `ccipSend` on the Router contract to send the message.\n///     refer to https://docs.chain.link/ccip/api-reference/i-router-client#ccipsend\n/// @dev Recovery:\n/// 1. If not enough gas paid, the message will be failed to execute on the destination chain, you can manually retry by calling `manuallyExecute` on the `OffRamp` contract.\n///     refer to https://github.com/smartcontractkit/ccip/blob/ccip-develop/contracts/src/v0.8/ccip/offRamp/EVM2EVMOffRamp.sol#L222\ncontract CCIPDVNAdapter is DVNAdapterBase, IAny2EVMMessageReceiver, ICCIPDVNAdapter {\n    address private constant NATIVE_GAS_TOKEN_ADDRESS = address(0);\n\n    IRouterClient public immutable router;\n\n    mapping(uint32 dstEid => DstConfig) public dstConfig;\n    mapping(uint64 srcChainSelector => SrcConfig) public srcConfig;\n\n    constructor(address[] memory _admins, address _router) DVNAdapterBase(msg.sender, _admins, 12000) {\n        router = IRouterClient(_router);\n    }\n\n    // ========================= OnlyAdmin =========================\n    /// @notice sets configuration for destination chains\n    /// @param _params array of chain configurations\n    function setDstConfig(DstConfigParam[] calldata _params) external onlyRole(ADMIN_ROLE) {\n        for (uint256 i = 0; i < _params.length; i++) {\n            DstConfigParam calldata param = _params[i];\n\n            uint32 eid = param.eid % 30000;\n\n            // set once per chainSelector\n            // only one adapter per dvn that services both endpoint v1 and v2\n            // we standardize the eid stored here with mod 30000\n            if (dstConfig[eid].chainSelector == 0) {\n                dstConfig[eid].chainSelector = param.chainSelector;\n                dstConfig[eid].peer = param.peer;\n                srcConfig[param.chainSelector].eid = eid;\n                srcConfig[param.chainSelector].peer = param.peer;\n            }\n\n            dstConfig[eid].multiplierBps = param.multiplierBps;\n            dstConfig[eid].gas = param.gas;\n        }\n\n        emit DstConfigSet(_params);\n    }\n\n    // ========================= OnlyMessageLib =========================\n    function assignJob(\n        AssignJobParam calldata _param,\n        bytes calldata _options\n    ) external payable override onlyAcl(_param.sender) returns (uint256 totalFee) {\n        bytes32 receiveLib = _getAndAssertReceiveLib(msg.sender, _param.dstEid);\n\n        ICCIPDVNAdapterFeeLib.Param memory feeLibParam = ICCIPDVNAdapterFeeLib.Param(\n            _param.dstEid,\n            _param.confirmations,\n            _param.sender,\n            defaultMultiplierBps\n        );\n\n        DstConfig memory config = dstConfig[_param.dstEid % 30000];\n\n        bytes memory data = _encode(receiveLib, _param.packetHeader, _param.payloadHash);\n        Client.EVM2AnyMessage memory message = _createCCIPMessage(data, config.peer, config.gas);\n\n        IRouterClient ccipRouter = router;\n        uint256 ccipFee;\n        (ccipFee, totalFee) = ICCIPDVNAdapterFeeLib(workerFeeLib).getFeeOnSend(\n            feeLibParam,\n            config,\n            message,\n            _options,\n            ccipRouter\n        );\n\n        _assertBalanceAndWithdrawFee(msg.sender, ccipFee);\n\n        ccipRouter.ccipSend{ value: ccipFee }(config.chainSelector, message);\n    }\n\n    // ========================= OnlyRouter =========================\n    function ccipReceive(Client.Any2EVMMessage calldata _message) external {\n        if (msg.sender != address(router)) revert CCIPDVNAdapter_InvalidRouter(msg.sender);\n\n        SrcConfig memory config = srcConfig[_message.sourceChainSelector];\n\n        _assertPeer(_message.sourceChainSelector, _message.sender, config.peer);\n\n        _decodeAndVerify(config.eid, _message.data);\n    }\n\n    // ========================= View =========================\n    function getFee(\n        uint32 _dstEid,\n        uint64 _confirmations,\n        address _sender,\n        bytes calldata _options\n    ) external view override onlyAcl(_sender) returns (uint256 totalFee) {\n        ICCIPDVNAdapterFeeLib.Param memory feeLibParam = ICCIPDVNAdapterFeeLib.Param(\n            _dstEid,\n            _confirmations,\n            _sender,\n            defaultMultiplierBps\n        );\n\n        DstConfig memory config = dstConfig[_dstEid % 30000];\n\n        bytes memory data = _encodeEmpty();\n        Client.EVM2AnyMessage memory message = _createCCIPMessage(data, config.peer, config.gas);\n\n        totalFee = ICCIPDVNAdapterFeeLib(workerFeeLib).getFee(feeLibParam, config, message, _options, router);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAny2EVMMessageReceiver).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    // ========================= Internal =========================\n    function _createCCIPMessage(\n        bytes memory _data,\n        bytes memory _receiver,\n        uint256 _gas\n    ) private pure returns (Client.EVM2AnyMessage memory message) {\n        message = Client.EVM2AnyMessage({\n            receiver: _receiver,\n            data: _data,\n            tokenAmounts: new Client.EVMTokenAmount[](0), // Empty array indicating no tokens are being sent\n            extraArgs: Client._argsToBytes(Client.EVMExtraArgsV1({ gasLimit: _gas, strict: false })),\n            feeToken: NATIVE_GAS_TOKEN_ADDRESS\n        });\n    }\n\n    function _assertPeer(uint64 _sourceChainSelector, bytes memory _sourceAddress, bytes memory peer) private pure {\n        if (keccak256(_sourceAddress) != keccak256(peer)) {\n            revert CCIPDVNAdapter_UntrustedPeer(_sourceChainSelector, _sourceAddress);\n        }\n    }\n}\n"
    },
    "contracts/messagelib/contracts/uln/dvn/adapters/CCIP/CCIPDVNAdapterFeeLib.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { Proxied } from \"hardhat-deploy/solc_0.8/proxy/Proxied.sol\";\nimport { OwnableUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport { Client } from \"@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol\";\nimport { IRouterClient } from \"@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol\";\n\nimport { ICCIPDVNAdapter } from \"../../../interfaces/adapters/ICCIPDVNAdapter.sol\";\nimport { ICCIPDVNAdapterFeeLib } from \"../../../interfaces/adapters/ICCIPDVNAdapterFeeLib.sol\";\n\ncontract CCIPDVNAdapterFeeLib is OwnableUpgradeable, Proxied, ICCIPDVNAdapterFeeLib {\n    uint16 internal constant BPS_DENOMINATOR = 10000;\n\n    mapping(uint32 dstEid => DstConfig) public dstConfig;\n\n    function initialize() external proxied initializer {\n        __Ownable_init();\n    }\n\n    // ================================ OnlyOwner ===============================\n    function setDstConfig(DstConfigParam[] calldata _param) external onlyOwner {\n        for (uint256 i = 0; i < _param.length; i++) {\n            DstConfigParam calldata param = _param[i];\n\n            dstConfig[param.dstEid] = DstConfig({ floorMarginUSD: param.floorMarginUSD });\n        }\n\n        emit DstConfigSet(_param);\n    }\n\n    // ================================ External ================================\n    function getFeeOnSend(\n        Param calldata _params,\n        ICCIPDVNAdapter.DstConfig calldata _dstConfig,\n        Client.EVM2AnyMessage calldata _message,\n        bytes calldata _options,\n        IRouterClient _router\n    ) external payable returns (uint256 ccipFee, uint256 totalFee) {\n        if (_dstConfig.gas == 0) revert CCIPDVNAdapter_EidNotSupported(_params.dstEid);\n        if (_options.length > 0) revert CCIPDVNAdapter_OptionsUnsupported();\n\n        ccipFee = _router.getFee(_dstConfig.chainSelector, _message);\n        totalFee = _applyPremium(_dstConfig.multiplierBps, _params.defaultMultiplierBps, ccipFee);\n    }\n\n    function getFee(\n        Param calldata _params,\n        ICCIPDVNAdapter.DstConfig calldata _dstConfig,\n        Client.EVM2AnyMessage calldata _message,\n        bytes calldata _options,\n        IRouterClient _router\n    ) external view returns (uint256 totalFee) {\n        if (_dstConfig.gas == 0) revert CCIPDVNAdapter_EidNotSupported(_params.dstEid);\n        if (_options.length > 0) revert CCIPDVNAdapter_OptionsUnsupported();\n\n        totalFee = _router.getFee(_dstConfig.chainSelector, _message);\n        totalFee = _applyPremium(_dstConfig.multiplierBps, _params.defaultMultiplierBps, totalFee);\n    }\n\n    // ================================ Internal ================================\n    function _applyPremium(\n        uint16 _multiplierBps,\n        uint16 _defaultMultiplierBps,\n        uint256 _fee\n    ) internal pure returns (uint256 fee) {\n        uint256 multiplier = _multiplierBps == 0 ? _defaultMultiplierBps : _multiplierBps;\n        fee = (_fee * multiplier) / BPS_DENOMINATOR;\n    }\n}\n"
    },
    "contracts/messagelib/contracts/uln/dvn/adapters/DVNAdapterBase.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { Transfer } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/Transfer.sol\";\nimport { ISendLib } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ISendLib.sol\";\n\nimport { ILayerZeroDVN } from \"../../interfaces/ILayerZeroDVN.sol\";\nimport { Worker } from \"../../../Worker.sol\";\nimport { DVNAdapterMessageCodec } from \"./libs/DVNAdapterMessageCodec.sol\";\n\ninterface ISendLibBase {\n    function fees(address _worker) external view returns (uint256);\n}\n\ninterface IReceiveUln {\n    function verify(bytes calldata _packetHeader, bytes32 _payloadHash, uint64 _confirmations) external;\n}\n\nstruct ReceiveLibParam {\n    address sendLib;\n    uint32 dstEid;\n    bytes32 receiveLib;\n}\n\n/// @title SendDVNAdapterBase\n/// @notice base contract for DVN adapters\n/// @dev limitations:\n///  - doesn't accept alt token\n///  - doesn't respect block confirmations\nabstract contract DVNAdapterBase is Worker, ILayerZeroDVN {\n    // --- Errors ---\n    error DVNAdapter_InsufficientBalance(uint256 actual, uint256 requested);\n    error DVNAdapter_NotImplemented();\n    error DVNAdapter_MissingRecieveLib(address sendLib, uint32 dstEid);\n\n    event ReceiveLibsSet(ReceiveLibParam[] params);\n\n    /// @dev on change of application config, dvn adapters will not perform any additional verification\n    /// @dev to avoid messages from being stuck, all verifications from adapters will be done with the maximum possible confirmations\n    uint64 internal constant MAX_CONFIRMATIONS = type(uint64).max;\n\n    /// @dev receive lib to call verify() on at destination\n    mapping(address sendLib => mapping(uint32 dstEid => bytes32 receiveLib)) public receiveLibs;\n\n    constructor(\n        address _roleAdmin,\n        address[] memory _admins,\n        uint16 _defaultMultiplierBps\n    ) Worker(new address[](0), address(0x0), _defaultMultiplierBps, _roleAdmin, _admins) {}\n\n    // ========================= OnlyAdmin =========================\n    /// @notice sets receive lib for destination chains\n    /// @dev DEFAULT_ADMIN_ROLE can set MESSAGE_LIB_ROLE for sendLibs and use below function to set receiveLibs\n    function setReceiveLibs(ReceiveLibParam[] calldata _params) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        for (uint256 i = 0; i < _params.length; i++) {\n            ReceiveLibParam calldata param = _params[i];\n            receiveLibs[param.sendLib][param.dstEid] = param.receiveLib;\n        }\n\n        emit ReceiveLibsSet(_params);\n    }\n\n    // ========================= Internal =========================\n    function _getAndAssertReceiveLib(address _sendLib, uint32 _dstEid) internal view returns (bytes32 lib) {\n        lib = receiveLibs[_sendLib][_dstEid];\n        if (lib == bytes32(0)) revert DVNAdapter_MissingRecieveLib(_sendLib, _dstEid);\n    }\n\n    function _encode(\n        bytes32 _receiveLib,\n        bytes memory _packetHeader,\n        bytes32 _payloadHash\n    ) internal pure returns (bytes memory) {\n        return DVNAdapterMessageCodec.encode(_receiveLib, _packetHeader, _payloadHash);\n    }\n\n    function _encodeEmpty() internal pure returns (bytes memory) {\n        return\n            DVNAdapterMessageCodec.encode(bytes32(0), new bytes(DVNAdapterMessageCodec.PACKET_HEADER_SIZE), bytes32(0));\n    }\n\n    function _decodeAndVerify(uint32 _srcEid, bytes calldata _payload) internal {\n        require((DVNAdapterMessageCodec.srcEid(_payload) % 30000) == _srcEid, \"DVNAdapterBase: invalid srcEid\");\n\n        (address receiveLib, bytes memory packetHeader, bytes32 payloadHash) = DVNAdapterMessageCodec.decode(_payload);\n\n        IReceiveUln(receiveLib).verify(packetHeader, payloadHash, MAX_CONFIRMATIONS);\n    }\n\n    function _withdrawFeeFromSendLib(address _sendLib, address _to) internal {\n        uint256 fee = ISendLibBase(_sendLib).fees(address(this));\n        if (fee > 0) {\n            ISendLib(_sendLib).withdrawFee(_to, fee);\n            emit Withdraw(_sendLib, _to, fee);\n        }\n    }\n\n    function _assertBalanceAndWithdrawFee(address _sendLib, uint256 _messageFee) internal {\n        uint256 balance = address(this).balance;\n        if (balance < _messageFee) {\n            // withdraw all fees from the sendLib if balance is insufficient\n            _withdrawFeeFromSendLib(_sendLib, address(this));\n\n            // check balance again\n            balance = address(this).balance;\n            // revert if balance is still insufficient, need to transfer more funds manually to the adapter\n            if (balance < _messageFee) revert DVNAdapter_InsufficientBalance(balance, _messageFee);\n        }\n    }\n\n    /// @dev to receive refund\n    receive() external payable {}\n}\n"
    },
    "contracts/messagelib/contracts/uln/dvn/adapters/libs/DVNAdapterMessageCodec.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { AddressCast } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/AddressCast.sol\";\n\nlibrary DVNAdapterMessageCodec {\n    using AddressCast for bytes32;\n\n    error DVNAdapter_InvalidMessageSize();\n\n    uint256 private constant RECEIVE_LIB_OFFSET = 0;\n    uint256 private constant PAYLOAD_HASH_OFFSET = 32;\n    uint256 private constant PACKET_HEADER_OFFSET = 64;\n    uint256 private constant SRC_EID_OFFSET = 73; // 64 + 1 + 8\n\n    uint256 internal constant PACKET_HEADER_SIZE = 81; // version(uint8) + nonce(uint64) + path(uint32,bytes32,uint32,bytes32)\n    uint256 internal constant MESSAGE_SIZE = 32 + 32 + PACKET_HEADER_SIZE; // receive_lib(bytes32) + payloadHash(bytes32) + packetHeader\n\n    function encode(\n        bytes32 _receiveLib,\n        bytes memory _packetHeader,\n        bytes32 _payloadHash\n    ) internal pure returns (bytes memory payload) {\n        return abi.encodePacked(_receiveLib, _payloadHash, _packetHeader);\n    }\n\n    function decode(\n        bytes calldata _message\n    ) internal pure returns (address receiveLib, bytes memory packetHeader, bytes32 payloadHash) {\n        if (_message.length != MESSAGE_SIZE) revert DVNAdapter_InvalidMessageSize();\n\n        receiveLib = bytes32(_message[RECEIVE_LIB_OFFSET:PAYLOAD_HASH_OFFSET]).toAddress();\n        payloadHash = bytes32(_message[PAYLOAD_HASH_OFFSET:PACKET_HEADER_OFFSET]);\n        packetHeader = _message[PACKET_HEADER_OFFSET:];\n    }\n\n    function srcEid(bytes calldata _message) internal pure returns (uint32) {\n        return uint32(bytes4(_message[SRC_EID_OFFSET:SRC_EID_OFFSET + 4]));\n    }\n}\n"
    },
    "contracts/messagelib/contracts/uln/dvn/adapters/optimism/OptimismDVNAdapterL1.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.20;\n\nimport { ICrossDomainMessenger } from \"@eth-optimism/contracts/libraries/bridge/ICrossDomainMessenger.sol\";\n\nimport { OptimismDVNAdapterL2 } from \"./OptimismDVNAdapterL2.sol\";\nimport { DVNAdapterMessageCodec } from \"../libs/DVNAdapterMessageCodec.sol\";\nimport { DVNAdapterBase } from \"../DVNAdapterBase.sol\";\n\n/// @title OptimismDVNAdapterL1\n/// @dev How Optimism DVN adapter works:\n///  1. call `sendMessage` on the L1CrossDomainMessenger contract.\n///     refer to https://docs.optimism.io/builders/dapp-developers/bridging/messaging#basics-of-communication-between-layers\n/// @dev Recovery:\n///  1. If the message is not executed or failed to execute on the destination chain, you can manually retry by calling `relayMessage` on the `CrossDomainMessenger` contract.\n///     refer to https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts-bedrock/src/universal/CrossDomainMessenger.sol#L211C14-L211C26\ncontract OptimismDVNAdapterL1 is DVNAdapterBase {\n    // --- Errors ---\n    error OnlyOptimism();\n    error NoPeer();\n\n    // --- Events ---\n    event PeerSet(address indexed peer);\n    event GasLimitSet(uint32 gasLimit);\n\n    uint32 public immutable optimismEid; // eid % 30000 (v1 eid)\n    address public immutable l1Messenger; // L1CrossDomainMessenger\n\n    uint32 public gasLimit;\n    address public peer;\n\n    constructor(\n        address[] memory _admins,\n        uint32 _optimismEid,\n        address _l1Messenger\n    ) DVNAdapterBase(msg.sender, _admins, 12000) {\n        optimismEid = _optimismEid; // eid % 30000 (v1 eid)\n        l1Messenger = _l1Messenger;\n    }\n\n    // --- Admin ---\n    function setGasLimit(uint32 _gasLimit) external onlyRole(ADMIN_ROLE) {\n        gasLimit = _gasLimit;\n        emit GasLimitSet(_gasLimit);\n    }\n\n    function setPeer(address _peer) external onlyRole(ADMIN_ROLE) {\n        peer = _peer;\n        emit PeerSet(_peer);\n    }\n\n    // --- Send ---\n    function assignJob(\n        AssignJobParam calldata _param,\n        bytes calldata /*_options*/\n    ) external payable override onlyAcl(_param.sender) returns (uint256) {\n        _getAndAssertReceiveLib(msg.sender, _param.dstEid);\n\n        if (_param.dstEid % 30000 != optimismEid) revert OnlyOptimism();\n        if (peer == address(0)) revert NoPeer();\n\n        bytes memory payload = abi.encodeWithSelector(\n            OptimismDVNAdapterL2.verify.selector,\n            DVNAdapterMessageCodec.encode(\n                receiveLibs[msg.sender][_param.dstEid],\n                _param.packetHeader,\n                _param.payloadHash\n            )\n        );\n        ICrossDomainMessenger(l1Messenger).sendMessage(peer, payload, gasLimit);\n\n        return 0;\n    }\n\n    // --- View ---\n    function getFee(\n        uint32 /*_dstEid*/,\n        uint64 /*_confirmations*/,\n        address _sender,\n        bytes calldata /*_options*/\n    ) public view override onlyAcl(_sender) returns (uint256) {\n        // no fee, charged as gas when sending message from L1 to L2\n        return 0;\n    }\n}\n"
    },
    "contracts/messagelib/contracts/uln/dvn/adapters/optimism/OptimismDVNAdapterL2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.20;\n\nimport { ICrossDomainMessenger } from \"@eth-optimism/contracts/libraries/bridge/ICrossDomainMessenger.sol\";\n\nimport { DVNAdapterBase } from \"../DVNAdapterBase.sol\";\n\ncontract OptimismDVNAdapterL2 is DVNAdapterBase {\n    // --- Errors ---\n    error UntrustedPeer(address peer);\n    error Unauthorized();\n\n    // --- Events ---\n    event PeerSet(address indexed peer);\n\n    address public immutable l2Messenger; // L2CrossDomainMessenger\n\n    address public peer;\n\n    constructor(address[] memory _admins, address _l2Messenger) DVNAdapterBase(msg.sender, _admins, 12000) {\n        l2Messenger = _l2Messenger;\n    }\n\n    // --- Admin ---\n    function setPeer(address _peer) external onlyRole(ADMIN_ROLE) {\n        peer = _peer;\n        emit PeerSet(_peer);\n    }\n\n    // --- Send ---\n    function assignJob(\n        AssignJobParam calldata /*_param*/,\n        bytes calldata /*_options*/\n    ) external payable override returns (uint256) {\n        revert DVNAdapter_NotImplemented();\n    }\n\n    function getFee(\n        uint32 /*_dstEid*/,\n        uint64 /*_confirmations*/,\n        address /*_sender*/,\n        bytes calldata /*_options*/\n    ) external pure override returns (uint256) {\n        revert DVNAdapter_NotImplemented();\n    }\n\n    // --- Receive ---\n    function verify(bytes calldata _payload) external {\n        // assert messenger\n        if (msg.sender != l2Messenger) revert Unauthorized();\n        // assert peer\n        address xSender = ICrossDomainMessenger(l2Messenger).xDomainMessageSender();\n        if (xSender != peer) revert UntrustedPeer(xSender);\n\n        _decodeAndVerify(0, _payload); //todo: fix\n    }\n}\n"
    },
    "contracts/messagelib/contracts/uln/dvn/DeadDVN.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { ILayerZeroDVN } from \"../interfaces/ILayerZeroDVN.sol\";\n\ncontract DeadDVN is ILayerZeroDVN {\n    string internal constant ERROR_NOT_ALLOWED = \"Please set your OApp's DVNs and/or Executor\";\n\n    /// @dev for ULN301, ULN302 and more to assign job\n    function assignJob(AssignJobParam calldata, bytes calldata) external payable returns (uint256) {\n        revert(ERROR_NOT_ALLOWED);\n    }\n\n    /// @dev to support ULNv2\n    function assignJob(uint16, uint16, uint64, address) external pure returns (uint256) {\n        revert(ERROR_NOT_ALLOWED);\n    }\n\n    // ========================= View =========================\n\n    function getFee(uint32, uint64, address, bytes calldata) external pure returns (uint256) {\n        revert(ERROR_NOT_ALLOWED);\n    }\n\n    /// @dev to support ULNv2\n    function getFee(uint16, uint16, uint64, address) public pure returns (uint256) {\n        revert(ERROR_NOT_ALLOWED);\n    }\n}\n"
    },
    "contracts/messagelib/contracts/uln/dvn/DVN.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { ILayerZeroUltraLightNodeV2 } from \"@layerzerolabs/lz-evm-v1-0.7/contracts/interfaces/ILayerZeroUltraLightNodeV2.sol\";\n\nimport { Worker } from \"../../Worker.sol\";\nimport { MultiSig } from \"./MultiSig.sol\";\nimport { IDVN } from \"../interfaces/IDVN.sol\";\nimport { IDVNFeeLib } from \"../interfaces/IDVNFeeLib.sol\";\nimport { IReceiveUlnE2 } from \"../interfaces/IReceiveUlnE2.sol\";\n\nstruct ExecuteParam {\n    uint32 vid;\n    address target;\n    bytes callData;\n    uint256 expiration;\n    bytes signatures;\n}\n\ncontract DVN is Worker, MultiSig, IDVN {\n    // to uniquely identify this DVN instance\n    // set to endpoint v1 eid if available OR endpoint v2 eid % 30_000\n    uint32 public immutable vid;\n\n    mapping(uint32 dstEid => DstConfig) public dstConfig;\n    mapping(bytes32 executableHash => bool used) public usedHashes;\n\n    error DVN_OnlySelf();\n    error DVN_InvalidRole(bytes32 role);\n    error DVN_InstructionExpired();\n    error DVN_InvalidTarget(address target);\n    error DVN_InvalidVid(uint32 vid);\n    error DVN_InvalidSignatures();\n    error DVN_DuplicatedHash(bytes32 executableHash);\n\n    event VerifySignaturesFailed(uint256 idx);\n    event ExecuteFailed(uint256 _index, bytes _data);\n    event HashAlreadyUsed(ExecuteParam param, bytes32 _hash);\n    // same as DVNFeePaid, but for ULNv2\n    event VerifierFeePaid(uint256 fee);\n\n    // ========================= Constructor =========================\n\n    /// @dev DVN doesn't have a roleAdmin (address(0x0))\n    /// @dev Supports all of ULNv2, ULN301, ULN302 and more\n    /// @param _vid unique identifier for this DVN instance\n    /// @param _messageLibs array of message lib addresses that are granted the MESSAGE_LIB_ROLE\n    /// @param _priceFeed price feed address\n    /// @param _signers array of signer addresses for multisig\n    /// @param _quorum quorum for multisig\n    /// @param _admins array of admin addresses that are granted the ADMIN_ROLE\n    constructor(\n        uint32 _vid,\n        address[] memory _messageLibs,\n        address _priceFeed,\n        address[] memory _signers,\n        uint64 _quorum,\n        address[] memory _admins\n    ) Worker(_messageLibs, _priceFeed, 12000, address(0x0), _admins) MultiSig(_signers, _quorum) {\n        vid = _vid;\n    }\n\n    // ========================= Modifier =========================\n\n    /// @dev depending on role, restrict access to only self or admin\n    /// @dev ALLOWLIST, DENYLIST, MESSAGE_LIB_ROLE can only be granted/revoked by self\n    /// @dev ADMIN_ROLE can only be granted/revoked by admin\n    /// @dev reverts if not one of the above roles\n    /// @param _role role to check\n    modifier onlySelfOrAdmin(bytes32 _role) {\n        if (_role == ALLOWLIST || _role == DENYLIST || _role == MESSAGE_LIB_ROLE) {\n            // self required\n            if (address(this) != msg.sender) {\n                revert DVN_OnlySelf();\n            }\n        } else if (_role == ADMIN_ROLE) {\n            // admin required\n            _checkRole(ADMIN_ROLE);\n        } else {\n            revert DVN_InvalidRole(_role);\n        }\n        _;\n    }\n\n    modifier onlySelf() {\n        if (address(this) != msg.sender) {\n            revert DVN_OnlySelf();\n        }\n        _;\n    }\n\n    // ========================= OnlySelf =========================\n\n    /// @dev set signers for multisig\n    /// @dev function sig 0x31cb6105\n    /// @param _signer signer address\n    /// @param _active true to add, false to remove\n    function setSigner(address _signer, bool _active) external onlySelf {\n        _setSigner(_signer, _active);\n    }\n\n    /// @dev set quorum for multisig\n    /// @dev function sig 0x8585c945\n    /// @param _quorum to set\n    function setQuorum(uint64 _quorum) external onlySelf {\n        _setQuorum(_quorum);\n    }\n\n    // ========================= OnlySelf / OnlyAdmin =========================\n\n    /// @dev overrides AccessControl to allow self/admin to grant role'\n    /// @dev function sig 0x2f2ff15d\n    /// @param _role role to grant\n    /// @param _account account to grant role to\n    function grantRole(bytes32 _role, address _account) public override onlySelfOrAdmin(_role) {\n        _grantRole(_role, _account);\n    }\n\n    /// @dev overrides AccessControl to allow self/admin to revoke role\n    /// @dev function sig 0xd547741f\n    /// @param _role role to revoke\n    /// @param _account account to revoke role from\n    function revokeRole(bytes32 _role, address _account) public override onlySelfOrAdmin(_role) {\n        _revokeRole(_role, _account);\n    }\n\n    // ========================= OnlyQuorum =========================\n\n    /// @notice function for quorum to change admin without going through execute function\n    /// @dev calldata in the case is abi.encode new admin address\n    function quorumChangeAdmin(ExecuteParam calldata _param) external {\n        if (_param.expiration <= block.timestamp) {\n            revert DVN_InstructionExpired();\n        }\n        if (_param.target != address(this)) {\n            revert DVN_InvalidTarget(_param.target);\n        }\n        if (_param.vid != vid) {\n            revert DVN_InvalidVid(_param.vid);\n        }\n\n        // generate and validate hash\n        bytes32 hash = hashCallData(_param.vid, _param.target, _param.callData, _param.expiration);\n        (bool sigsValid, ) = verifySignatures(hash, _param.signatures);\n        if (!sigsValid) {\n            revert DVN_InvalidSignatures();\n        }\n        if (usedHashes[hash]) {\n            revert DVN_DuplicatedHash(hash);\n        }\n\n        usedHashes[hash] = true;\n        _grantRole(ADMIN_ROLE, abi.decode(_param.callData, (address)));\n    }\n\n    // ========================= OnlyAdmin =========================\n\n    /// @param _params array of DstConfigParam\n    function setDstConfig(DstConfigParam[] calldata _params) external onlyRole(ADMIN_ROLE) {\n        for (uint256 i = 0; i < _params.length; ++i) {\n            DstConfigParam calldata param = _params[i];\n            dstConfig[param.dstEid] = DstConfig(param.gas, param.multiplierBps, param.floorMarginUSD);\n        }\n        emit SetDstConfig(_params);\n    }\n\n    /// @dev takes a list of instructions and executes them in order\n    /// @dev if any of the instructions fail, it will emit an error event and continue to execute the rest of the instructions\n    /// @param _params array of ExecuteParam, includes target, callData, expiration, signatures\n    function execute(ExecuteParam[] calldata _params) external onlyRole(ADMIN_ROLE) {\n        for (uint256 i = 0; i < _params.length; ++i) {\n            ExecuteParam calldata param = _params[i];\n            // 1. skip if invalid vid\n            if (param.vid != vid) {\n                continue;\n            }\n\n            // 2. skip if expired\n            if (param.expiration <= block.timestamp) {\n                continue;\n            }\n\n            // generate and validate hash\n            bytes32 hash = hashCallData(param.vid, param.target, param.callData, param.expiration);\n\n            // 3. check signatures\n            (bool sigsValid, ) = verifySignatures(hash, param.signatures);\n            if (!sigsValid) {\n                emit VerifySignaturesFailed(i);\n                continue;\n            }\n\n            // 4. should check hash\n            bool shouldCheckHash = _shouldCheckHash(bytes4(param.callData));\n            if (shouldCheckHash) {\n                if (usedHashes[hash]) {\n                    emit HashAlreadyUsed(param, hash);\n                    continue;\n                } else {\n                    usedHashes[hash] = true; // prevent reentry and replay attack\n                }\n            }\n\n            (bool success, bytes memory rtnData) = param.target.call(param.callData);\n            if (!success) {\n                if (shouldCheckHash) {\n                    // need to unset the usedHash otherwise it cant be used\n                    usedHashes[hash] = false;\n                }\n                // emit an event in any case\n                emit ExecuteFailed(i, rtnData);\n            }\n        }\n    }\n\n    /// @dev to support ULNv2\n    /// @dev the withdrawFee function for ULN30X is built in the Worker contract\n    /// @param _lib message lib address\n    /// @param _to address to withdraw to\n    /// @param _amount amount to withdraw\n    function withdrawFeeFromUlnV2(address _lib, address payable _to, uint256 _amount) external onlyRole(ADMIN_ROLE) {\n        if (!hasRole(MESSAGE_LIB_ROLE, _lib)) {\n            revert Worker_OnlyMessageLib();\n        }\n        ILayerZeroUltraLightNodeV2(_lib).withdrawNative(_to, _amount);\n    }\n\n    // ========================= OnlyMessageLib =========================\n\n    /// @dev for ULN301, ULN302 and more to assign job\n    /// @dev dvn network can reject job from _sender by adding/removing them from allowlist/denylist\n    /// @param _param assign job param\n    /// @param _options dvn options\n    function assignJob(\n        AssignJobParam calldata _param,\n        bytes calldata _options\n    ) external payable onlyRole(MESSAGE_LIB_ROLE) onlyAcl(_param.sender) returns (uint256 totalFee) {\n        IDVNFeeLib.FeeParams memory feeParams = IDVNFeeLib.FeeParams(\n            priceFeed,\n            _param.dstEid,\n            _param.confirmations,\n            _param.sender,\n            quorum,\n            defaultMultiplierBps\n        );\n        totalFee = IDVNFeeLib(workerFeeLib).getFeeOnSend(feeParams, dstConfig[_param.dstEid], _options);\n    }\n\n    /// @dev to support ULNv2\n    /// @dev dvn network can reject job from _sender by adding/removing them from allowlist/denylist\n    /// @param _dstEid destination EndpointId\n    /// @param //_outboundProofType outbound proof type\n    /// @param _confirmations block confirmations\n    /// @param _sender message sender address\n    function assignJob(\n        uint16 _dstEid,\n        uint16 /*_outboundProofType*/,\n        uint64 _confirmations,\n        address _sender\n    ) external onlyRole(MESSAGE_LIB_ROLE) onlyAcl(_sender) returns (uint256 totalFee) {\n        IDVNFeeLib.FeeParams memory params = IDVNFeeLib.FeeParams(\n            priceFeed,\n            _dstEid,\n            _confirmations,\n            _sender,\n            quorum,\n            defaultMultiplierBps\n        );\n        // ULNV2 does not have dvn options\n        totalFee = IDVNFeeLib(workerFeeLib).getFeeOnSend(params, dstConfig[_dstEid], bytes(\"\"));\n        emit VerifierFeePaid(totalFee);\n    }\n\n    // ========================= View =========================\n\n    /// @dev getFee can revert if _sender doesn't pass ACL\n    /// @param _dstEid destination EndpointId\n    /// @param _confirmations block confirmations\n    /// @param _sender message sender address\n    /// @param _options dvn options\n    /// @return fee fee in native amount\n    function getFee(\n        uint32 _dstEid,\n        uint64 _confirmations,\n        address _sender,\n        bytes calldata _options\n    ) external view onlyAcl(_sender) returns (uint256 fee) {\n        IDVNFeeLib.FeeParams memory params = IDVNFeeLib.FeeParams(\n            priceFeed,\n            _dstEid,\n            _confirmations,\n            _sender,\n            quorum,\n            defaultMultiplierBps\n        );\n        return IDVNFeeLib(workerFeeLib).getFee(params, dstConfig[_dstEid], _options);\n    }\n\n    /// @dev to support ULNv2\n    /// @dev getFee can revert if _sender doesn't pass ACL\n    /// @param _dstEid destination EndpointId\n    /// @param //_outboundProofType outbound proof type\n    /// @param _confirmations block confirmations\n    /// @param _sender message sender address\n    function getFee(\n        uint16 _dstEid,\n        uint16 /*_outboundProofType*/,\n        uint64 _confirmations,\n        address _sender\n    ) public view onlyAcl(_sender) returns (uint256 fee) {\n        IDVNFeeLib.FeeParams memory params = IDVNFeeLib.FeeParams(\n            priceFeed,\n            _dstEid,\n            _confirmations,\n            _sender,\n            quorum,\n            defaultMultiplierBps\n        );\n        return IDVNFeeLib(workerFeeLib).getFee(params, dstConfig[_dstEid], bytes(\"\"));\n    }\n\n    /// @param _target target address\n    /// @param _callData call data\n    /// @param _expiration expiration timestamp\n    /// @return hash of above\n    function hashCallData(\n        uint32 _vid,\n        address _target,\n        bytes calldata _callData,\n        uint256 _expiration\n    ) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_vid, _target, _expiration, _callData));\n    }\n\n    // ========================= Internal =========================\n\n    /// @dev to save gas, we don't check hash for some functions (where replaying won't change the state)\n    /// @dev for example, some administrative functions like changing signers, the contract should check hash to double spending\n    /// @dev should ensure that all onlySelf functions have unique functionSig\n    /// @param _functionSig function signature\n    /// @return true if should check hash\n    function _shouldCheckHash(bytes4 _functionSig) internal pure returns (bool) {\n        // never check for these selectors to save gas\n        return\n            _functionSig != IReceiveUlnE2.verify.selector && // 0x0223536e, replaying won't change the state\n            _functionSig != ILayerZeroUltraLightNodeV2.updateHash.selector; // 0x704316e5, replaying will be revert at uln\n    }\n}\n"
    },
    "contracts/messagelib/contracts/uln/dvn/DVNFeeLib.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { Transfer } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/Transfer.sol\";\n\nimport { ILayerZeroPriceFeed } from \"../../interfaces/ILayerZeroPriceFeed.sol\";\nimport { IDVN } from \"../interfaces/IDVN.sol\";\nimport { IDVNFeeLib } from \"../interfaces/IDVNFeeLib.sol\";\nimport { DVNOptions } from \"../libs/DVNOptions.sol\";\n\ncontract DVNFeeLib is Ownable, IDVNFeeLib {\n    using DVNOptions for bytes;\n\n    uint16 internal constant EXECUTE_FIXED_BYTES = 68; // encoded: funcSigHash + params -> 4  + (32 * 2)\n    uint16 internal constant SIGNATURE_RAW_BYTES = 65; // not encoded\n    // callData(updateHash) = 132 (4 + 32 * 4), padded to 32 = 160 and encoded as bytes with an 64 byte overhead = 224\n    uint16 internal constant UPDATE_HASH_BYTES = 224;\n\n    uint256 private immutable nativeDecimalsRate;\n\n    constructor(uint256 _nativeDecimalsRate) {\n        nativeDecimalsRate = _nativeDecimalsRate;\n    }\n\n    // ================================ OnlyOwner ================================\n    function withdrawToken(address _token, address _to, uint256 _amount) external onlyOwner {\n        // transfers native if _token is address(0x0)\n        Transfer.nativeOrToken(_token, _to, _amount);\n    }\n\n    // ========================= External =========================\n    /// @dev get fee function that can change state. e.g. paying priceFeed\n    /// @param _params fee params\n    /// @param _dstConfig dst config\n    /// @param //_options options\n    function getFeeOnSend(\n        FeeParams calldata _params,\n        IDVN.DstConfig calldata _dstConfig,\n        bytes calldata _options\n    ) external payable returns (uint256) {\n        if (_dstConfig.gas == 0) revert DVN_EidNotSupported(_params.dstEid);\n\n        _decodeDVNOptions(_options); // todo: validate options\n\n        uint256 callDataSize = _getCallDataSize(_params.quorum);\n\n        // for future versions where priceFeed charges a fee\n        //        uint256 priceFeedFee = ILayerZeroPriceFeed(_params.priceFeed).getFee(_params.dstEid, callDataSize, _dstConfig.gas);\n        //        (uint256 fee, , , uint128 nativePriceUSD) = ILayerZeroPriceFeed(_params.priceFeed).estimateFeeOnSend{\n        //            value: priceFeedFee\n        //        }(_params.dstEid, callDataSize, _dstConfig.gas);\n\n        (uint256 fee, , , uint128 nativePriceUSD) = ILayerZeroPriceFeed(_params.priceFeed).estimateFeeOnSend(\n            _params.dstEid,\n            callDataSize,\n            _dstConfig.gas\n        );\n\n        return\n            _applyPremium(\n                fee,\n                _dstConfig.multiplierBps,\n                _params.defaultMultiplierBps,\n                _dstConfig.floorMarginUSD,\n                nativePriceUSD\n            );\n    }\n\n    // ========================= View =========================\n    /// @dev get fee view function\n    /// @param _params fee params\n    /// @param _dstConfig dst config\n    /// @param //_options options\n    function getFee(\n        FeeParams calldata _params,\n        IDVN.DstConfig calldata _dstConfig,\n        bytes calldata _options\n    ) external view returns (uint256) {\n        if (_dstConfig.gas == 0) revert DVN_EidNotSupported(_params.dstEid);\n\n        _decodeDVNOptions(_options); // validate options\n\n        uint256 callDataSize = _getCallDataSize(_params.quorum);\n        (uint256 fee, , , uint128 nativePriceUSD) = ILayerZeroPriceFeed(_params.priceFeed).estimateFeeByEid(\n            _params.dstEid,\n            callDataSize,\n            _dstConfig.gas\n        );\n        return\n            _applyPremium(\n                fee,\n                _dstConfig.multiplierBps,\n                _params.defaultMultiplierBps,\n                _dstConfig.floorMarginUSD,\n                nativePriceUSD\n            );\n    }\n\n    // ========================= Internal =========================\n    function _getCallDataSize(uint256 _quorum) internal pure returns (uint256) {\n        uint256 totalSignatureBytes = _quorum * SIGNATURE_RAW_BYTES;\n        if (totalSignatureBytes % 32 != 0) {\n            totalSignatureBytes = totalSignatureBytes - (totalSignatureBytes % 32) + 32;\n        }\n        // getFee should charge on execute(updateHash)\n        // totalSignatureBytesPadded also has 64 overhead for bytes\n        return uint256(EXECUTE_FIXED_BYTES) + UPDATE_HASH_BYTES + totalSignatureBytes + 64;\n    }\n\n    function _applyPremium(\n        uint256 _fee,\n        uint16 _bps,\n        uint16 _defaultBps,\n        uint128 _marginUSD,\n        uint128 _nativePriceUSD\n    ) internal view returns (uint256) {\n        uint16 multiplierBps = _bps == 0 ? _defaultBps : _bps;\n\n        uint256 feeWithMultiplier = (_fee * multiplierBps) / 10000;\n        if (_nativePriceUSD == 0 || _marginUSD == 0) {\n            return feeWithMultiplier;\n        }\n\n        uint256 feeWithFloorMargin = _fee + (_marginUSD * nativeDecimalsRate) / _nativePriceUSD;\n\n        return feeWithFloorMargin > feeWithMultiplier ? feeWithFloorMargin : feeWithMultiplier;\n    }\n\n    function _decodeDVNOptions(bytes calldata _options) internal pure returns (uint256) {\n        uint256 cursor;\n        while (cursor < _options.length) {\n            (uint8 optionType, , uint256 newCursor) = _options.nextDVNOption(cursor);\n            cursor = newCursor;\n            revert DVN_UnsupportedOptionType(optionType);\n        }\n        if (cursor != _options.length) revert DVNOptions.DVN_InvalidDVNOptions(cursor);\n\n        return 0; // todo: precrime fee model\n    }\n\n    // send funds here to pay for price feed directly\n    receive() external payable {}\n}\n"
    },
    "contracts/messagelib/contracts/uln/dvn/MultiSig.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { ECDSA } from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\nabstract contract MultiSig {\n    enum Errors {\n        NoError,\n        SignatureError,\n        DuplicatedSigner,\n        SignerNotInCommittee\n    }\n\n    mapping(address signer => bool active) public signers;\n    uint64 public signerSize;\n    uint64 public quorum;\n\n    error MultiSig_OnlySigner();\n    error MultiSig_QuorumIsZero();\n    error MultiSig_SignersSizeIsLessThanQuorum(uint64 signersSize, uint64 quorum);\n    error MultiSig_UnorderedSigners();\n    error MultiSig_StateAlreadySet(address signer, bool active);\n\n    event UpdateSigner(address _signer, bool _active);\n    event UpdateQuorum(uint64 _quorum);\n\n    modifier onlySigner() {\n        if (!signers[msg.sender]) {\n            revert MultiSig_OnlySigner();\n        }\n        _;\n    }\n\n    constructor(address[] memory _signers, uint64 _quorum) {\n        if (_quorum == 0) {\n            revert MultiSig_QuorumIsZero();\n        }\n        if (_signers.length < _quorum) {\n            revert MultiSig_SignersSizeIsLessThanQuorum(uint64(_signers.length), _quorum);\n        }\n        address lastSigner = address(0);\n        for (uint256 i = 0; i < _signers.length; i++) {\n            address signer = _signers[i];\n            if (signer <= lastSigner) {\n                revert MultiSig_UnorderedSigners();\n            }\n            signers[signer] = true;\n            lastSigner = signer;\n        }\n        signerSize = uint64(_signers.length);\n        quorum = _quorum;\n    }\n\n    function _setSigner(address _signer, bool _active) internal {\n        if (signers[_signer] == _active) {\n            revert MultiSig_StateAlreadySet(_signer, _active);\n        }\n        signers[_signer] = _active;\n        uint64 _signerSize = _active ? signerSize + 1 : signerSize - 1;\n        uint64 _quorum = quorum;\n        if (_signerSize < _quorum) {\n            revert MultiSig_SignersSizeIsLessThanQuorum(_signerSize, _quorum);\n        }\n        signerSize = _signerSize;\n        emit UpdateSigner(_signer, _active);\n    }\n\n    function _setQuorum(uint64 _quorum) internal {\n        if (_quorum == 0) {\n            revert MultiSig_QuorumIsZero();\n        }\n        uint64 _signerSize = signerSize;\n        if (_signerSize < _quorum) {\n            revert MultiSig_SignersSizeIsLessThanQuorum(_signerSize, _quorum);\n        }\n        quorum = _quorum;\n        emit UpdateQuorum(_quorum);\n    }\n\n    function verifySignatures(bytes32 _hash, bytes calldata _signatures) public view returns (bool, Errors) {\n        if (_signatures.length != uint256(quorum) * 65) {\n            return (false, Errors.SignatureError);\n        }\n\n        bytes32 messageDigest = _getEthSignedMessageHash(_hash);\n\n        address lastSigner = address(0); // There cannot be a signer with address 0.\n        for (uint256 i = 0; i < quorum; i++) {\n            bytes calldata signature = _signatures[i * 65:(i + 1) * 65];\n            (address currentSigner, ECDSA.RecoverError error) = ECDSA.tryRecover(messageDigest, signature);\n\n            if (error != ECDSA.RecoverError.NoError) return (false, Errors.SignatureError);\n            if (currentSigner <= lastSigner) return (false, Errors.DuplicatedSigner); // prevent duplicate signatures\n            if (!signers[currentSigner]) return (false, Errors.SignerNotInCommittee); // signature is not in committee\n            lastSigner = currentSigner;\n        }\n        return (true, Errors.NoError);\n    }\n\n    function _getEthSignedMessageHash(bytes32 _messageHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", _messageHash));\n    }\n}\n"
    },
    "contracts/messagelib/contracts/uln/interfaces/adapters/IAxelarDVNAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface IAxelarDVNAdapter {\n    struct MultiplierParam {\n        uint32 dstEid;\n        uint16 multiplierBps;\n    }\n\n    struct FloorMarginUSDParam {\n        uint32 dstEid;\n        uint128 floorMarginUSD;\n    }\n\n    struct NativeGasFeeParam {\n        uint32 dstEid;\n        uint256 nativeGasFee;\n    }\n\n    struct DstConfigParam {\n        uint32 eid;\n        string chainName;\n        string peer;\n        uint16 multiplierBps;\n        uint256 nativeGasFee;\n    }\n\n    struct DstConfig {\n        string chainName;\n        string peer;\n        uint16 multiplierBps;\n        uint256 nativeGasFee;\n    }\n\n    struct SrcConfig {\n        uint32 eid;\n        string peer;\n    }\n\n    event DstConfigSet(DstConfigParam[] params);\n    event NativeGasFeeSet(NativeGasFeeParam[] params);\n    event MultiplierSet(MultiplierParam[] params);\n    event FloorMarginUSDSet(FloorMarginUSDParam[] params);\n\n    error AxelarDVNAdapter_UntrustedPeer(string chainName, string peer);\n    error AxelarDVNAdapter_OnlyWorkerFeeLib();\n\n    function withdrawToFeeLib(address _sendLib) external;\n}\n"
    },
    "contracts/messagelib/contracts/uln/interfaces/adapters/IAxelarDVNAdapterFeeLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport { IAxelarDVNAdapter } from \"./IAxelarDVNAdapter.sol\";\n\ninterface IAxelarDVNAdapterFeeLib {\n    struct Param {\n        uint32 dstEid;\n        uint64 confirmations;\n        address sender;\n        uint16 defaultMultiplierBps;\n    }\n\n    struct DstConfig {\n        uint64 gas;\n        uint128 floorMarginUSD; // uses priceFeed PRICE_RATIO_DENOMINATOR\n    }\n\n    struct DstConfigParam {\n        uint32 dstEid;\n        uint64 gas;\n        uint128 floorMarginUSD; // uses priceFeed PRICE_RATIO_DENOMINATOR\n    }\n\n    event DstConfigSet(DstConfigParam[] params);\n    event TokenWithdrawn(address token, address to, uint256 amount);\n    event GasServiceSet(address gasService);\n    event PriceFeedSet(address priceFeed);\n    event NativeGasFeeMultiplierBpsSet(uint16 multiplierBps);\n\n    error AxelarDVNAdapter_OptionsUnsupported();\n    error AxelarDVNAdapter_InsufficientBalance(uint256 actual, uint256 requested);\n    error AxelarDVNAdapter_EidNotSupported(uint32 eid);\n\n    function getFeeOnSend(\n        Param calldata _params,\n        IAxelarDVNAdapter.DstConfig calldata _dstConfig,\n        bytes memory _payload,\n        bytes calldata _options,\n        address _sendLib\n    ) external payable returns (uint256 totalFee);\n\n    function getFee(\n        Param calldata _params,\n        IAxelarDVNAdapter.DstConfig calldata _dstConfig,\n        bytes calldata _options\n    ) external view returns (uint256 totalFee);\n}\n"
    },
    "contracts/messagelib/contracts/uln/interfaces/adapters/ICCIPDVNAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface ICCIPDVNAdapter {\n    struct DstConfigParam {\n        uint32 eid;\n        uint16 multiplierBps;\n        uint64 chainSelector;\n        uint256 gas;\n        bytes peer;\n    }\n\n    struct DstConfig {\n        // https://docs.chain.link/ccip/supported-networks/v1_2_0/testnet#ethereum-sepolia\n        // https://docs.chain.link/ccip/supported-networks/v1_0_0/mainnet\n        uint64 chainSelector;\n        uint16 multiplierBps;\n        // https://github.com/smartcontractkit/ccip/blob/ccip-develop/contracts/src/v0.8/ccip/libraries/Client.sol#L22C51-L22C51\n        // for destination is evm chain, need to use `abi.encode(address)` to get the peer\n        bytes peer;\n        uint256 gas;\n    }\n\n    struct SrcConfig {\n        uint32 eid;\n        bytes peer;\n    }\n\n    event DstConfigSet(DstConfigParam[] params);\n\n    error CCIPDVNAdapter_UntrustedPeer(uint64 chainSelector, bytes peer);\n    error CCIPDVNAdapter_InvalidRouter(address router);\n}\n"
    },
    "contracts/messagelib/contracts/uln/interfaces/adapters/ICCIPDVNAdapterFeeLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport { Client } from \"@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol\";\nimport { IRouterClient } from \"@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol\";\nimport { ICCIPDVNAdapter } from \"./ICCIPDVNAdapter.sol\";\n\ninterface ICCIPDVNAdapterFeeLib {\n    struct Param {\n        uint32 dstEid;\n        uint64 confirmations;\n        address sender;\n        uint16 defaultMultiplierBps;\n    }\n\n    struct DstConfig {\n        uint128 floorMarginUSD; // uses priceFeed PRICE_RATIO_DENOMINATOR\n    }\n\n    struct DstConfigParam {\n        uint32 dstEid;\n        uint128 floorMarginUSD; // uses priceFeed PRICE_RATIO_DENOMINATOR\n    }\n\n    event DstConfigSet(DstConfigParam[] params);\n\n    error CCIPDVNAdapter_OptionsUnsupported();\n    error CCIPDVNAdapter_EidNotSupported(uint32 eid);\n\n    function getFeeOnSend(\n        Param calldata _params,\n        ICCIPDVNAdapter.DstConfig calldata _dstConfig,\n        Client.EVM2AnyMessage calldata _message,\n        bytes calldata _options,\n        IRouterClient _router\n    ) external payable returns (uint256 ccipFee, uint256 totalFee);\n\n    function getFee(\n        Param calldata _params,\n        ICCIPDVNAdapter.DstConfig calldata _dstConfig,\n        Client.EVM2AnyMessage calldata _message,\n        bytes calldata _options,\n        IRouterClient _router\n    ) external view returns (uint256 totalFee);\n}\n"
    },
    "contracts/messagelib/contracts/uln/interfaces/IDVN.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport { IWorker } from \"../../interfaces/IWorker.sol\";\nimport { ILayerZeroDVN } from \"./ILayerZeroDVN.sol\";\n\ninterface IDVN is IWorker, ILayerZeroDVN {\n    struct DstConfigParam {\n        uint32 dstEid;\n        uint64 gas;\n        uint16 multiplierBps;\n        uint128 floorMarginUSD;\n    }\n\n    struct DstConfig {\n        uint64 gas;\n        uint16 multiplierBps;\n        uint128 floorMarginUSD; // uses priceFeed PRICE_RATIO_DENOMINATOR\n    }\n\n    event SetDstConfig(DstConfigParam[] params);\n\n    function dstConfig(uint32 _dstEid) external view returns (uint64, uint16, uint128);\n}\n"
    },
    "contracts/messagelib/contracts/uln/interfaces/IDVNFeeLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport { IDVN } from \"./IDVN.sol\";\n\ninterface IDVNFeeLib {\n    struct FeeParams {\n        address priceFeed;\n        uint32 dstEid;\n        uint64 confirmations;\n        address sender;\n        uint64 quorum;\n        uint16 defaultMultiplierBps;\n    }\n\n    error DVN_UnsupportedOptionType(uint8 optionType);\n    error DVN_EidNotSupported(uint32 eid);\n\n    function getFeeOnSend(\n        FeeParams calldata _params,\n        IDVN.DstConfig calldata _dstConfig,\n        bytes calldata _options\n    ) external payable returns (uint256 fee);\n\n    function getFee(\n        FeeParams calldata _params,\n        IDVN.DstConfig calldata _dstConfig,\n        bytes calldata _options\n    ) external view returns (uint256 fee);\n}\n"
    },
    "contracts/messagelib/contracts/uln/interfaces/ILayerZeroDVN.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface ILayerZeroDVN {\n    struct AssignJobParam {\n        uint32 dstEid;\n        bytes packetHeader;\n        bytes32 payloadHash;\n        uint64 confirmations;\n        address sender;\n    }\n\n    // @notice query price and assign jobs at the same time\n    // @param _dstEid - the destination endpoint identifier\n    // @param _packetHeader - version + nonce + path\n    // @param _payloadHash - hash of guid + message\n    // @param _confirmations - block confirmation delay before relaying blocks\n    // @param _sender - the source sending contract address\n    // @param _options - options\n    function assignJob(AssignJobParam calldata _param, bytes calldata _options) external payable returns (uint256 fee);\n\n    // @notice query the dvn fee for relaying block information to the destination chain\n    // @param _dstEid the destination endpoint identifier\n    // @param _confirmations - block confirmation delay before relaying blocks\n    // @param _sender - the source sending contract address\n    // @param _options - options\n    function getFee(\n        uint32 _dstEid,\n        uint64 _confirmations,\n        address _sender,\n        bytes calldata _options\n    ) external view returns (uint256 fee);\n}\n"
    },
    "contracts/messagelib/contracts/uln/interfaces/IReceiveUlnE2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\n/// @dev should be implemented by the ReceiveUln302 contract and future ReceiveUln contracts on EndpointV2\ninterface IReceiveUlnE2 {\n    /// @notice for each dvn to verify the payload\n    /// @dev this function signature 0x0223536e\n    function verify(bytes calldata _packetHeader, bytes32 _payloadHash, uint64 _confirmations) external;\n\n    /// @notice verify the payload at endpoint, will check if all DVNs verified\n    function commitVerification(bytes calldata _packetHeader, bytes32 _payloadHash) external;\n}\n"
    },
    "contracts/messagelib/contracts/uln/libs/DVNOptions.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { BytesLib } from \"solidity-bytes-utils/contracts/BytesLib.sol\";\n\nimport { BitMap256 } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/BitMaps.sol\";\nimport { CalldataBytesLib } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/CalldataBytesLib.sol\";\n\nlibrary DVNOptions {\n    using CalldataBytesLib for bytes;\n    using BytesLib for bytes;\n\n    uint8 internal constant WORKER_ID = 2;\n    uint8 internal constant OPTION_TYPE_PRECRIME = 1;\n\n    error DVN_InvalidDVNIdx();\n    error DVN_InvalidDVNOptions(uint256 cursor);\n\n    /// @dev group dvn options by its idx\n    /// @param _options [dvn_id][dvn_option][dvn_id][dvn_option]...\n    ///        dvn_option = [option_size][dvn_idx][option_type][option]\n    ///        option_size = len(dvn_idx) + len(option_type) + len(option)\n    ///        dvn_id: uint8, dvn_idx: uint8, option_size: uint16, option_type: uint8, option: bytes\n    /// @return dvnOptions the grouped options, still share the same format of _options\n    /// @return dvnIndices the dvn indices\n    function groupDVNOptionsByIdx(\n        bytes memory _options\n    ) internal pure returns (bytes[] memory dvnOptions, uint8[] memory dvnIndices) {\n        if (_options.length == 0) return (dvnOptions, dvnIndices);\n\n        uint8 numDVNs = getNumDVNs(_options);\n\n        // if there is only 1 dvn, we can just return the whole options\n        if (numDVNs == 1) {\n            dvnOptions = new bytes[](1);\n            dvnOptions[0] = _options;\n\n            dvnIndices = new uint8[](1);\n            dvnIndices[0] = _options.toUint8(3); // dvn idx\n            return (dvnOptions, dvnIndices);\n        }\n\n        // otherwise, we need to group the options by dvn_idx\n        dvnIndices = new uint8[](numDVNs);\n        dvnOptions = new bytes[](numDVNs);\n        unchecked {\n            uint256 cursor = 0;\n            uint256 start = 0;\n            uint8 lastDVNIdx = 255; // 255 is an invalid dvn_idx\n\n            while (cursor < _options.length) {\n                ++cursor; // skip worker_id\n\n                // optionLength asserted in getNumDVNs (skip check)\n                uint16 optionLength = _options.toUint16(cursor);\n                cursor += 2;\n\n                // dvnIdx asserted in getNumDVNs (skip check)\n                uint8 dvnIdx = _options.toUint8(cursor);\n\n                // dvnIdx must equal to the lastDVNIdx for the first option\n                // so it is always skipped in the first option\n                // this operation slices out options whenever the scan finds a different lastDVNIdx\n                if (lastDVNIdx == 255) {\n                    lastDVNIdx = dvnIdx;\n                } else if (dvnIdx != lastDVNIdx) {\n                    uint256 len = cursor - start - 3; // 3 is for worker_id and option_length\n                    bytes memory opt = _options.slice(start, len);\n                    _insertDVNOptions(dvnOptions, dvnIndices, lastDVNIdx, opt);\n\n                    // reset the start and lastDVNIdx\n                    start += len;\n                    lastDVNIdx = dvnIdx;\n                }\n\n                cursor += optionLength;\n            }\n\n            // skip check the cursor here because the cursor is asserted in getNumDVNs\n            // if we have reached the end of the options, we need to process the last dvn\n            uint256 size = cursor - start;\n            bytes memory op = _options.slice(start, size);\n            _insertDVNOptions(dvnOptions, dvnIndices, lastDVNIdx, op);\n\n            // revert dvnIndices to start from 0\n            for (uint8 i = 0; i < numDVNs; ++i) {\n                --dvnIndices[i];\n            }\n        }\n    }\n\n    function _insertDVNOptions(\n        bytes[] memory _dvnOptions,\n        uint8[] memory _dvnIndices,\n        uint8 _dvnIdx,\n        bytes memory _newOptions\n    ) internal pure {\n        // dvnIdx starts from 0 but default value of dvnIndices is 0,\n        // so we tell if the slot is empty by adding 1 to dvnIdx\n        if (_dvnIdx == 255) revert DVN_InvalidDVNIdx();\n        uint8 dvnIdxAdj = _dvnIdx + 1;\n\n        for (uint256 j = 0; j < _dvnIndices.length; ++j) {\n            uint8 index = _dvnIndices[j];\n            if (dvnIdxAdj == index) {\n                _dvnOptions[j] = abi.encodePacked(_dvnOptions[j], _newOptions);\n                break;\n            } else if (index == 0) {\n                // empty slot, that means it is the first time we see this dvn\n                _dvnIndices[j] = dvnIdxAdj;\n                _dvnOptions[j] = _newOptions;\n                break;\n            }\n        }\n    }\n\n    /// @dev get the number of unique dvns\n    /// @param _options the format is the same as groupDVNOptionsByIdx\n    function getNumDVNs(bytes memory _options) internal pure returns (uint8 numDVNs) {\n        uint256 cursor = 0;\n        BitMap256 bitmap;\n\n        // find number of unique dvn_idx\n        unchecked {\n            while (cursor < _options.length) {\n                ++cursor; // skip worker_id\n\n                uint16 optionLength = _options.toUint16(cursor);\n                cursor += 2;\n                if (optionLength < 2) revert DVN_InvalidDVNOptions(cursor); // at least 1 byte for dvn_idx and 1 byte for option_type\n\n                uint8 dvnIdx = _options.toUint8(cursor);\n\n                // if dvnIdx is not set, increment numDVNs\n                // max num of dvns is 255, 255 is an invalid dvn_idx\n                // The order of the dvnIdx is not required to be sequential, as enforcing the order may weaken\n                // the composability of the options. e.g. if we refrain from enforcing the order, an OApp that has\n                // already enforced certain options can append additional options to the end of the enforced\n                // ones without restrictions.\n                if (dvnIdx == 255) revert DVN_InvalidDVNIdx();\n                if (!bitmap.get(dvnIdx)) {\n                    ++numDVNs;\n                    bitmap = bitmap.set(dvnIdx);\n                }\n\n                cursor += optionLength;\n            }\n        }\n        if (cursor != _options.length) revert DVN_InvalidDVNOptions(cursor);\n    }\n\n    /// @dev decode the next dvn option from _options starting from the specified cursor\n    /// @param _options the format is the same as groupDVNOptionsByIdx\n    /// @param _cursor the cursor to start decoding\n    /// @return optionType the type of the option\n    /// @return option the option\n    /// @return cursor the cursor to start decoding the next option\n    function nextDVNOption(\n        bytes calldata _options,\n        uint256 _cursor\n    ) internal pure returns (uint8 optionType, bytes calldata option, uint256 cursor) {\n        unchecked {\n            // skip worker id\n            cursor = _cursor + 1;\n\n            // read option size\n            uint16 size = _options.toU16(cursor);\n            cursor += 2;\n\n            // read option type\n            optionType = _options.toU8(cursor + 1); // skip dvn_idx\n\n            // startCursor and endCursor are used to slice the option from _options\n            uint256 startCursor = cursor + 2; // skip option type and dvn_idx\n            uint256 endCursor = cursor + size;\n            option = _options[startCursor:endCursor];\n            cursor += size;\n        }\n    }\n}\n"
    },
    "contracts/messagelib/contracts/uln/libs/UlnOptions.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport { ExecutorOptions } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/ExecutorOptions.sol\";\n\nimport { DVNOptions } from \"./DVNOptions.sol\";\n\nlibrary UlnOptions {\n    using SafeCast for uint256;\n\n    uint16 internal constant TYPE_1 = 1; // legacy options type 1\n    uint16 internal constant TYPE_2 = 2; // legacy options type 2\n    uint16 internal constant TYPE_3 = 3;\n\n    error LZ_ULN_InvalidWorkerOptions(uint256 cursor);\n    error LZ_ULN_InvalidWorkerId(uint8 workerId);\n    error LZ_ULN_InvalidLegacyType1Option();\n    error LZ_ULN_InvalidLegacyType2Option();\n    error LZ_ULN_UnsupportedOptionType(uint16 optionType);\n\n    /// @dev decode the options into executorOptions and dvnOptions\n    /// @param _options the options can be either legacy options (type 1 or 2) or type 3 options\n    /// @return executorOptions the executor options, share the same format of type 3 options\n    /// @return dvnOptions the dvn options, share the same format of type 3 options\n    function decode(\n        bytes calldata _options\n    ) internal pure returns (bytes memory executorOptions, bytes memory dvnOptions) {\n        // at least 2 bytes for the option type, but can have no options\n        if (_options.length < 2) revert LZ_ULN_InvalidWorkerOptions(0);\n\n        uint16 optionsType = uint16(bytes2(_options[0:2]));\n        uint256 cursor = 2;\n\n        // type3 options: [worker_option][worker_option]...\n        // worker_option: [worker_id][option_size][option]\n        // worker_id: uint8, option_size: uint16, option: bytes\n        if (optionsType == TYPE_3) {\n            unchecked {\n                uint256 start = cursor;\n                uint8 lastWorkerId; // worker_id starts from 1, so 0 is an invalid worker_id\n\n                // heuristic: we assume that the options are mostly EXECUTOR options only\n                // checking the workerID can reduce gas usage for most cases\n                while (cursor < _options.length) {\n                    uint8 workerId = uint8(bytes1(_options[cursor:cursor + 1]));\n                    if (workerId == 0) revert LZ_ULN_InvalidWorkerId(0);\n\n                    // workerId must equal to the lastWorkerId for the first option\n                    // so it is always skipped in the first option\n                    // this operation slices out options whenever the the scan finds a different workerId\n                    if (lastWorkerId == 0) {\n                        lastWorkerId = workerId;\n                    } else if (workerId != lastWorkerId) {\n                        bytes calldata op = _options[start:cursor]; // slice out the last worker's options\n                        (executorOptions, dvnOptions) = _insertWorkerOptions(\n                            executorOptions,\n                            dvnOptions,\n                            lastWorkerId,\n                            op\n                        );\n\n                        // reset the start cursor and lastWorkerId\n                        start = cursor;\n                        lastWorkerId = workerId;\n                    }\n\n                    ++cursor; // for workerId\n\n                    uint16 size = uint16(bytes2(_options[cursor:cursor + 2]));\n                    if (size == 0) revert LZ_ULN_InvalidWorkerOptions(cursor);\n                    cursor += size + 2;\n                }\n\n                // the options length must be the same as the cursor at the end\n                if (cursor != _options.length) revert LZ_ULN_InvalidWorkerOptions(cursor);\n\n                // if we have reached the end of the options and the options are not empty\n                // we need to process the last worker's options\n                if (_options.length > 2) {\n                    bytes calldata op = _options[start:cursor];\n                    (executorOptions, dvnOptions) = _insertWorkerOptions(executorOptions, dvnOptions, lastWorkerId, op);\n                }\n            }\n        } else {\n            executorOptions = decodeLegacyOptions(optionsType, _options);\n        }\n    }\n\n    function _insertWorkerOptions(\n        bytes memory _executorOptions,\n        bytes memory _dvnOptions,\n        uint8 _workerId,\n        bytes calldata _newOptions\n    ) private pure returns (bytes memory, bytes memory) {\n        if (_workerId == ExecutorOptions.WORKER_ID) {\n            _executorOptions = _executorOptions.length == 0\n                ? _newOptions\n                : abi.encodePacked(_executorOptions, _newOptions);\n        } else if (_workerId == DVNOptions.WORKER_ID) {\n            _dvnOptions = _dvnOptions.length == 0 ? _newOptions : abi.encodePacked(_dvnOptions, _newOptions);\n        } else {\n            revert LZ_ULN_InvalidWorkerId(_workerId);\n        }\n        return (_executorOptions, _dvnOptions);\n    }\n\n    /// @dev decode the legacy options (type 1 or 2) into executorOptions\n    /// @param _optionType the legacy option type\n    /// @param _options the legacy options, which still has the option type in the first 2 bytes\n    /// @return executorOptions the executor options, share the same format of type 3 options\n    /// Data format:\n    /// legacy type 1: [extraGas]\n    /// legacy type 2: [extraGas][dstNativeAmt][dstNativeAddress]\n    /// extraGas: uint256, dstNativeAmt: uint256, dstNativeAddress: bytes\n    function decodeLegacyOptions(\n        uint16 _optionType,\n        bytes calldata _options\n    ) internal pure returns (bytes memory executorOptions) {\n        if (_optionType == TYPE_1) {\n            if (_options.length != 34) revert LZ_ULN_InvalidLegacyType1Option();\n\n            // execution gas\n            uint128 executionGas = uint256(bytes32(_options[2:2 + 32])).toUint128();\n\n            // dont use the encode function in the ExecutorOptions lib for saving gas by calling abi.encodePacked once\n            // the result is a lzReceive option: [executor_id][option_size][option_type][execution_gas]\n            // option_type: uint8, execution_gas: uint128\n            // option_size = len(option_type) + len(execution_gas) = 1 + 16 = 17\n            executorOptions = abi.encodePacked(\n                ExecutorOptions.WORKER_ID,\n                uint16(17), // 16 + 1, 16 for option_length, + 1 for option_type\n                ExecutorOptions.OPTION_TYPE_LZRECEIVE,\n                executionGas\n            );\n        } else if (_optionType == TYPE_2) {\n            // receiver size <= 32\n            if (_options.length <= 66 || _options.length > 98) revert LZ_ULN_InvalidLegacyType2Option();\n\n            // execution gas\n            uint128 executionGas = uint256(bytes32(_options[2:2 + 32])).toUint128();\n\n            // nativeDrop (amount + receiver)\n            uint128 amount = uint256(bytes32(_options[34:34 + 32])).toUint128(); // offset 2 + 32\n            bytes32 receiver;\n            unchecked {\n                uint256 receiverLen = _options.length - 66; // offset 2 + 32 + 32\n                receiver = bytes32(_options[66:]);\n                receiver = receiver >> (8 * (32 - receiverLen)); // padding 0 to the left\n            }\n\n            // dont use the encode function in the ExecutorOptions lib for saving gas by calling abi.encodePacked once\n            // the result has one lzReceive option and one nativeDrop option:\n            //      [executor_id][lzReceive_option_size][option_type][execution_gas] +\n            //      [executor_id][nativeDrop_option_size][option_type][nativeDrop_amount][receiver]\n            // option_type: uint8, execution_gas: uint128, nativeDrop_amount: uint128, receiver: bytes32\n            // lzReceive_option_size = len(option_type) + len(execution_gas) = 1 + 16 = 17\n            // nativeDrop_option_size = len(option_type) + len(nativeDrop_amount) + len(receiver) = 1 + 16 + 32 = 49\n            executorOptions = abi.encodePacked(\n                ExecutorOptions.WORKER_ID,\n                uint16(17), // 16 + 1, 16 for option_length, + 1 for option_type\n                ExecutorOptions.OPTION_TYPE_LZRECEIVE,\n                executionGas,\n                ExecutorOptions.WORKER_ID,\n                uint16(49), // 48 + 1, 32 + 16 for option_length, + 1 for option_type\n                ExecutorOptions.OPTION_TYPE_NATIVE_DROP,\n                amount,\n                receiver\n            );\n        } else {\n            revert LZ_ULN_UnsupportedOptionType(_optionType);\n        }\n    }\n}\n"
    },
    "contracts/messagelib/contracts/uln/LzExecutor.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { OwnableUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport { Proxied } from \"hardhat-deploy/solc_0.8/proxy/Proxied.sol\";\n\nimport { IReceiveUlnE2 } from \"./interfaces/IReceiveUlnE2.sol\";\nimport { ILayerZeroEndpointV2, Origin } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\nimport { Transfer } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/Transfer.sol\";\n\nimport { ExecutionState, EndpointV2ViewUpgradeable } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/EndpointV2ViewUpgradeable.sol\";\n\nimport { VerificationState } from \"./uln302/ReceiveUln302View.sol\";\n\nstruct LzReceiveParam {\n    Origin origin;\n    address receiver;\n    bytes32 guid;\n    bytes message;\n    bytes extraData;\n    uint256 gas;\n    uint256 value;\n}\n\nstruct NativeDropParam {\n    address _receiver;\n    uint256 _amount;\n}\n\ninterface IReceiveUlnView {\n    function verifiable(bytes calldata _packetHeader, bytes32 _payloadHash) external view returns (VerificationState);\n}\n\ncontract LzExecutor is OwnableUpgradeable, EndpointV2ViewUpgradeable, Proxied {\n    error LzExecutor_Executed();\n    error LzExecutor_Verifying();\n    error LzExecutor_ReceiveLibViewNotSet();\n\n    event NativeWithdrawn(address _to, uint256 _amount);\n    event ReceiveLibViewSet(address _receiveLib, address _receiveLibView);\n\n    address public receiveUln302;\n    uint32 public localEid;\n\n    mapping(address receiveLib => address receiveLibView) public receiveLibToView;\n\n    function initialize(\n        address _receiveUln302,\n        address _receiveUln302View,\n        address _endpoint\n    ) external proxied initializer {\n        __Ownable_init();\n        __EndpointV2View_init(_endpoint);\n\n        receiveUln302 = _receiveUln302;\n        localEid = endpoint.eid();\n        receiveLibToView[_receiveUln302] = _receiveUln302View;\n    }\n\n    // ============================ OnlyOwner ===================================\n\n    function withdrawNative(address _to, uint256 _amount) external onlyOwner {\n        Transfer.native(_to, _amount);\n        emit NativeWithdrawn(_to, _amount);\n    }\n\n    function setReceiveLibView(address _receiveLib, address _receiveLibView) external onlyOwner {\n        receiveLibToView[_receiveLib] = _receiveLibView;\n        emit ReceiveLibViewSet(_receiveLib, _receiveLibView);\n    }\n\n    // ============================ External ===================================\n\n    /// @notice process for commit and execute\n    /// 1. check if executable, revert if executed, execute if executable\n    /// 2. check if verifiable, revert if verifying, commit if verifiable\n    /// 3. native drop\n    /// 4. try execute, will revert if not executable\n    function commitAndExecute(\n        address _receiveLib,\n        LzReceiveParam calldata _lzReceiveParam,\n        NativeDropParam[] calldata _nativeDropParams\n    ) external payable {\n        /// 1. check if executable, revert if executed\n        ExecutionState executionState = executable(_lzReceiveParam.origin, _lzReceiveParam.receiver);\n        if (executionState == ExecutionState.Executed) revert LzExecutor_Executed();\n\n        /// 2. if not executable, check if verifiable, revert if verifying, commit if verifiable\n        if (executionState != ExecutionState.Executable) {\n            address receiveLib = receiveUln302 == address(0x0) ? _receiveLib : address(receiveUln302);\n            bytes memory packetHeader = abi.encodePacked(\n                uint8(1), // packet version 1\n                _lzReceiveParam.origin.nonce,\n                _lzReceiveParam.origin.srcEid,\n                _lzReceiveParam.origin.sender,\n                localEid,\n                bytes32(uint256(uint160(_lzReceiveParam.receiver)))\n            );\n            bytes32 payloadHash = keccak256(abi.encodePacked(_lzReceiveParam.guid, _lzReceiveParam.message));\n\n            address receiveLibView = receiveLibToView[receiveLib];\n            if (receiveLibView == address(0x0)) revert LzExecutor_ReceiveLibViewNotSet();\n\n            VerificationState verificationState = IReceiveUlnView(receiveLibView).verifiable(packetHeader, payloadHash);\n            if (verificationState == VerificationState.Verifiable) {\n                // verification required\n                IReceiveUlnE2(receiveLib).commitVerification(packetHeader, payloadHash);\n            } else if (verificationState == VerificationState.Verifying) {\n                revert LzExecutor_Verifying();\n            }\n        }\n\n        /// 3. native drop\n        for (uint256 i = 0; i < _nativeDropParams.length; i++) {\n            NativeDropParam calldata param = _nativeDropParams[i];\n            Transfer.native(param._receiver, param._amount);\n        }\n\n        /// 4. try execute, will revert if not executable\n        endpoint.lzReceive{ gas: _lzReceiveParam.gas, value: _lzReceiveParam.value }(\n            _lzReceiveParam.origin,\n            _lzReceiveParam.receiver,\n            _lzReceiveParam.guid,\n            _lzReceiveParam.message,\n            _lzReceiveParam.extraData\n        );\n    }\n}\n"
    },
    "contracts/messagelib/contracts/uln/ReceiveUlnBase.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { PacketV1Codec } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/PacketV1Codec.sol\";\n\nimport { UlnBase, UlnConfig } from \"./UlnBase.sol\";\n\nstruct Verification {\n    bool submitted;\n    uint64 confirmations;\n}\n\n/// @dev includes the utility functions for checking ULN states and logics\nabstract contract ReceiveUlnBase is UlnBase {\n    using PacketV1Codec for bytes;\n\n    mapping(bytes32 headerHash => mapping(bytes32 payloadHash => mapping(address dvn => Verification)))\n        public hashLookup;\n\n    event PayloadVerified(address dvn, bytes header, uint256 confirmations, bytes32 proofHash);\n\n    error LZ_ULN_InvalidPacketHeader();\n    error LZ_ULN_InvalidPacketVersion();\n    error LZ_ULN_InvalidEid();\n    error LZ_ULN_Verifying();\n\n    // ============================ External ===================================\n    function verifiable(\n        UlnConfig memory _config,\n        bytes32 _headerHash,\n        bytes32 _payloadHash\n    ) external view returns (bool) {\n        return _checkVerifiable(_config, _headerHash, _payloadHash);\n    }\n\n    function assertHeader(bytes calldata _packetHeader, uint32 _localEid) external pure {\n        _assertHeader(_packetHeader, _localEid);\n    }\n\n    // ============================ Internal ===================================\n    /// @dev per DVN signing function\n    function _verify(bytes calldata _packetHeader, bytes32 _payloadHash, uint64 _confirmations) internal {\n        hashLookup[keccak256(_packetHeader)][_payloadHash][msg.sender] = Verification(true, _confirmations);\n        emit PayloadVerified(msg.sender, _packetHeader, _confirmations, _payloadHash);\n    }\n\n    function _verified(\n        address _dvn,\n        bytes32 _headerHash,\n        bytes32 _payloadHash,\n        uint64 _requiredConfirmation\n    ) internal view returns (bool verified) {\n        Verification memory verification = hashLookup[_headerHash][_payloadHash][_dvn];\n        // return true if the dvn has signed enough confirmations\n        verified = verification.submitted && verification.confirmations >= _requiredConfirmation;\n    }\n\n    function _verifyAndReclaimStorage(UlnConfig memory _config, bytes32 _headerHash, bytes32 _payloadHash) internal {\n        if (!_checkVerifiable(_config, _headerHash, _payloadHash)) {\n            revert LZ_ULN_Verifying();\n        }\n\n        // iterate the required DVNs\n        if (_config.requiredDVNCount > 0) {\n            for (uint8 i = 0; i < _config.requiredDVNCount; ++i) {\n                delete hashLookup[_headerHash][_payloadHash][_config.requiredDVNs[i]];\n            }\n        }\n\n        // iterate the optional DVNs\n        if (_config.optionalDVNCount > 0) {\n            for (uint8 i = 0; i < _config.optionalDVNCount; ++i) {\n                delete hashLookup[_headerHash][_payloadHash][_config.optionalDVNs[i]];\n            }\n        }\n    }\n\n    function _assertHeader(bytes calldata _packetHeader, uint32 _localEid) internal pure {\n        // assert packet header is of right size 81\n        if (_packetHeader.length != 81) revert LZ_ULN_InvalidPacketHeader();\n        // assert packet header version is the same as ULN\n        if (_packetHeader.version() != PacketV1Codec.PACKET_VERSION) revert LZ_ULN_InvalidPacketVersion();\n        // assert the packet is for this endpoint\n        if (_packetHeader.dstEid() != _localEid) revert LZ_ULN_InvalidEid();\n    }\n\n    /// @dev for verifiable view function\n    /// @dev checks if this verification is ready to be committed to the endpoint\n    function _checkVerifiable(\n        UlnConfig memory _config,\n        bytes32 _headerHash,\n        bytes32 _payloadHash\n    ) internal view returns (bool) {\n        // iterate the required DVNs\n        if (_config.requiredDVNCount > 0) {\n            for (uint8 i = 0; i < _config.requiredDVNCount; ++i) {\n                if (!_verified(_config.requiredDVNs[i], _headerHash, _payloadHash, _config.confirmations)) {\n                    // return if any of the required DVNs haven't signed\n                    return false;\n                }\n            }\n            if (_config.optionalDVNCount == 0) {\n                // returns early if all required DVNs have signed and there are no optional DVNs\n                return true;\n            }\n        }\n\n        // then it must require optional validations\n        uint8 threshold = _config.optionalDVNThreshold;\n        for (uint8 i = 0; i < _config.optionalDVNCount; ++i) {\n            if (_verified(_config.optionalDVNs[i], _headerHash, _payloadHash, _config.confirmations)) {\n                // increment the optional count if the optional DVN has signed\n                threshold--;\n                if (threshold == 0) {\n                    // early return if the optional threshold has hit\n                    return true;\n                }\n            }\n        }\n\n        // return false as a catch-all\n        return false;\n    }\n}\n"
    },
    "contracts/messagelib/contracts/uln/SendUlnBase.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { Packet } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ISendLib.sol\";\nimport { PacketV1Codec } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/PacketV1Codec.sol\";\n\nimport { ILayerZeroDVN } from \"./interfaces/ILayerZeroDVN.sol\";\nimport { DVNOptions } from \"./libs/DVNOptions.sol\";\nimport { UlnOptions } from \"./libs/UlnOptions.sol\";\nimport { WorkerOptions } from \"../SendLibBase.sol\";\nimport { UlnConfig, UlnBase } from \"./UlnBase.sol\";\n\n/// @dev includes the utility functions for checking ULN states and logics\nabstract contract SendUlnBase is UlnBase {\n    event DVNFeePaid(address[] requiredDVNs, address[] optionalDVNs, uint256[] fees);\n\n    function _splitUlnOptions(bytes calldata _options) internal pure returns (bytes memory, WorkerOptions[] memory) {\n        (bytes memory executorOpts, bytes memory dvnOpts) = UlnOptions.decode(_options);\n\n        if (dvnOpts.length == 0) {\n            return (executorOpts, new WorkerOptions[](0));\n        }\n\n        WorkerOptions[] memory workerOpts = new WorkerOptions[](1);\n        workerOpts[0] = WorkerOptions(DVNOptions.WORKER_ID, dvnOpts);\n        return (executorOpts, workerOpts);\n    }\n\n    /// ---------- pay and assign jobs ----------\n\n    function _payDVNs(\n        mapping(address => uint256) storage _fees,\n        Packet memory _packet,\n        WorkerOptions[] memory _options\n    ) internal returns (uint256 totalFee, bytes memory encodedPacket) {\n        bytes memory packetHeader = PacketV1Codec.encodePacketHeader(_packet);\n        bytes memory payload = PacketV1Codec.encodePayload(_packet);\n        bytes32 payloadHash = keccak256(payload);\n        uint32 dstEid = _packet.dstEid;\n        address sender = _packet.sender;\n        UlnConfig memory config = getUlnConfig(sender, dstEid);\n\n        // if options is not empty, it must be dvn options\n        bytes memory dvnOptions = _options.length == 0 ? bytes(\"\") : _options[0].options;\n        uint256[] memory dvnFees;\n        (totalFee, dvnFees) = _assignJobs(\n            _fees,\n            config,\n            ILayerZeroDVN.AssignJobParam(dstEid, packetHeader, payloadHash, config.confirmations, sender),\n            dvnOptions\n        );\n        encodedPacket = abi.encodePacked(packetHeader, payload);\n\n        emit DVNFeePaid(config.requiredDVNs, config.optionalDVNs, dvnFees);\n    }\n\n    function _assignJobs(\n        mapping(address => uint256) storage _fees,\n        UlnConfig memory _ulnConfig,\n        ILayerZeroDVN.AssignJobParam memory _param,\n        bytes memory dvnOptions\n    ) internal returns (uint256 totalFee, uint256[] memory dvnFees) {\n        (bytes[] memory optionsArray, uint8[] memory dvnIds) = DVNOptions.groupDVNOptionsByIdx(dvnOptions);\n\n        uint8 dvnsLength = _ulnConfig.requiredDVNCount + _ulnConfig.optionalDVNCount;\n        dvnFees = new uint256[](dvnsLength);\n        for (uint8 i = 0; i < dvnsLength; ++i) {\n            address dvn = i < _ulnConfig.requiredDVNCount\n                ? _ulnConfig.requiredDVNs[i]\n                : _ulnConfig.optionalDVNs[i - _ulnConfig.requiredDVNCount];\n\n            bytes memory options = \"\";\n            for (uint256 j = 0; j < dvnIds.length; ++j) {\n                if (dvnIds[j] == i) {\n                    options = optionsArray[j];\n                    break;\n                }\n            }\n\n            dvnFees[i] = ILayerZeroDVN(dvn).assignJob(_param, options);\n            if (dvnFees[i] > 0) {\n                _fees[dvn] += dvnFees[i];\n                totalFee += dvnFees[i];\n            }\n        }\n    }\n\n    /// ---------- quote ----------\n    function _quoteDVNs(\n        address _sender,\n        uint32 _dstEid,\n        WorkerOptions[] memory _options\n    ) internal view returns (uint256 totalFee) {\n        UlnConfig memory config = getUlnConfig(_sender, _dstEid);\n\n        // if options is not empty, it must be dvn options\n        bytes memory dvnOptions = _options.length == 0 ? bytes(\"\") : _options[0].options;\n        (bytes[] memory optionsArray, uint8[] memory dvnIndices) = DVNOptions.groupDVNOptionsByIdx(dvnOptions);\n\n        totalFee = _getFees(config, _dstEid, _sender, optionsArray, dvnIndices);\n    }\n\n    function _getFees(\n        UlnConfig memory _config,\n        uint32 _dstEid,\n        address _sender,\n        bytes[] memory _optionsArray,\n        uint8[] memory _dvnIds\n    ) internal view returns (uint256 totalFee) {\n        // here we merge 2 list of dvns into 1 to allocate the indexed dvn options to the right dvn\n        uint8 dvnsLength = _config.requiredDVNCount + _config.optionalDVNCount;\n        for (uint8 i = 0; i < dvnsLength; ++i) {\n            address dvn = i < _config.requiredDVNCount\n                ? _config.requiredDVNs[i]\n                : _config.optionalDVNs[i - _config.requiredDVNCount];\n\n            bytes memory options = \"\";\n            // it is a double loop here. however, if the list is short, the cost is very acceptable.\n            for (uint256 j = 0; j < _dvnIds.length; ++j) {\n                if (_dvnIds[j] == i) {\n                    options = _optionsArray[j];\n                    break;\n                }\n            }\n            totalFee += ILayerZeroDVN(dvn).getFee(_dstEid, _config.confirmations, _sender, options);\n        }\n    }\n}\n"
    },
    "contracts/messagelib/contracts/uln/uln301/AddressSizeConfig.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nabstract contract AddressSizeConfig is Ownable {\n    // EndpointV1 is using bytes as address. this map is for address length assertion\n    mapping(uint32 dstEid => uint256 size) public addressSizes;\n\n    event AddressSizeSet(uint16 eid, uint256 size);\n\n    error AddressSizeConfig_InvalidAddressSize();\n    error AddressSizeConfig_AddressSizeAlreadySet();\n\n    function setAddressSize(uint16 _eid, uint256 _size) external onlyOwner {\n        if (_size > 32) revert AddressSizeConfig_InvalidAddressSize();\n        if (addressSizes[_eid] != 0) revert AddressSizeConfig_AddressSizeAlreadySet();\n        addressSizes[_eid] = _size;\n        emit AddressSizeSet(_eid, _size);\n    }\n}\n"
    },
    "contracts/messagelib/contracts/uln/uln301/interfaces/IMessageLibE1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport { ILayerZeroMessagingLibrary } from \"@layerzerolabs/lz-evm-v1-0.7/contracts/interfaces/ILayerZeroMessagingLibrary.sol\";\n\n/// extends ILayerZeroMessagingLibrary instead of ILayerZeroMessagingLibraryV2 for reducing the contract size\ninterface IMessageLibE1 is ILayerZeroMessagingLibrary {\n    error LZ_MessageLib_InvalidPath();\n    error LZ_MessageLib_InvalidSender();\n    error LZ_MessageLib_InsufficientMsgValue();\n    error LZ_MessageLib_LzTokenPaymentAddressMustBeSender();\n\n    function setLzToken(address _lzToken) external;\n\n    function setTreasury(address _treasury) external;\n\n    function withdrawFee(address _to, uint256 _amount) external;\n\n    // message libs of same major version are compatible\n    function version() external view returns (uint64 major, uint8 minor, uint8 endpointVersion);\n}\n"
    },
    "contracts/messagelib/contracts/uln/uln301/interfaces/INonceContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface INonceContract {\n    function increment(uint16 _chainId, address _ua, bytes calldata _path) external returns (uint64);\n}\n"
    },
    "contracts/messagelib/contracts/uln/uln301/interfaces/ITreasuryFeeHandler.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface ITreasuryFeeHandler {\n    function payFee(\n        address _lzToken,\n        address _sender,\n        uint256 _required,\n        uint256 _supplied,\n        address _treasury\n    ) external;\n}\n"
    },
    "contracts/messagelib/contracts/uln/uln301/interfaces/IUltraLightNode301.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface IUltraLightNode301 {\n    function commitVerification(bytes calldata _packet, uint256 _gasLimit) external;\n}\n"
    },
    "contracts/messagelib/contracts/uln/uln301/mocks/NonceContractMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.19;\n\nimport { ILayerZeroEndpoint } from \"@layerzerolabs/lz-evm-v1-0.7/contracts/interfaces/ILayerZeroEndpoint.sol\";\n\ncontract NonceContractMock {\n    error OnlySendLibrary();\n\n    ILayerZeroEndpoint public immutable endpoint;\n    mapping(uint16 dstEid => mapping(bytes path => uint64 nonce)) public outboundNonce;\n\n    constructor(address _endpoint) {\n        endpoint = ILayerZeroEndpoint(_endpoint);\n    }\n\n    function increment(uint16 _chainId, address _ua, bytes calldata _path) external returns (uint64) {\n        if (msg.sender != endpoint.getSendLibraryAddress(_ua)) {\n            revert OnlySendLibrary();\n        }\n        return ++outboundNonce[_chainId][_path];\n    }\n}\n"
    },
    "contracts/messagelib/contracts/uln/uln301/ReceiveLibBaseE1.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { Origin } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\nimport { ILayerZeroEndpoint } from \"@layerzerolabs/lz-evm-v1-0.7/contracts/interfaces/ILayerZeroEndpoint.sol\";\nimport { AddressCast } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/AddressCast.sol\";\n\nimport { AddressSizeConfig } from \"./AddressSizeConfig.sol\";\nimport { MessageLibBase } from \"../../MessageLibBase.sol\";\n\n// only receiver function from \"@layerzerolabs/lz-evm-v1-0.7/contracts/interfaces/ILayerZeroMessagingLibrary.sol\"\n// because we are separating the send and receive libraries\ninterface ILayerZeroReceiveLibrary {\n    // setConfig / getConfig are User Application (UA) functions to specify Oracle, Relayer, blockConfirmations, libraryVersion\n    function setConfig(uint16 _chainId, address _userApplication, uint256 _configType, bytes calldata _config) external;\n\n    function getConfig(\n        uint16 _chainId,\n        address _userApplication,\n        uint256 _configType\n    ) external view returns (bytes memory);\n}\n\nstruct SetDefaultExecutorParam {\n    uint32 eid;\n    address executor;\n}\n\n/// @dev receive-side message library base contract on endpoint v1.\n/// design:\n/// 1/ it provides an internal execute function that calls the endpoint. It enforces the path definition on V1.\n/// 2/ it provides interfaces to configure executors that is whitelisted to execute the msg to prevent grieving\nabstract contract ReceiveLibBaseE1 is MessageLibBase, AddressSizeConfig, ILayerZeroReceiveLibrary {\n    using AddressCast for bytes32;\n\n    mapping(address oapp => mapping(uint32 eid => address executor)) public executors;\n    mapping(uint32 eid => address executor) public defaultExecutors;\n\n    // this event is the same as the PacketDelivered event on EndpointV2\n    event PacketDelivered(Origin origin, address receiver);\n    event InvalidDst(\n        uint16 indexed srcChainId,\n        bytes32 srcAddress,\n        address indexed dstAddress,\n        uint64 nonce,\n        bytes32 payloadHash\n    );\n    event DefaultExecutorsSet(SetDefaultExecutorParam[] params);\n    event ExecutorSet(address oapp, uint32 eid, address executor);\n\n    error LZ_MessageLib_InvalidExecutor();\n    error LZ_MessageLib_OnlyExecutor();\n\n    constructor(address _endpoint, uint32 _localEid) MessageLibBase(_endpoint, _localEid) {}\n\n    function setDefaultExecutors(SetDefaultExecutorParam[] calldata _params) external onlyOwner {\n        for (uint256 i = 0; i < _params.length; ++i) {\n            SetDefaultExecutorParam calldata param = _params[i];\n            if (param.executor == address(0x0)) revert LZ_MessageLib_InvalidExecutor();\n            defaultExecutors[param.eid] = param.executor;\n        }\n        emit DefaultExecutorsSet(_params);\n    }\n\n    function getExecutor(address _oapp, uint32 _remoteEid) public view returns (address) {\n        address executor = executors[_oapp][_remoteEid];\n        return executor != address(0x0) ? executor : defaultExecutors[_remoteEid];\n    }\n\n    function _setExecutor(uint32 _remoteEid, address _oapp, address _executor) internal {\n        executors[_oapp][_remoteEid] = _executor;\n        emit ExecutorSet(_oapp, _remoteEid, _executor);\n    }\n\n    /// @dev this function change pack the path as required for EndpointV1\n    function _execute(\n        uint16 _srcEid,\n        bytes32 _sender,\n        address _receiver,\n        uint64 _nonce,\n        bytes memory _message,\n        uint256 _gasLimit\n    ) internal {\n        // if the executor is malicious, it can make the msg as a storedPayload or fail in the nonBlockingApp\n        // which might result in unintended behaviour and risks, like grieving.\n        // to err on the safe side, we should assert the executor here.\n        if (msg.sender != getExecutor(_receiver, _srcEid)) revert LZ_MessageLib_OnlyExecutor();\n\n        if (_receiver.code.length == 0) {\n            /// on chains where EOA has no codes, it will early return and emit InvalidDst event\n            // on chains where all address have codes, this will be skipped\n            emit InvalidDst(_srcEid, _sender, _receiver, _nonce, keccak256(_message));\n            return;\n        }\n\n        bytes memory pathData = abi.encodePacked(_sender.toBytes(addressSizes[_srcEid]), _receiver);\n        ILayerZeroEndpoint(endpoint).receivePayload(_srcEid, pathData, _receiver, _nonce, _gasLimit, _message);\n\n        Origin memory origin = Origin(_srcEid, _sender, _nonce);\n        emit PacketDelivered(origin, _receiver);\n    }\n}\n"
    },
    "contracts/messagelib/contracts/uln/uln301/ReceiveUln301.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { PacketV1Codec } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/PacketV1Codec.sol\";\n\nimport { IUltraLightNode301 } from \"./interfaces/IUltraLightNode301.sol\";\nimport { ReceiveLibBaseE1 } from \"./ReceiveLibBaseE1.sol\";\nimport { ReceiveUlnBase } from \"../ReceiveUlnBase.sol\";\nimport { UlnConfig } from \"../UlnBase.sol\";\n\n/// @dev ULN301 will be deployed on EndpointV1 and is for backward compatibility with ULN302 on EndpointV2. 301 can talk to both 301 and 302\n/// @dev This is a gluing contract. It simply parses the requests and forward to the super.impl() accordingly.\n/// @dev In this case, it combines the logic of ReceiveUlnBase and ReceiveLibBaseE1\ncontract ReceiveUln301 is IUltraLightNode301, ReceiveUlnBase, ReceiveLibBaseE1 {\n    using PacketV1Codec for bytes;\n    using SafeCast for uint32; // for chain ID uint32 to uint16 conversion\n\n    uint256 internal constant CONFIG_TYPE_EXECUTOR = 1;\n    uint256 internal constant CONFIG_TYPE_ULN = 2;\n\n    error LZ_ULN_InvalidConfigType(uint256 configType);\n\n    constructor(address _endpoint, uint32 _localEid) ReceiveLibBaseE1(_endpoint, _localEid) {}\n\n    // ============================ OnlyEndpoint ===================================\n\n    function setConfig(\n        uint16 _eid,\n        address _oapp,\n        uint256 _configType,\n        bytes calldata _config\n    ) external override onlyEndpoint {\n        _assertSupportedEid(_eid);\n        if (_configType == CONFIG_TYPE_EXECUTOR) {\n            _setExecutor(_eid, _oapp, abi.decode(_config, (address)));\n        } else if (_configType == CONFIG_TYPE_ULN) {\n            _setUlnConfig(_eid, _oapp, abi.decode(_config, (UlnConfig)));\n        } else {\n            revert LZ_ULN_InvalidConfigType(_configType);\n        }\n    }\n\n    // ============================ External ===================================\n\n    /// @dev in 301, this is equivalent to execution as in Endpoint V2\n    /// @dev dont need to check endpoint verifiable here to save gas, as it will reverts if not verifiable.\n    function commitVerification(bytes calldata _packet, uint256 _gasLimit) external {\n        bytes calldata header = _packet.header();\n        _assertHeader(header, localEid);\n\n        // cache these values to save gas\n        address receiver = _packet.receiverB20();\n        uint16 srcEid = _packet.srcEid().toUint16();\n\n        UlnConfig memory config = getUlnConfig(receiver, srcEid);\n        _verifyAndReclaimStorage(config, keccak256(header), _packet.payloadHash());\n\n        // endpoint will revert if nonce != ++inboundNonce\n        _execute(srcEid, _packet.sender(), receiver, _packet.nonce(), _packet.message(), _gasLimit);\n    }\n\n    function verify(bytes calldata _packetHeader, bytes32 _payloadHash, uint64 _confirmations) external {\n        _verify(_packetHeader, _payloadHash, _confirmations);\n    }\n\n    // ============================ View ===================================\n\n    function getConfig(uint16 _eid, address _oapp, uint256 _configType) external view override returns (bytes memory) {\n        if (_configType == CONFIG_TYPE_EXECUTOR) {\n            return abi.encode(getExecutor(_oapp, _eid));\n        } else if (_configType == CONFIG_TYPE_ULN) {\n            return abi.encode(getUlnConfig(_oapp, _eid));\n        } else {\n            revert LZ_ULN_InvalidConfigType(_configType);\n        }\n    }\n\n    function version() external pure returns (uint64 major, uint8 minor, uint8 endpointVersion) {\n        return (3, 0, 1);\n    }\n}\n"
    },
    "contracts/messagelib/contracts/uln/uln301/ReceiveUln301View.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { Proxied } from \"hardhat-deploy/solc_0.8/proxy/Proxied.sol\";\n\nimport { ILayerZeroEndpoint } from \"@layerzerolabs/lz-evm-v1-0.7/contracts/interfaces/ILayerZeroEndpoint.sol\";\nimport { AddressCast } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/AddressCast.sol\";\nimport { PacketV1Codec } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/PacketV1Codec.sol\";\nimport { ExecutionState, EndpointV2View } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/EndpointV2View.sol\";\n\nimport { UlnConfig } from \"../UlnBase.sol\";\n\nenum VerificationState {\n    Verifying,\n    Verifiable,\n    Verified\n}\n\ninterface IReceiveUln301 {\n    function assertHeader(bytes calldata _packetHeader, uint32 _localEid) external pure;\n\n    function addressSizes(uint32 _dstEid) external view returns (uint256);\n\n    function endpoint() external view returns (address);\n\n    function verifiable(\n        UlnConfig memory _config,\n        bytes32 _headerHash,\n        bytes32 _payloadHash\n    ) external view returns (bool);\n\n    function getUlnConfig(address _oapp, uint32 _remoteEid) external view returns (UlnConfig memory rtnConfig);\n}\n\ncontract ReceiveUln301View is Initializable, Proxied {\n    using PacketV1Codec for bytes;\n    using AddressCast for bytes32;\n    using SafeCast for uint32;\n\n    ILayerZeroEndpoint public endpoint;\n    IReceiveUln301 public receiveUln301;\n    uint32 internal localEid;\n\n    function initialize(address _endpoint, uint32 _localEid, address _receiveUln301) external proxied initializer {\n        receiveUln301 = IReceiveUln301(_receiveUln301);\n        endpoint = ILayerZeroEndpoint(_endpoint);\n        localEid = _localEid;\n    }\n\n    function executable(bytes calldata _packetHeader, bytes32 _payloadHash) public view returns (ExecutionState) {\n        receiveUln301.assertHeader(_packetHeader, localEid);\n\n        address receiver = _packetHeader.receiverB20();\n        uint16 srcEid = _packetHeader.srcEid().toUint16();\n        uint64 nonce = _packetHeader.nonce();\n\n        // executed if nonce less than or equal to inboundNonce\n        bytes memory path = abi.encodePacked(\n            _packetHeader.sender().toBytes(receiveUln301.addressSizes(srcEid)),\n            receiver\n        );\n        if (nonce <= endpoint.getInboundNonce(srcEid, path)) return ExecutionState.Executed;\n\n        // executable if not executed and _verified\n        if (\n            receiveUln301.verifiable(\n                receiveUln301.getUlnConfig(receiver, srcEid),\n                keccak256(_packetHeader),\n                _payloadHash\n            )\n        ) {\n            return ExecutionState.Executable;\n        }\n\n        return ExecutionState.NotExecutable;\n    }\n\n    /// @dev keeping the same interface as 302\n    /// @dev a verifiable message requires it to be ULN verifiable only, excluding the endpoint verifiable check\n    function verifiable(bytes calldata _packetHeader, bytes32 _payloadHash) external view returns (VerificationState) {\n        if (executable(_packetHeader, _payloadHash) == ExecutionState.NotExecutable) {\n            return VerificationState.Verifying;\n        }\n        return VerificationState.Verified;\n    }\n}\n"
    },
    "contracts/messagelib/contracts/uln/uln301/SendLibBaseE1.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { Packet } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ISendLib.sol\";\nimport { AddressCast } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/AddressCast.sol\";\nimport { GUID } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/GUID.sol\";\nimport { Transfer } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/Transfer.sol\";\n\nimport { IMessageLibE1 } from \"./interfaces/IMessageLibE1.sol\";\nimport { ITreasuryFeeHandler } from \"./interfaces/ITreasuryFeeHandler.sol\";\nimport { INonceContract } from \"./interfaces/INonceContract.sol\";\nimport { SendLibBase, WorkerOptions, ExecutorConfig } from \"../../SendLibBase.sol\";\nimport { AddressSizeConfig } from \"./AddressSizeConfig.sol\";\n\n/// @dev send-side message library base contract on endpoint v1.\n/// design:\n/// 1/ it enforces the path definition on V1 and interacts with the nonce contract\n/// 2/ quote: first executor, then verifier (e.g. DVNs), then treasury\n/// 3/ send: first executor, then verifier (e.g. DVNs), then treasury. the treasury pay much be DoS-proof\nabstract contract SendLibBaseE1 is SendLibBase, AddressSizeConfig, IMessageLibE1 {\n    INonceContract public immutable nonceContract;\n    ITreasuryFeeHandler public immutable treasuryFeeHandler;\n\n    // config\n    address internal lzToken;\n\n    // this event should be identical to the one on Endpoint V2\n    event PacketSent(bytes encodedPayload, bytes options, uint256 nativeFee, uint256 lzTokenFee);\n    event NativeFeeWithdrawn(address user, address receiver, uint256 amount);\n    event LzTokenSet(address token);\n\n    constructor(\n        address _endpoint,\n        uint256 _treasuryGasLimit,\n        uint256 _treasuryNativeFeeCap,\n        address _nonceContract,\n        uint32 _localEid,\n        address _treasuryFeeHandler\n    ) SendLibBase(_endpoint, _localEid, _treasuryGasLimit, _treasuryNativeFeeCap) {\n        nonceContract = INonceContract(_nonceContract);\n        treasuryFeeHandler = ITreasuryFeeHandler(_treasuryFeeHandler);\n    }\n\n    // ======================= OnlyEndpoint =======================\n    /// @dev the abstract process for send() is:\n    /// 1/ pay workers, which includes the executor and the validation workers\n    /// 2/ pay treasury\n    /// 3/ in EndpointV1, here we handle the fees and refunds\n    function send(\n        address _sender,\n        uint64, // _nonce\n        uint16 _dstEid,\n        bytes calldata _path, // remoteAddress + localAddress\n        bytes calldata _message,\n        address payable _refundAddress,\n        address _lzTokenPaymentAddress,\n        bytes calldata _options\n    ) external payable onlyEndpoint {\n        (bytes memory encodedPacket, uint256 totalNativeFee) = _payWorkers(_sender, _dstEid, _path, _message, _options);\n\n        // quote treasury fee\n        uint32 dstEid = _dstEid; // stack too deep\n        address sender = _sender; // stack too deep\n        bool payInLzToken = _lzTokenPaymentAddress != address(0x0) && address(lzToken) != address(0x0);\n        (uint256 treasuryNativeFee, uint256 lzTokenFee) = _payTreasury(sender, dstEid, totalNativeFee, payInLzToken);\n        totalNativeFee += treasuryNativeFee;\n\n        // pay native fee\n        // assert the user has attached enough native token for this address\n        if (msg.value < totalNativeFee) revert LZ_MessageLib_InsufficientMsgValue();\n        // refund if they send too much\n        uint256 refundAmt = msg.value - totalNativeFee;\n        if (refundAmt > 0) {\n            Transfer.native(_refundAddress, refundAmt);\n        }\n\n        // pay lz token fee if needed\n        if (lzTokenFee > 0) {\n            // in v2, we let user pass a payInLzToken boolean but always charging the sender\n            // likewise in v1, if _lzTokenPaymentAddress is passed, it must be the sender\n            if (_lzTokenPaymentAddress != sender) revert LZ_MessageLib_LzTokenPaymentAddressMustBeSender();\n            _payLzTokenFee(sender, lzTokenFee);\n        }\n\n        emit PacketSent(encodedPacket, _options, totalNativeFee, lzTokenFee);\n    }\n\n    // ======================= OnlyOwner =======================\n    function setLzToken(address _lzToken) external onlyOwner {\n        lzToken = _lzToken;\n        emit LzTokenSet(_lzToken);\n    }\n\n    function setTreasury(address _treasury) external onlyOwner {\n        _setTreasury(_treasury);\n    }\n\n    // ======================= External =======================\n    function withdrawFee(address _to, uint256 _amount) external {\n        _debitFee(_amount);\n        Transfer.native(_to, _amount);\n        emit NativeFeeWithdrawn(msg.sender, _to, _amount);\n    }\n\n    // ======================= View =======================\n    function estimateFees(\n        uint16 _dstEid,\n        address _sender,\n        bytes calldata _message,\n        bool _payInLzToken,\n        bytes calldata _options\n    ) external view returns (uint256 nativeFee, uint256 lzTokenFee) {\n        return _quote(_sender, _dstEid, _message.length, _payInLzToken, _options);\n    }\n\n    // ======================= Internal =======================\n    /// @dev path = remoteAddress + localAddress.\n    function _assertPath(address _sender, bytes calldata _path, uint256 remoteAddressSize) internal pure {\n        if (_path.length != 20 + remoteAddressSize) revert LZ_MessageLib_InvalidPath();\n        address srcInPath = AddressCast.toAddress(_path[remoteAddressSize:]);\n        if (_sender != srcInPath) revert LZ_MessageLib_InvalidSender();\n    }\n\n    function _payLzTokenFee(address _sender, uint256 _lzTokenFee) internal {\n        treasuryFeeHandler.payFee(\n            lzToken,\n            _sender,\n            _lzTokenFee, // the supplied fee is always equal to the required fee\n            _lzTokenFee,\n            treasury\n        );\n    }\n\n    /// @dev outbound does three things\n    /// @dev 1) asserts path\n    /// @dev 2) increments the nonce\n    /// @dev 3) assemble packet\n    /// @return packet to be sent to workers\n    function _outbound(\n        address _sender,\n        uint16 _dstEid,\n        bytes calldata _path,\n        bytes calldata _message\n    ) internal returns (Packet memory packet) {\n        // assert toAddress size\n        uint256 remoteAddressSize = addressSizes[_dstEid];\n        if (remoteAddressSize == 0) revert LZ_MessageLib_InvalidPath();\n        _assertPath(_sender, _path, remoteAddressSize);\n\n        // increment nonce\n        uint64 nonce = nonceContract.increment(_dstEid, _sender, _path);\n\n        bytes32 receiver = AddressCast.toBytes32(_path[0:remoteAddressSize]);\n\n        bytes32 guid = GUID.generate(nonce, localEid, _sender, _dstEid, receiver);\n\n        // assemble packet\n        packet = Packet(nonce, localEid, _sender, _dstEid, receiver, guid, _message);\n    }\n\n    /// 1/ handle executor\n    /// 2/ handle other workers\n    function _payWorkers(\n        address _sender,\n        uint16 _dstEid,\n        bytes calldata _path,\n        bytes calldata _message,\n        bytes calldata _options\n    ) internal returns (bytes memory encodedPacket, uint256 totalNativeFee) {\n        Packet memory packet = _outbound(_sender, _dstEid, _path, _message);\n\n        // split workers options\n        (bytes memory executorOptions, WorkerOptions[] memory verificationOptions) = _splitOptions(_options);\n\n        // handle executor\n        ExecutorConfig memory config = getExecutorConfig(_sender, _dstEid);\n        uint256 msgSize = packet.message.length;\n        _assertMessageSize(msgSize, config.maxMessageSize);\n        totalNativeFee += _payExecutor(config.executor, packet.dstEid, packet.sender, msgSize, executorOptions);\n\n        // handle other workers\n        (uint256 verifierFee, bytes memory packetBytes) = _payVerifier(packet, verificationOptions);\n        totalNativeFee += verifierFee;\n\n        encodedPacket = packetBytes;\n    }\n\n    // ======================= Virtual =======================\n    function _payVerifier(\n        Packet memory _packet, // packet is assembled in memory for endpoint-v1. so the location can not be calldata\n        WorkerOptions[] memory _options\n    ) internal virtual returns (uint256 otherWorkerFees, bytes memory encodedPacket);\n}\n"
    },
    "contracts/messagelib/contracts/uln/uln301/SendUln301.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { Packet } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ISendLib.sol\";\n\nimport { ExecutorConfig, WorkerOptions } from \"../../SendLibBase.sol\";\nimport { SendLibBaseE1 } from \"./SendLibBaseE1.sol\";\nimport { SendUlnBase } from \"../SendUlnBase.sol\";\nimport { UlnConfig } from \"../UlnBase.sol\";\n\n/// @dev ULN301 will be deployed on EndpointV1 and is for backward compatibility with ULN302 on EndpointV2. 301 can talk to both 301 and 302\n/// @dev This is a gluing contract. It simply parses the requests and forward to the super.impl() accordingly.\n/// @dev In this case, it combines the logic of SendUlnBase and SendLibBaseE1\ncontract SendUln301 is SendUlnBase, SendLibBaseE1 {\n    uint256 internal constant CONFIG_TYPE_EXECUTOR = 1;\n    uint256 internal constant CONFIG_TYPE_ULN = 2;\n\n    error LZ_ULN_InvalidConfigType(uint256 configType);\n\n    constructor(\n        address _endpoint,\n        uint256 _treasuryGasLimit,\n        uint256 _treasuryGasForFeeCap,\n        address _nonceContract,\n        uint32 _localEid,\n        address _treasuryFeeHandler\n    )\n        SendLibBaseE1(\n            _endpoint,\n            _treasuryGasLimit,\n            _treasuryGasForFeeCap,\n            _nonceContract,\n            _localEid,\n            _treasuryFeeHandler\n        )\n    {}\n\n    // ============================ OnlyEndpoint ===================================\n\n    function setConfig(\n        uint16 _eid,\n        address _oapp,\n        uint256 _configType,\n        bytes calldata _config\n    ) external override onlyEndpoint {\n        _assertSupportedEid(_eid);\n        if (_configType == CONFIG_TYPE_EXECUTOR) {\n            _setExecutorConfig(_eid, _oapp, abi.decode(_config, (ExecutorConfig)));\n        } else if (_configType == CONFIG_TYPE_ULN) {\n            _setUlnConfig(_eid, _oapp, abi.decode(_config, (UlnConfig)));\n        } else {\n            revert LZ_ULN_InvalidConfigType(_configType);\n        }\n    }\n\n    // ============================ View ===================================\n\n    function getConfig(uint16 _eid, address _oapp, uint256 _configType) external view override returns (bytes memory) {\n        if (_configType == CONFIG_TYPE_EXECUTOR) {\n            return abi.encode(getExecutorConfig(_oapp, _eid));\n        } else if (_configType == CONFIG_TYPE_ULN) {\n            return abi.encode(getUlnConfig(_oapp, _eid));\n        } else {\n            revert LZ_ULN_InvalidConfigType(_configType);\n        }\n    }\n\n    function version() external pure override returns (uint64 major, uint8 minor, uint8 endpointVersion) {\n        return (3, 0, 1);\n    }\n\n    function isSupportedEid(uint32 _eid) external view returns (bool) {\n        return _isSupportedEid(_eid);\n    }\n\n    // ============================ Internal ===================================\n\n    function _quoteVerifier(\n        address _sender,\n        uint32 _dstEid,\n        WorkerOptions[] memory _options\n    ) internal view override returns (uint256) {\n        return _quoteDVNs(_sender, _dstEid, _options);\n    }\n\n    function _payVerifier(\n        Packet memory _packet,\n        WorkerOptions[] memory _options\n    ) internal virtual override returns (uint256 otherWorkerFees, bytes memory encodedPacket) {\n        (otherWorkerFees, encodedPacket) = _payDVNs(fees, _packet, _options);\n    }\n\n    function _splitOptions(\n        bytes calldata _options\n    ) internal pure override returns (bytes memory, WorkerOptions[] memory) {\n        return _splitUlnOptions(_options);\n    }\n}\n"
    },
    "contracts/messagelib/contracts/uln/uln301/TreasuryFeeHandler.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { ILayerZeroEndpoint } from \"@layerzerolabs/lz-evm-v1-0.7/contracts/interfaces/ILayerZeroEndpoint.sol\";\n\nimport { ITreasuryFeeHandler } from \"./interfaces/ITreasuryFeeHandler.sol\";\n\ncontract TreasuryFeeHandler is ITreasuryFeeHandler {\n    using SafeERC20 for IERC20;\n\n    ILayerZeroEndpoint public immutable endpoint;\n\n    error LZ_TreasuryFeeHandler_OnlySendLibrary();\n    error LZ_TreasuryFeeHandler_OnlyOnSending();\n    error LZ_TreasuryFeeHandler_InvalidAmount(uint256 required, uint256 supplied);\n\n    constructor(address _endpoint) {\n        endpoint = ILayerZeroEndpoint(_endpoint);\n    }\n\n    // @dev payer of layerzero token must be sender\n    function payFee(\n        address _lzToken,\n        address _sender,\n        uint256 _required,\n        uint256 _supplied,\n        address _treasury\n    ) external {\n        // only sender's message library can call this function and only when sending a payload\n        if (endpoint.getSendLibraryAddress(_sender) != msg.sender) revert LZ_TreasuryFeeHandler_OnlySendLibrary();\n        if (!endpoint.isSendingPayload()) revert LZ_TreasuryFeeHandler_OnlyOnSending();\n        if (_required > _supplied) revert LZ_TreasuryFeeHandler_InvalidAmount(_required, _supplied);\n\n        // send lz token fee to the treasury directly\n        IERC20(_lzToken).safeTransferFrom(_sender, _treasury, _required);\n    }\n}\n"
    },
    "contracts/messagelib/contracts/uln/uln302/ReceiveUln302.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { PacketV1Codec } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/PacketV1Codec.sol\";\nimport { SetConfigParam } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessageLibManager.sol\";\nimport { ILayerZeroEndpointV2, Origin } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\n\nimport { IReceiveUlnE2 } from \"../interfaces/IReceiveUlnE2.sol\";\nimport { ReceiveUlnBase } from \"../ReceiveUlnBase.sol\";\nimport { ReceiveLibBaseE2 } from \"../../ReceiveLibBaseE2.sol\";\nimport { UlnConfig } from \"../UlnBase.sol\";\n\n/// @dev This is a gluing contract. It simply parses the requests and forward to the super.impl() accordingly.\n/// @dev In this case, it combines the logic of ReceiveUlnBase and ReceiveLibBaseE2\ncontract ReceiveUln302 is IReceiveUlnE2, ReceiveUlnBase, ReceiveLibBaseE2 {\n    using PacketV1Codec for bytes;\n\n    /// @dev CONFIG_TYPE_ULN=2 here to align with SendUln302/ReceiveUln302/ReceiveUln301\n    uint32 internal constant CONFIG_TYPE_ULN = 2;\n\n    error LZ_ULN_InvalidConfigType(uint32 configType);\n\n    constructor(address _endpoint) ReceiveLibBaseE2(_endpoint) {}\n\n    function supportsInterface(bytes4 _interfaceId) public view override returns (bool) {\n        return _interfaceId == type(IReceiveUlnE2).interfaceId || super.supportsInterface(_interfaceId);\n    }\n\n    // ============================ OnlyEndpoint ===================================\n\n    // only the ULN config on the receive side\n    function setConfig(address _oapp, SetConfigParam[] calldata _params) external override onlyEndpoint {\n        for (uint256 i = 0; i < _params.length; i++) {\n            SetConfigParam calldata param = _params[i];\n            _assertSupportedEid(param.eid);\n            if (param.configType == CONFIG_TYPE_ULN) {\n                _setUlnConfig(param.eid, _oapp, abi.decode(param.config, (UlnConfig)));\n            } else {\n                revert LZ_ULN_InvalidConfigType(param.configType);\n            }\n        }\n    }\n\n    // ============================ External ===================================\n\n    /// @dev dont need to check endpoint verifiable here to save gas, as it will reverts if not verifiable.\n    function commitVerification(bytes calldata _packetHeader, bytes32 _payloadHash) external {\n        _assertHeader(_packetHeader, localEid);\n\n        // cache these values to save gas\n        address receiver = _packetHeader.receiverB20();\n        uint32 srcEid = _packetHeader.srcEid();\n\n        UlnConfig memory config = getUlnConfig(receiver, srcEid);\n        _verifyAndReclaimStorage(config, keccak256(_packetHeader), _payloadHash);\n\n        Origin memory origin = Origin(srcEid, _packetHeader.sender(), _packetHeader.nonce());\n        // endpoint will revert if nonce <= lazyInboundNonce\n        ILayerZeroEndpointV2(endpoint).verify(origin, receiver, _payloadHash);\n    }\n\n    /// @dev for dvn to verify the payload\n    function verify(bytes calldata _packetHeader, bytes32 _payloadHash, uint64 _confirmations) external {\n        _verify(_packetHeader, _payloadHash, _confirmations);\n    }\n\n    // ============================ View ===================================\n\n    function getConfig(uint32 _eid, address _oapp, uint32 _configType) external view override returns (bytes memory) {\n        if (_configType == CONFIG_TYPE_ULN) {\n            return abi.encode(getUlnConfig(_oapp, _eid));\n        } else {\n            revert LZ_ULN_InvalidConfigType(_configType);\n        }\n    }\n\n    function isSupportedEid(uint32 _eid) external view override returns (bool) {\n        return _isSupportedEid(_eid);\n    }\n\n    function version() external pure override returns (uint64 major, uint8 minor, uint8 endpointVersion) {\n        return (3, 0, 2);\n    }\n}\n"
    },
    "contracts/messagelib/contracts/uln/uln302/ReceiveUln302View.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { Proxied } from \"hardhat-deploy/solc_0.8/proxy/Proxied.sol\";\nimport { PacketV1Codec } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/PacketV1Codec.sol\";\nimport { Origin } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\nimport { EndpointV2ViewUpgradeable } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/EndpointV2ViewUpgradeable.sol\";\nimport { UlnConfig } from \"../UlnBase.sol\";\n\nenum VerificationState {\n    Verifying,\n    Verifiable,\n    Verified,\n    NotInitializable\n}\n\ninterface IReceiveUln302 {\n    function assertHeader(bytes calldata _packetHeader, uint32 _localEid) external pure;\n\n    function verifiable(\n        UlnConfig memory _config,\n        bytes32 _headerHash,\n        bytes32 _payloadHash\n    ) external view returns (bool);\n\n    function getUlnConfig(address _oapp, uint32 _remoteEid) external view returns (UlnConfig memory rtnConfig);\n}\n\ncontract ReceiveUln302View is EndpointV2ViewUpgradeable, Proxied {\n    using PacketV1Codec for bytes;\n\n    IReceiveUln302 public receiveUln302;\n    uint32 internal localEid;\n\n    function initialize(address _endpoint, address _receiveUln302) external proxied initializer {\n        __EndpointV2View_init(_endpoint);\n        receiveUln302 = IReceiveUln302(_receiveUln302);\n        localEid = endpoint.eid();\n    }\n\n    /// @dev a ULN verifiable requires it to be endpoint verifiable and committable\n    function verifiable(bytes calldata _packetHeader, bytes32 _payloadHash) external view returns (VerificationState) {\n        receiveUln302.assertHeader(_packetHeader, localEid);\n\n        address receiver = _packetHeader.receiverB20();\n\n        Origin memory origin = Origin(_packetHeader.srcEid(), _packetHeader.sender(), _packetHeader.nonce());\n\n        // check endpoint initializable\n        if (!initializable(origin, receiver)) {\n            return VerificationState.NotInitializable;\n        }\n\n        // check endpoint verifiable\n        if (!_endpointVerifiable(origin, receiver, _payloadHash)) {\n            return VerificationState.Verified;\n        }\n\n        // check uln verifiable\n        if (\n            receiveUln302.verifiable(\n                receiveUln302.getUlnConfig(receiver, origin.srcEid),\n                keccak256(_packetHeader),\n                _payloadHash\n            )\n        ) {\n            return VerificationState.Verifiable;\n        }\n        return VerificationState.Verifying;\n    }\n\n    /// @dev checks for endpoint verifiable and endpoint has payload hash\n    function _endpointVerifiable(\n        Origin memory origin,\n        address _receiver,\n        bytes32 _payloadHash\n    ) internal view returns (bool) {\n        // check endpoint verifiable\n        if (!verifiable(origin, _receiver, address(receiveUln302), _payloadHash)) return false;\n\n        // if endpoint.verifiable, also check if the payload hash matches\n        // endpoint allows re-verify, check if this payload has already been verified\n        if (endpoint.inboundPayloadHash(_receiver, origin.srcEid, origin.sender, origin.nonce) == _payloadHash)\n            return false;\n\n        return true;\n    }\n}\n"
    },
    "contracts/messagelib/contracts/uln/uln302/SendUln302.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { Packet } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ISendLib.sol\";\nimport { SetConfigParam } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessageLibManager.sol\";\n\nimport { ExecutorConfig } from \"../../SendLibBase.sol\";\nimport { SendLibBaseE2, WorkerOptions } from \"../../SendLibBaseE2.sol\";\nimport { UlnConfig } from \"../UlnBase.sol\";\nimport { SendUlnBase } from \"../SendUlnBase.sol\";\n\n/// @dev This is a gluing contract. It simply parses the requests and forward to the super.impl() accordingly.\n/// @dev In this case, it combines the logic of SendUlnBase and SendLibBaseE2\ncontract SendUln302 is SendUlnBase, SendLibBaseE2 {\n    uint32 internal constant CONFIG_TYPE_EXECUTOR = 1;\n    uint32 internal constant CONFIG_TYPE_ULN = 2;\n\n    error LZ_ULN_InvalidConfigType(uint32 configType);\n\n    constructor(\n        address _endpoint,\n        uint256 _treasuryGasLimit,\n        uint256 _treasuryGasForFeeCap\n    ) SendLibBaseE2(_endpoint, _treasuryGasLimit, _treasuryGasForFeeCap) {}\n\n    // ============================ OnlyEndpoint ===================================\n\n    // on the send side the user can config both the executor and the ULN\n    function setConfig(address _oapp, SetConfigParam[] calldata _params) external override onlyEndpoint {\n        for (uint256 i = 0; i < _params.length; i++) {\n            SetConfigParam calldata param = _params[i];\n            _assertSupportedEid(param.eid);\n            if (param.configType == CONFIG_TYPE_EXECUTOR) {\n                _setExecutorConfig(param.eid, _oapp, abi.decode(param.config, (ExecutorConfig)));\n            } else if (param.configType == CONFIG_TYPE_ULN) {\n                _setUlnConfig(param.eid, _oapp, abi.decode(param.config, (UlnConfig)));\n            } else {\n                revert LZ_ULN_InvalidConfigType(param.configType);\n            }\n        }\n    }\n\n    // ============================ View ===================================\n\n    function getConfig(uint32 _eid, address _oapp, uint32 _configType) external view override returns (bytes memory) {\n        if (_configType == CONFIG_TYPE_EXECUTOR) {\n            return abi.encode(getExecutorConfig(_oapp, _eid));\n        } else if (_configType == CONFIG_TYPE_ULN) {\n            return abi.encode(getUlnConfig(_oapp, _eid));\n        } else {\n            revert LZ_ULN_InvalidConfigType(_configType);\n        }\n    }\n\n    function version() external pure override returns (uint64 major, uint8 minor, uint8 endpointVersion) {\n        return (3, 0, 2);\n    }\n\n    function isSupportedEid(uint32 _eid) external view override returns (bool) {\n        return _isSupportedEid(_eid);\n    }\n\n    // ============================ Internal ===================================\n\n    function _quoteVerifier(\n        address _sender,\n        uint32 _dstEid,\n        WorkerOptions[] memory _options\n    ) internal view override returns (uint256) {\n        return _quoteDVNs(_sender, _dstEid, _options);\n    }\n\n    function _payVerifier(\n        Packet calldata _packet,\n        WorkerOptions[] memory _options\n    ) internal override returns (uint256 otherWorkerFees, bytes memory encodedPacket) {\n        (otherWorkerFees, encodedPacket) = _payDVNs(fees, _packet, _options);\n    }\n\n    function _splitOptions(\n        bytes calldata _options\n    ) internal pure override returns (bytes memory, WorkerOptions[] memory) {\n        return _splitUlnOptions(_options);\n    }\n}\n"
    },
    "contracts/messagelib/contracts/uln/UlnBase.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n// the formal properties are documented in the setter functions\nstruct UlnConfig {\n    uint64 confirmations;\n    // we store the length of required DVNs and optional DVNs instead of using DVN.length directly to save gas\n    uint8 requiredDVNCount; // 0 indicate DEFAULT, NIL_DVN_COUNT indicate NONE (to override the value of default)\n    uint8 optionalDVNCount; // 0 indicate DEFAULT, NIL_DVN_COUNT indicate NONE (to override the value of default)\n    uint8 optionalDVNThreshold; // (0, optionalDVNCount]\n    address[] requiredDVNs; // no duplicates. sorted an an ascending order. allowed overlap with optionalDVNs\n    address[] optionalDVNs; // no duplicates. sorted an an ascending order. allowed overlap with requiredDVNs\n}\n\nstruct SetDefaultUlnConfigParam {\n    uint32 eid;\n    UlnConfig config;\n}\n\n/// @dev includes the utility functions for checking ULN states and logics\nabstract contract UlnBase is Ownable {\n    address private constant DEFAULT_CONFIG = address(0);\n    // reserved values for\n    uint8 internal constant DEFAULT = 0;\n    uint8 internal constant NIL_DVN_COUNT = type(uint8).max;\n    uint64 internal constant NIL_CONFIRMATIONS = type(uint64).max;\n    // 127 to prevent total number of DVNs (127 * 2) exceeding uint8.max (255)\n    // by limiting the total size, it would help constraint the design of DVNOptions\n    uint8 private constant MAX_COUNT = (type(uint8).max - 1) / 2;\n\n    mapping(address oapp => mapping(uint32 eid => UlnConfig)) internal ulnConfigs;\n\n    error LZ_ULN_Unsorted();\n    error LZ_ULN_InvalidRequiredDVNCount();\n    error LZ_ULN_InvalidOptionalDVNCount();\n    error LZ_ULN_AtLeastOneDVN();\n    error LZ_ULN_InvalidOptionalDVNThreshold();\n    error LZ_ULN_InvalidConfirmations();\n    error LZ_ULN_UnsupportedEid(uint32 eid);\n\n    event DefaultUlnConfigsSet(SetDefaultUlnConfigParam[] params);\n    event UlnConfigSet(address oapp, uint32 eid, UlnConfig config);\n\n    // ============================ OnlyOwner ===================================\n\n    /// @dev about the DEFAULT ULN config\n    /// 1) its values are all LITERAL (e.g. 0 is 0). whereas in the oapp ULN config, 0 (default value) points to the default ULN config\n    ///     this design enables the oapp to point to DEFAULT config without explicitly setting the config\n    /// 2) its configuration is more restrictive than the oapp ULN config that\n    ///     a) it must not use NIL value, where NIL is used only by oapps to indicate the LITERAL 0\n    ///     b) it must have at least one DVN\n    function setDefaultUlnConfigs(SetDefaultUlnConfigParam[] calldata _params) external onlyOwner {\n        for (uint256 i = 0; i < _params.length; ++i) {\n            SetDefaultUlnConfigParam calldata param = _params[i];\n\n            // 2.a must not use NIL\n            if (param.config.requiredDVNCount == NIL_DVN_COUNT) revert LZ_ULN_InvalidRequiredDVNCount();\n            if (param.config.optionalDVNCount == NIL_DVN_COUNT) revert LZ_ULN_InvalidOptionalDVNCount();\n            if (param.config.confirmations == NIL_CONFIRMATIONS) revert LZ_ULN_InvalidConfirmations();\n\n            // 2.b must have at least one dvn\n            _assertAtLeastOneDVN(param.config);\n\n            _setConfig(DEFAULT_CONFIG, param.eid, param.config);\n        }\n        emit DefaultUlnConfigsSet(_params);\n    }\n\n    // ============================ View ===================================\n    // @dev assuming most oapps use default, we get default as memory and custom as storage to save gas\n    function getUlnConfig(address _oapp, uint32 _remoteEid) public view returns (UlnConfig memory rtnConfig) {\n        UlnConfig storage defaultConfig = ulnConfigs[DEFAULT_CONFIG][_remoteEid];\n        UlnConfig storage customConfig = ulnConfigs[_oapp][_remoteEid];\n\n        // if confirmations is 0, use default\n        uint64 confirmations = customConfig.confirmations;\n        if (confirmations == DEFAULT) {\n            rtnConfig.confirmations = defaultConfig.confirmations;\n        } else if (confirmations != NIL_CONFIRMATIONS) {\n            // if confirmations is uint64.max, no block confirmations required\n            rtnConfig.confirmations = confirmations;\n        } // else do nothing, rtnConfig.confirmation is 0\n\n        if (customConfig.requiredDVNCount == DEFAULT) {\n            if (defaultConfig.requiredDVNCount > 0) {\n                // copy only if count > 0. save gas\n                rtnConfig.requiredDVNs = defaultConfig.requiredDVNs;\n                rtnConfig.requiredDVNCount = defaultConfig.requiredDVNCount;\n            } // else, do nothing\n        } else {\n            if (customConfig.requiredDVNCount != NIL_DVN_COUNT) {\n                rtnConfig.requiredDVNs = customConfig.requiredDVNs;\n                rtnConfig.requiredDVNCount = customConfig.requiredDVNCount;\n            } // else, do nothing\n        }\n\n        if (customConfig.optionalDVNCount == DEFAULT) {\n            if (defaultConfig.optionalDVNCount > 0) {\n                // copy only if count > 0. save gas\n                rtnConfig.optionalDVNs = defaultConfig.optionalDVNs;\n                rtnConfig.optionalDVNCount = defaultConfig.optionalDVNCount;\n                rtnConfig.optionalDVNThreshold = defaultConfig.optionalDVNThreshold;\n            }\n        } else {\n            if (customConfig.optionalDVNCount != NIL_DVN_COUNT) {\n                rtnConfig.optionalDVNs = customConfig.optionalDVNs;\n                rtnConfig.optionalDVNCount = customConfig.optionalDVNCount;\n                rtnConfig.optionalDVNThreshold = customConfig.optionalDVNThreshold;\n            }\n        }\n\n        // the final value must have at least one dvn\n        // it is possible that some default config result into 0 dvns\n        _assertAtLeastOneDVN(rtnConfig);\n    }\n\n    /// @dev Get the uln config without the default config for the given remoteEid.\n    function getAppUlnConfig(address _oapp, uint32 _remoteEid) external view returns (UlnConfig memory) {\n        return ulnConfigs[_oapp][_remoteEid];\n    }\n\n    // ============================ Internal ===================================\n    function _setUlnConfig(uint32 _remoteEid, address _oapp, UlnConfig memory _param) internal {\n        _setConfig(_oapp, _remoteEid, _param);\n\n        // get ULN config again as a catch all to ensure the config is valid\n        getUlnConfig(_oapp, _remoteEid);\n        emit UlnConfigSet(_oapp, _remoteEid, _param);\n    }\n\n    /// @dev a supported Eid must have a valid default uln config, which has at least one dvn\n    function _isSupportedEid(uint32 _remoteEid) internal view returns (bool) {\n        UlnConfig storage defaultConfig = ulnConfigs[DEFAULT_CONFIG][_remoteEid];\n        return defaultConfig.requiredDVNCount > 0 || defaultConfig.optionalDVNThreshold > 0;\n    }\n\n    function _assertSupportedEid(uint32 _remoteEid) internal view {\n        if (!_isSupportedEid(_remoteEid)) revert LZ_ULN_UnsupportedEid(_remoteEid);\n    }\n\n    // ============================ Private ===================================\n\n    function _assertAtLeastOneDVN(UlnConfig memory _config) private pure {\n        if (_config.requiredDVNCount == 0 && _config.optionalDVNThreshold == 0) revert LZ_ULN_AtLeastOneDVN();\n    }\n\n    /// @dev this private function is used in both setDefaultUlnConfigs and setUlnConfig\n    function _setConfig(address _oapp, uint32 _eid, UlnConfig memory _param) private {\n        // @dev required dvns\n        // if dvnCount == NONE, dvns list must be empty\n        // if dvnCount == DEFAULT, dvn list must be empty\n        // otherwise, dvnList.length == dvnCount and assert the list is valid\n        if (_param.requiredDVNCount == NIL_DVN_COUNT || _param.requiredDVNCount == DEFAULT) {\n            if (_param.requiredDVNs.length != 0) revert LZ_ULN_InvalidRequiredDVNCount();\n        } else {\n            if (_param.requiredDVNs.length != _param.requiredDVNCount || _param.requiredDVNCount > MAX_COUNT)\n                revert LZ_ULN_InvalidRequiredDVNCount();\n            _assertNoDuplicates(_param.requiredDVNs);\n        }\n\n        // @dev optional dvns\n        // if optionalDVNCount == NONE, optionalDVNs list must be empty and threshold must be 0\n        // if optionalDVNCount == DEFAULT, optionalDVNs list must be empty and threshold must be 0\n        // otherwise, optionalDVNs.length == optionalDVNCount, threshold > 0 && threshold <= optionalDVNCount and assert the list is valid\n\n        // example use case: an oapp uses the DEFAULT 'required' but\n        //     a) use a custom 1/1 dvn (practically a required dvn), or\n        //     b) use a custom 2/3 dvn\n        if (_param.optionalDVNCount == NIL_DVN_COUNT || _param.optionalDVNCount == DEFAULT) {\n            if (_param.optionalDVNs.length != 0) revert LZ_ULN_InvalidOptionalDVNCount();\n            if (_param.optionalDVNThreshold != 0) revert LZ_ULN_InvalidOptionalDVNThreshold();\n        } else {\n            if (_param.optionalDVNs.length != _param.optionalDVNCount || _param.optionalDVNCount > MAX_COUNT)\n                revert LZ_ULN_InvalidOptionalDVNCount();\n            if (_param.optionalDVNThreshold == 0 || _param.optionalDVNThreshold > _param.optionalDVNCount)\n                revert LZ_ULN_InvalidOptionalDVNThreshold();\n            _assertNoDuplicates(_param.optionalDVNs);\n        }\n        // don't assert valid count here, as it needs to be validated along side default config\n\n        ulnConfigs[_oapp][_eid] = _param;\n    }\n\n    function _assertNoDuplicates(address[] memory _dvns) private pure {\n        address lastDVN = address(0);\n        for (uint256 i = 0; i < _dvns.length; i++) {\n            address dvn = _dvns[i];\n            if (dvn <= lastDVN) revert LZ_ULN_Unsorted(); // to ensure no duplicates\n            lastDVN = dvn;\n        }\n    }\n}\n"
    },
    "contracts/messagelib/contracts/upgradeable/proxy/ProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// OpenZeppelin Contracts v4.4.1 (proxy/transparent/ProxyAdmin.sol)\n\npragma solidity ^0.8.0;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport { TransparentUpgradeableProxy } from \"./TransparentUpgradeableProxy.sol\";\n\n/**\n * @author OpenZeppelin. Modified from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.4/contracts/proxy/transparent/ProxyAdmin.sol\n * to support custom errors and `initialOwner` constructor parameter.\n * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an\n * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.\n */\ncontract ProxyAdmin is Ownable {\n    error ImplementationCallFailed();\n    error AdminCallFailed();\n\n    constructor(address initialOwner) {\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Returns the current implementation of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyImplementation(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"implementation()\")) == 0x5c60da1b\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"5c60da1b\");\n        if (!success) {\n            revert ImplementationCallFailed();\n        }\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Returns the current admin of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyAdmin(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"admin()\")) == 0xf851a440\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"f851a440\");\n        if (!success) {\n            revert AdminCallFailed();\n        }\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Changes the admin of `proxy` to `newAdmin`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the current admin of `proxy`.\n     */\n    function changeProxyAdmin(TransparentUpgradeableProxy proxy, address newAdmin) public virtual onlyOwner {\n        proxy.changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgrade(TransparentUpgradeableProxy proxy, address implementation) public virtual onlyOwner {\n        proxy.upgradeTo(implementation);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See\n     * {TransparentUpgradeableProxy-upgradeToAndCall}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgradeAndCall(\n        TransparentUpgradeableProxy proxy,\n        address implementation,\n        bytes memory data\n    ) public payable virtual onlyOwner {\n        proxy.upgradeToAndCall{ value: msg.value }(implementation, data);\n    }\n}\n"
    },
    "contracts/messagelib/contracts/upgradeable/proxy/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// OpenZeppelin Contracts v4.4.1 (proxy/transparent/TransparentUpgradeableProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport { ERC1967Proxy } from \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\";\n\n/**\n * @author OpenZeppelin. Modified from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.4/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\n * to support custom errors.\n * @dev This contract implements a proxy that is upgradeable by an admin.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error indicating\n * the proxy admin cannot fallback to the target implementation.\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n */\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\n    /**\n     * @dev The proxy caller is the current admin, and can't fallback to the proxy target.\n     */\n    error AdminAccessDenied();\n\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\n     */\n    constructor(address _logic, address admin_, bytes memory _data) payable ERC1967Proxy(_logic, _data) {\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n        _changeAdmin(admin_);\n    }\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _getAdmin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function admin() external ifAdmin returns (address admin_) {\n        admin_ = _getAdmin();\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function implementation() external ifAdmin returns (address implementation_) {\n        implementation_ = _implementation();\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\n     */\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\n        _changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\n     */\n    function upgradeTo(address newImplementation) external ifAdmin {\n        _upgradeToAndCall(newImplementation, bytes(\"\"), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\n        _upgradeToAndCall(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _admin() internal view virtual returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\n     */\n    function _beforeFallback() internal virtual override {\n        if (msg.sender == _getAdmin()) {\n            revert AdminAccessDenied();\n        }\n        super._beforeFallback();\n    }\n}\n"
    },
    "contracts/messagelib/contracts/upgradeable/WorkerUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport { AccessControlUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport { ISendLib } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ISendLib.sol\";\nimport { Transfer } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/Transfer.sol\";\n\nimport { IWorker } from \"../interfaces/IWorker.sol\";\n\nabstract contract WorkerUpgradeable is Initializable, AccessControlUpgradeable, PausableUpgradeable, IWorker {\n    bytes32 internal constant MESSAGE_LIB_ROLE = keccak256(\"MESSAGE_LIB_ROLE\");\n    bytes32 internal constant ALLOWLIST = keccak256(\"ALLOWLIST\");\n    bytes32 internal constant DENYLIST = keccak256(\"DENYLIST\");\n    bytes32 internal constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n\n    address public workerFeeLib;\n\n    uint64 public allowlistSize;\n    uint16 public defaultMultiplierBps;\n    address public priceFeed;\n\n    mapping(uint32 eid => uint8[] optionTypes) internal supportedOptionTypes;\n\n    /// @param _messageLibs array of message lib addresses that are granted the MESSAGE_LIB_ROLE\n    /// @param _priceFeed price feed address\n    /// @param _defaultMultiplierBps default multiplier for worker fee\n    /// @param _roleAdmin address that is granted the DEFAULT_ADMIN_ROLE (can grant and revoke all roles)\n    /// @param _admins array of admin addresses that are granted the ADMIN_ROLE\n    function __Worker_init(\n        address[] memory _messageLibs,\n        address _priceFeed,\n        uint16 _defaultMultiplierBps,\n        address _roleAdmin,\n        address[] memory _admins\n    ) internal onlyInitializing {\n        __Context_init_unchained();\n        __AccessControl_init_unchained();\n        __Pausable_init_unchained();\n        __Worker_init_unchained(_messageLibs, _priceFeed, _defaultMultiplierBps, _roleAdmin, _admins);\n    }\n\n    function __Worker_init_unchained(\n        address[] memory _messageLibs,\n        address _priceFeed,\n        uint16 _defaultMultiplierBps,\n        address _roleAdmin,\n        address[] memory _admins\n    ) internal onlyInitializing {\n        defaultMultiplierBps = _defaultMultiplierBps;\n        priceFeed = _priceFeed;\n\n        if (_roleAdmin != address(0x0)) {\n            _grantRole(DEFAULT_ADMIN_ROLE, _roleAdmin); // _roleAdmin can grant and revoke all roles\n        }\n\n        for (uint256 i = 0; i < _messageLibs.length; ++i) {\n            _grantRole(MESSAGE_LIB_ROLE, _messageLibs[i]);\n        }\n\n        for (uint256 i = 0; i < _admins.length; ++i) {\n            _grantRole(ADMIN_ROLE, _admins[i]);\n        }\n    }\n\n    // ========================= Modifier =========================\n\n    modifier onlyAcl(address _sender) {\n        if (!hasAcl(_sender)) {\n            revert Worker_NotAllowed();\n        }\n        _;\n    }\n\n    /// @dev Access control list using allowlist and denylist\n    /// @dev 1) if one address is in the denylist -> deny\n    /// @dev 2) else if address in the allowlist OR allowlist is empty (allows everyone)-> allow\n    /// @dev 3) else deny\n    /// @param _sender address to check\n    function hasAcl(address _sender) public view returns (bool) {\n        if (hasRole(DENYLIST, _sender)) {\n            return false;\n        } else if (allowlistSize == 0 || hasRole(ALLOWLIST, _sender)) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    // ========================= OnyDefaultAdmin =========================\n\n    /// @dev flag to pause execution of workers (if used with whenNotPaused modifier)\n    /// @param _paused true to pause, false to unpause\n    function setPaused(bool _paused) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (_paused) {\n            _pause();\n        } else {\n            _unpause();\n        }\n    }\n\n    // ========================= OnlyAdmin =========================\n\n    /// @param _priceFeed price feed address\n    function setPriceFeed(address _priceFeed) external onlyRole(ADMIN_ROLE) {\n        priceFeed = _priceFeed;\n        emit SetPriceFeed(_priceFeed);\n    }\n\n    /// @param _workerFeeLib worker fee lib address\n    function setWorkerFeeLib(address _workerFeeLib) external onlyRole(ADMIN_ROLE) {\n        workerFeeLib = _workerFeeLib;\n        emit SetWorkerLib(_workerFeeLib);\n    }\n\n    /// @param _multiplierBps default multiplier for worker fee\n    function setDefaultMultiplierBps(uint16 _multiplierBps) external onlyRole(ADMIN_ROLE) {\n        defaultMultiplierBps = _multiplierBps;\n        emit SetDefaultMultiplierBps(_multiplierBps);\n    }\n\n    /// @dev supports withdrawing fee from ULN301, ULN302 and more\n    /// @param _lib message lib address\n    /// @param _to address to withdraw fee to\n    /// @param _amount amount to withdraw\n    function withdrawFee(address _lib, address _to, uint256 _amount) external onlyRole(ADMIN_ROLE) {\n        if (!hasRole(MESSAGE_LIB_ROLE, _lib)) revert Worker_OnlyMessageLib();\n        ISendLib(_lib).withdrawFee(_to, _amount);\n        emit Withdraw(_lib, _to, _amount);\n    }\n\n    /// @dev supports withdrawing token from the contract\n    /// @param _token token address\n    /// @param _to address to withdraw token to\n    /// @param _amount amount to withdraw\n    function withdrawToken(address _token, address _to, uint256 _amount) external onlyRole(ADMIN_ROLE) {\n        // transfers native if _token is address(0x0)\n        Transfer.nativeOrToken(_token, _to, _amount);\n    }\n\n    function setSupportedOptionTypes(uint32 _eid, uint8[] calldata _optionTypes) external onlyRole(ADMIN_ROLE) {\n        supportedOptionTypes[_eid] = _optionTypes;\n    }\n\n    // ========================= View Functions =========================\n    function getSupportedOptionTypes(uint32 _eid) external view returns (uint8[] memory) {\n        return supportedOptionTypes[_eid];\n    }\n\n    // ========================= Internal Functions =========================\n\n    /// @dev overrides AccessControl to allow for counting of allowlistSize\n    /// @param _role role to grant\n    /// @param _account address to grant role to\n    function _grantRole(bytes32 _role, address _account) internal override {\n        if (_role == ALLOWLIST && !hasRole(_role, _account)) {\n            ++allowlistSize;\n        }\n        super._grantRole(_role, _account);\n    }\n\n    /// @dev overrides AccessControl to allow for counting of allowlistSize\n    /// @param _role role to revoke\n    /// @param _account address to revoke role from\n    function _revokeRole(bytes32 _role, address _account) internal override {\n        if (_role == ALLOWLIST && hasRole(_role, _account)) {\n            --allowlistSize;\n        }\n        super._revokeRole(_role, _account);\n    }\n\n    /// @dev overrides AccessControl to disable renouncing of roles\n    function renounceRole(bytes32 /*role*/, address /*account*/) public pure override {\n        revert Worker_RoleRenouncingDisabled();\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[47] private __gap;\n}\n"
    },
    "contracts/messagelib/contracts/Worker.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { Pausable } from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport { AccessControl } from \"@openzeppelin/contracts/access/AccessControl.sol\";\n\nimport { ISendLib } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ISendLib.sol\";\nimport { Transfer } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/Transfer.sol\";\n\nimport { IWorker } from \"./interfaces/IWorker.sol\";\n\nabstract contract Worker is AccessControl, Pausable, IWorker {\n    bytes32 internal constant MESSAGE_LIB_ROLE = keccak256(\"MESSAGE_LIB_ROLE\");\n    bytes32 internal constant ALLOWLIST = keccak256(\"ALLOWLIST\");\n    bytes32 internal constant DENYLIST = keccak256(\"DENYLIST\");\n    bytes32 internal constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n\n    address public workerFeeLib;\n\n    uint64 public allowlistSize;\n    uint16 public defaultMultiplierBps;\n    address public priceFeed;\n\n    mapping(uint32 eid => uint8[] optionTypes) internal supportedOptionTypes;\n\n    // ========================= Constructor =========================\n\n    /// @param _messageLibs array of message lib addresses that are granted the MESSAGE_LIB_ROLE\n    /// @param _priceFeed price feed address\n    /// @param _defaultMultiplierBps default multiplier for worker fee\n    /// @param _roleAdmin address that is granted the DEFAULT_ADMIN_ROLE (can grant and revoke all roles)\n    /// @param _admins array of admin addresses that are granted the ADMIN_ROLE\n    constructor(\n        address[] memory _messageLibs,\n        address _priceFeed,\n        uint16 _defaultMultiplierBps,\n        address _roleAdmin,\n        address[] memory _admins\n    ) {\n        defaultMultiplierBps = _defaultMultiplierBps;\n        priceFeed = _priceFeed;\n\n        if (_roleAdmin != address(0x0)) {\n            _grantRole(DEFAULT_ADMIN_ROLE, _roleAdmin); // _roleAdmin can grant and revoke all roles\n        }\n\n        for (uint256 i = 0; i < _messageLibs.length; ++i) {\n            _grantRole(MESSAGE_LIB_ROLE, _messageLibs[i]);\n        }\n\n        for (uint256 i = 0; i < _admins.length; ++i) {\n            _grantRole(ADMIN_ROLE, _admins[i]);\n        }\n    }\n\n    // ========================= Modifier =========================\n\n    modifier onlyAcl(address _sender) {\n        if (!hasAcl(_sender)) {\n            revert Worker_NotAllowed();\n        }\n        _;\n    }\n\n    /// @dev Access control list using allowlist and denylist\n    /// @dev 1) if one address is in the denylist -> deny\n    /// @dev 2) else if address in the allowlist OR allowlist is empty (allows everyone)-> allow\n    /// @dev 3) else deny\n    /// @param _sender address to check\n    function hasAcl(address _sender) public view returns (bool) {\n        if (hasRole(DENYLIST, _sender)) {\n            return false;\n        } else if (allowlistSize == 0 || hasRole(ALLOWLIST, _sender)) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    // ========================= OnyDefaultAdmin =========================\n\n    /// @dev flag to pause execution of workers (if used with whenNotPaused modifier)\n    /// @param _paused true to pause, false to unpause\n    function setPaused(bool _paused) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (_paused) {\n            _pause();\n        } else {\n            _unpause();\n        }\n    }\n\n    // ========================= OnlyAdmin =========================\n\n    /// @param _priceFeed price feed address\n    function setPriceFeed(address _priceFeed) external onlyRole(ADMIN_ROLE) {\n        priceFeed = _priceFeed;\n        emit SetPriceFeed(_priceFeed);\n    }\n\n    /// @param _workerFeeLib worker fee lib address\n    function setWorkerFeeLib(address _workerFeeLib) external onlyRole(ADMIN_ROLE) {\n        workerFeeLib = _workerFeeLib;\n        emit SetWorkerLib(_workerFeeLib);\n    }\n\n    /// @param _multiplierBps default multiplier for worker fee\n    function setDefaultMultiplierBps(uint16 _multiplierBps) external onlyRole(ADMIN_ROLE) {\n        defaultMultiplierBps = _multiplierBps;\n        emit SetDefaultMultiplierBps(_multiplierBps);\n    }\n\n    /// @dev supports withdrawing fee from ULN301, ULN302 and more\n    /// @param _lib message lib address\n    /// @param _to address to withdraw fee to\n    /// @param _amount amount to withdraw\n    function withdrawFee(address _lib, address _to, uint256 _amount) external onlyRole(ADMIN_ROLE) {\n        if (!hasRole(MESSAGE_LIB_ROLE, _lib)) revert Worker_OnlyMessageLib();\n        ISendLib(_lib).withdrawFee(_to, _amount);\n        emit Withdraw(_lib, _to, _amount);\n    }\n\n    /// @dev supports withdrawing token from the contract\n    /// @param _token token address\n    /// @param _to address to withdraw token to\n    /// @param _amount amount to withdraw\n    function withdrawToken(address _token, address _to, uint256 _amount) external onlyRole(ADMIN_ROLE) {\n        // transfers native if _token is address(0x0)\n        Transfer.nativeOrToken(_token, _to, _amount);\n    }\n\n    function setSupportedOptionTypes(uint32 _eid, uint8[] calldata _optionTypes) external onlyRole(ADMIN_ROLE) {\n        supportedOptionTypes[_eid] = _optionTypes;\n    }\n\n    // ========================= View Functions =========================\n    function getSupportedOptionTypes(uint32 _eid) external view returns (uint8[] memory) {\n        return supportedOptionTypes[_eid];\n    }\n\n    // ========================= Internal Functions =========================\n\n    /// @dev overrides AccessControl to allow for counting of allowlistSize\n    /// @param _role role to grant\n    /// @param _account address to grant role to\n    function _grantRole(bytes32 _role, address _account) internal override {\n        if (_role == ALLOWLIST && !hasRole(_role, _account)) {\n            ++allowlistSize;\n        }\n        super._grantRole(_role, _account);\n    }\n\n    /// @dev overrides AccessControl to allow for counting of allowlistSize\n    /// @param _role role to revoke\n    /// @param _account address to revoke role from\n    function _revokeRole(bytes32 _role, address _account) internal override {\n        if (_role == ALLOWLIST && hasRole(_role, _account)) {\n            --allowlistSize;\n        }\n        super._revokeRole(_role, _account);\n    }\n\n    /// @dev overrides AccessControl to disable renouncing of roles\n    function renounceRole(bytes32 /*role*/, address /*account*/) public pure override {\n        revert Worker_RoleRenouncingDisabled();\n    }\n}\n"
    },
    "contracts/protocol/contracts/EndpointV2.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { MessagingFee, MessagingParams, MessagingReceipt, Origin, ILayerZeroEndpointV2 } from \"./interfaces/ILayerZeroEndpointV2.sol\";\nimport { ISendLib, Packet } from \"./interfaces/ISendLib.sol\";\nimport { ILayerZeroReceiver } from \"./interfaces/ILayerZeroReceiver.sol\";\nimport { Errors } from \"./libs/Errors.sol\";\nimport { GUID } from \"./libs/GUID.sol\";\nimport { Transfer } from \"./libs/Transfer.sol\";\nimport { MessagingChannel } from \"./MessagingChannel.sol\";\nimport { MessagingComposer } from \"./MessagingComposer.sol\";\nimport { MessageLibManager } from \"./MessageLibManager.sol\";\nimport { MessagingContext } from \"./MessagingContext.sol\";\n\n// LayerZero EndpointV2 is fully backward compatible with LayerZero Endpoint(V1), but it also supports additional\n// features that Endpoint(V1) does not support now and may not in the future. We have also changed some terminology\n// to clarify pre-existing language that might have been confusing.\n//\n// The following is a list of terminology changes:\n//     -chainId -> eid\n//          - Rationale: chainId was a term we initially used to describe an endpoint on a specific chain. Since\n//          LayerZero supports non-EVMs we could not map the classic EVM chainIds to the LayerZero chainIds, making it\n//          confusing for developers. With the addition of EndpointV2 and its backward compatible nature, we would have\n//          two chainIds per chain that has Endpoint(V1), further confusing developers. We have decided to change the\n//          name to Endpoint Id, or eid, for simplicity and clarity.\n//     -adapterParams -> options\n//     -userApplication -> oapp. Omnichain Application\n//     -srcAddress -> sender\n//     -dstAddress -> receiver\n//          - Rationale: The sender/receiver on EVM is the address. However, on non-EVM chains, the sender/receiver could\n//          represented as a public key, or some other identifier. The term sender/receiver is more generic\n//     -payload -> message.\n//          - Rationale: The term payload is used in the context of a packet, which is a combination of the message and GUID\ncontract EndpointV2 is ILayerZeroEndpointV2, MessagingChannel, MessageLibManager, MessagingComposer, MessagingContext {\n    address public lzToken;\n\n    mapping(address oapp => address delegate) public delegates;\n\n    /// @param _eid the unique Endpoint Id for this deploy that all other Endpoints can use to send to it\n    constructor(uint32 _eid, address _owner) MessagingChannel(_eid) {\n        _transferOwnership(_owner);\n    }\n\n    /// @dev MESSAGING STEP 0\n    /// @notice This view function gives the application built on top of LayerZero the ability to requests a quote\n    /// with the same parameters as they would to send their message. Since the quotes are given on chain there is a\n    /// race condition in which the prices could change between the time the user gets their quote and the time they\n    /// submit their message. If the price moves up and the user doesn't send enough funds the transaction will revert,\n    /// if the price goes down the _refundAddress provided by the app will be refunded the difference.\n    /// @param _params the messaging parameters\n    /// @param _sender the sender of the message\n    function quote(MessagingParams calldata _params, address _sender) external view returns (MessagingFee memory) {\n        // lzToken must be set to support payInLzToken\n        if (_params.payInLzToken && lzToken == address(0x0)) revert Errors.LZ_LzTokenUnavailable();\n\n        // get the correct outbound nonce\n        uint64 nonce = outboundNonce[_sender][_params.dstEid][_params.receiver] + 1;\n\n        // construct the packet with a GUID\n        Packet memory packet = Packet({\n            nonce: nonce,\n            srcEid: eid,\n            sender: _sender,\n            dstEid: _params.dstEid,\n            receiver: _params.receiver,\n            guid: GUID.generate(nonce, eid, _sender, _params.dstEid, _params.receiver),\n            message: _params.message\n        });\n\n        // get the send library by sender and dst eid\n        // use _ to avoid variable shadowing\n        address _sendLibrary = getSendLibrary(_sender, _params.dstEid);\n\n        return ISendLib(_sendLibrary).quote(packet, _params.options, _params.payInLzToken);\n    }\n\n    /// @dev MESSAGING STEP 1 - OApp need to transfer the fees to the endpoint before sending the message\n    /// @param _params the messaging parameters\n    /// @param _refundAddress the address to refund both the native and lzToken\n    function send(\n        MessagingParams calldata _params,\n        address _refundAddress\n    ) external payable sendContext(_params.dstEid, msg.sender) returns (MessagingReceipt memory) {\n        if (_params.payInLzToken && lzToken == address(0x0)) revert Errors.LZ_LzTokenUnavailable();\n\n        // send message\n        (MessagingReceipt memory receipt, address _sendLibrary) = _send(msg.sender, _params);\n\n        // OApp can simulate with 0 native value it will fail with error including the required fee, which can be provided in the actual call\n        // this trick can be used to avoid the need to write the quote() function\n        // however, without the quote view function it will be hard to compose an oapp on chain\n        uint256 suppliedNative = _suppliedNative();\n        uint256 suppliedLzToken = _suppliedLzToken(_params.payInLzToken);\n        _assertMessagingFee(receipt.fee, suppliedNative, suppliedLzToken);\n\n        // handle lz token fees\n        _payToken(lzToken, receipt.fee.lzTokenFee, suppliedLzToken, _sendLibrary, _refundAddress);\n\n        // handle native fees\n        _payNative(receipt.fee.nativeFee, suppliedNative, _sendLibrary, _refundAddress);\n\n        return receipt;\n    }\n\n    /// @dev internal function for sending the messages used by all external send methods\n    /// @param _sender the address of the application sending the message to the destination chain\n    /// @param _params the messaging parameters\n    function _send(\n        address _sender,\n        MessagingParams calldata _params\n    ) internal returns (MessagingReceipt memory, address) {\n        // get the correct outbound nonce\n        uint64 latestNonce = _outbound(_sender, _params.dstEid, _params.receiver);\n\n        // construct the packet with a GUID\n        Packet memory packet = Packet({\n            nonce: latestNonce,\n            srcEid: eid,\n            sender: _sender,\n            dstEid: _params.dstEid,\n            receiver: _params.receiver,\n            guid: GUID.generate(latestNonce, eid, _sender, _params.dstEid, _params.receiver),\n            message: _params.message\n        });\n\n        // get the send library by sender and dst eid\n        address _sendLibrary = getSendLibrary(_sender, _params.dstEid);\n\n        // messageLib always returns encodedPacket with guid\n        (MessagingFee memory fee, bytes memory encodedPacket) = ISendLib(_sendLibrary).send(\n            packet,\n            _params.options,\n            _params.payInLzToken\n        );\n\n        // Emit packet information for DVNs, Executors, and any other offchain infrastructure to only listen\n        // for this one event to perform their actions.\n        emit PacketSent(encodedPacket, _params.options, _sendLibrary);\n\n        return (MessagingReceipt(packet.guid, latestNonce, fee), _sendLibrary);\n    }\n\n    /// @dev MESSAGING STEP 2 - on the destination chain\n    /// @dev configured receive library verifies a message\n    /// @param _origin a struct holding the srcEid, nonce, and sender of the message\n    /// @param _receiver the receiver of the message\n    /// @param _payloadHash the payload hash of the message\n    function verify(Origin calldata _origin, address _receiver, bytes32 _payloadHash) external {\n        if (!isValidReceiveLibrary(_receiver, _origin.srcEid, msg.sender)) revert Errors.LZ_InvalidReceiveLibrary();\n\n        uint64 lazyNonce = lazyInboundNonce[_receiver][_origin.srcEid][_origin.sender];\n        if (!_initializable(_origin, _receiver, lazyNonce)) revert Errors.LZ_PathNotInitializable();\n        if (!_verifiable(_origin, _receiver, lazyNonce)) revert Errors.LZ_PathNotVerifiable();\n\n        // insert the message into the message channel\n        _inbound(_receiver, _origin.srcEid, _origin.sender, _origin.nonce, _payloadHash);\n        emit PacketVerified(_origin, _receiver, _payloadHash);\n    }\n\n    /// @dev MESSAGING STEP 3 - the last step\n    /// @dev execute a verified message to the designated receiver\n    /// @dev the execution provides the execution context (caller, extraData) to the receiver. the receiver can optionally assert the caller and validate the untrusted extraData\n    /// @dev cant reentrant because the payload is cleared before execution\n    /// @param _origin the origin of the message\n    /// @param _receiver the receiver of the message\n    /// @param _guid the guid of the message\n    /// @param _message the message\n    /// @param _extraData the extra data provided by the executor. this data is untrusted and should be validated.\n    function lzReceive(\n        Origin calldata _origin,\n        address _receiver,\n        bytes32 _guid,\n        bytes calldata _message,\n        bytes calldata _extraData\n    ) external payable {\n        // clear the payload first to prevent reentrancy, and then execute the message\n        _clearPayload(_receiver, _origin.srcEid, _origin.sender, _origin.nonce, abi.encodePacked(_guid, _message));\n        ILayerZeroReceiver(_receiver).lzReceive{ value: msg.value }(_origin, _guid, _message, msg.sender, _extraData);\n        emit PacketDelivered(_origin, _receiver);\n    }\n\n    /// @param _origin the origin of the message\n    /// @param _receiver the receiver of the message\n    /// @param _guid the guid of the message\n    /// @param _message the message\n    /// @param _extraData the extra data provided by the executor.\n    /// @param _reason the reason for failure\n    function lzReceiveAlert(\n        Origin calldata _origin,\n        address _receiver,\n        bytes32 _guid,\n        uint256 _gas,\n        uint256 _value,\n        bytes calldata _message,\n        bytes calldata _extraData,\n        bytes calldata _reason\n    ) external {\n        emit LzReceiveAlert(_receiver, msg.sender, _origin, _guid, _gas, _value, _message, _extraData, _reason);\n    }\n\n    /// @dev Oapp uses this interface to clear a message.\n    /// @dev this is a PULL mode versus the PUSH mode of lzReceive\n    /// @dev the cleared message can be ignored by the app (effectively burnt)\n    /// @dev authenticated by oapp\n    /// @param _origin the origin of the message\n    /// @param _guid the guid of the message\n    /// @param _message the message\n    function clear(address _oapp, Origin calldata _origin, bytes32 _guid, bytes calldata _message) external {\n        _assertAuthorized(_oapp);\n\n        bytes memory payload = abi.encodePacked(_guid, _message);\n        _clearPayload(_oapp, _origin.srcEid, _origin.sender, _origin.nonce, payload);\n        emit PacketDelivered(_origin, _oapp);\n    }\n\n    /// @dev allows reconfiguration to recover from wrong configurations\n    /// @dev users should never approve the EndpointV2 contract to spend their non-layerzero tokens\n    /// @dev override this function if the endpoint is charging ERC20 tokens as native\n    /// @dev only owner\n    /// @param _lzToken the new layer zero token address\n    function setLzToken(address _lzToken) public virtual onlyOwner {\n        lzToken = _lzToken;\n        emit LzTokenSet(_lzToken);\n    }\n\n    /// @dev recover the token sent to this contract by mistake\n    /// @dev only owner\n    /// @param _token the token to recover. if 0x0 then it is native token\n    /// @param _to the address to send the token to\n    /// @param _amount the amount to send\n    function recoverToken(address _token, address _to, uint256 _amount) external onlyOwner {\n        Transfer.nativeOrToken(_token, _to, _amount);\n    }\n\n    /// @dev handling token payments on endpoint. the sender must approve the endpoint to spend the token\n    /// @dev internal function\n    /// @param _token the token to pay\n    /// @param _required the amount required\n    /// @param _supplied the amount supplied\n    /// @param _receiver the receiver of the token\n    function _payToken(\n        address _token,\n        uint256 _required,\n        uint256 _supplied,\n        address _receiver,\n        address _refundAddress\n    ) internal {\n        if (_required > 0) {\n            Transfer.token(_token, _receiver, _required);\n        }\n        if (_required < _supplied) {\n            unchecked {\n                // refund the excess\n                Transfer.token(_token, _refundAddress, _supplied - _required);\n            }\n        }\n    }\n\n    /// @dev handling native token payments on endpoint\n    /// @dev override this if the endpoint is charging ERC20 tokens as native\n    /// @dev internal function\n    /// @param _required the amount required\n    /// @param _supplied the amount supplied\n    /// @param _receiver the receiver of the native token\n    /// @param _refundAddress the address to refund the excess to\n    function _payNative(\n        uint256 _required,\n        uint256 _supplied,\n        address _receiver,\n        address _refundAddress\n    ) internal virtual {\n        if (_required > 0) {\n            Transfer.native(_receiver, _required);\n        }\n        if (_required < _supplied) {\n            unchecked {\n                // refund the excess\n                Transfer.native(_refundAddress, _supplied - _required);\n            }\n        }\n    }\n\n    /// @dev get the balance of the lzToken as the supplied lzToken fee if payInLzToken is true\n    function _suppliedLzToken(bool _payInLzToken) internal view returns (uint256 supplied) {\n        if (_payInLzToken) {\n            supplied = IERC20(lzToken).balanceOf(address(this));\n\n            // if payInLzToken is true, the supplied fee must be greater than 0 to prevent a race condition\n            // in which an oapp sending a message with lz token and the lz token is set to a new token between the tx\n            // being sent and the tx being mined. if the required lz token fee is 0 and the old lz token would be\n            // locked in the contract instead of being refunded\n            if (supplied == 0) revert Errors.LZ_ZeroLzTokenFee();\n        }\n    }\n\n    /// @dev override this if the endpoint is charging ERC20 tokens as native\n    function _suppliedNative() internal view virtual returns (uint256) {\n        return msg.value;\n    }\n\n    /// @dev Assert the required fees and the supplied fees are enough\n    function _assertMessagingFee(\n        MessagingFee memory _required,\n        uint256 _suppliedNativeFee,\n        uint256 _suppliedLzTokenFee\n    ) internal pure {\n        if (_required.nativeFee > _suppliedNativeFee || _required.lzTokenFee > _suppliedLzTokenFee) {\n            revert Errors.LZ_InsufficientFee(\n                _required.nativeFee,\n                _suppliedNativeFee,\n                _required.lzTokenFee,\n                _suppliedLzTokenFee\n            );\n        }\n    }\n\n    /// @dev override this if the endpoint is charging ERC20 tokens as native\n    /// @return 0x0 if using native. otherwise the address of the native ERC20 token\n    function nativeToken() external view virtual returns (address) {\n        return address(0x0);\n    }\n\n    /// @notice delegate is authorized by the oapp to configure anything in layerzero\n    function setDelegate(address _delegate) external {\n        delegates[msg.sender] = _delegate;\n        emit DelegateSet(msg.sender, _delegate);\n    }\n\n    // ========================= Internal =========================\n    function _initializable(\n        Origin calldata _origin,\n        address _receiver,\n        uint64 _lazyInboundNonce\n    ) internal view returns (bool) {\n        return\n            _lazyInboundNonce > 0 || // allowInitializePath already checked\n            ILayerZeroReceiver(_receiver).allowInitializePath(_origin);\n    }\n\n    /// @dev bytes(0) payloadHash can never be submitted\n    function _verifiable(\n        Origin calldata _origin,\n        address _receiver,\n        uint64 _lazyInboundNonce\n    ) internal view returns (bool) {\n        return\n            _origin.nonce > _lazyInboundNonce || // either initializing an empty slot or reverifying\n            inboundPayloadHash[_receiver][_origin.srcEid][_origin.sender][_origin.nonce] != EMPTY_PAYLOAD_HASH; // only allow reverifying if it hasn't been executed\n    }\n\n    /// @dev assert the caller to either be the oapp or the delegate\n    function _assertAuthorized(address _oapp) internal view override(MessagingChannel, MessageLibManager) {\n        if (msg.sender != _oapp && msg.sender != delegates[_oapp]) revert Errors.LZ_Unauthorized();\n    }\n\n    // ========================= VIEW FUNCTIONS FOR OFFCHAIN ONLY =========================\n    // Not involved in any state transition function.\n    // ====================================================================================\n    function initializable(Origin calldata _origin, address _receiver) external view returns (bool) {\n        return _initializable(_origin, _receiver, lazyInboundNonce[_receiver][_origin.srcEid][_origin.sender]);\n    }\n\n    function verifiable(Origin calldata _origin, address _receiver) external view returns (bool) {\n        return _verifiable(_origin, _receiver, lazyInboundNonce[_receiver][_origin.srcEid][_origin.sender]);\n    }\n}\n"
    },
    "contracts/protocol/contracts/EndpointV2Alt.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { EndpointV2 } from \"./EndpointV2.sol\";\nimport { Errors } from \"./libs/Errors.sol\";\n\n/// @notice this is the endpoint contract for layerzero v2 deployed on chains using ERC20 as native tokens\ncontract EndpointV2Alt is EndpointV2 {\n    error LZ_OnlyAltToken();\n\n    /// @dev the altFeeToken is used for fees when the native token has no value\n    /// @dev it is immutable for gas saving. only 1 endpoint for such chains\n    address internal immutable nativeErc20;\n\n    constructor(uint32 _eid, address _owner, address _altToken) EndpointV2(_eid, _owner) {\n        nativeErc20 = _altToken;\n    }\n\n    /// @dev handling native token payments on endpoint\n    /// @dev internal function\n    /// @param _required the amount required\n    /// @param _supplied the amount supplied\n    /// @param _receiver the receiver of the native token\n    /// @param _refundAddress the address to refund the excess to\n    function _payNative(\n        uint256 _required,\n        uint256 _supplied,\n        address _receiver,\n        address _refundAddress\n    ) internal override {\n        if (msg.value > 0) revert LZ_OnlyAltToken();\n        _payToken(nativeErc20, _required, _supplied, _receiver, _refundAddress);\n    }\n\n    /// @dev return the balance of the native token\n    function _suppliedNative() internal view override returns (uint256) {\n        return IERC20(nativeErc20).balanceOf(address(this));\n    }\n\n    /// @dev check if lzToken is set to the same address\n    function setLzToken(address _lzToken) public override onlyOwner {\n        if (_lzToken == nativeErc20) revert Errors.LZ_InvalidArgument();\n        super.setLzToken(_lzToken);\n    }\n\n    function nativeToken() external view override returns (address) {\n        return nativeErc20;\n    }\n}\n"
    },
    "contracts/protocol/contracts/EndpointV2View.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { Proxied } from \"hardhat-deploy/solc_0.8/proxy/Proxied.sol\";\nimport \"./EndpointV2ViewUpgradeable.sol\";\n\ncontract EndpointV2View is EndpointV2ViewUpgradeable, Proxied {\n    function initialize(address _endpoint) external proxied initializer {\n        __EndpointV2View_init(_endpoint);\n    }\n}\n"
    },
    "contracts/protocol/contracts/EndpointV2ViewUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport \"./interfaces/ILayerZeroEndpointV2.sol\";\n\nenum ExecutionState {\n    NotExecutable, // executor: waits for PayloadVerified event and starts polling for executable\n    VerifiedButNotExecutable, // executor: starts active polling for executable\n    Executable,\n    Executed\n}\n\ncontract EndpointV2ViewUpgradeable is Initializable {\n    bytes32 public constant EMPTY_PAYLOAD_HASH = bytes32(0);\n    bytes32 public constant NIL_PAYLOAD_HASH = bytes32(type(uint256).max);\n\n    ILayerZeroEndpointV2 public endpoint;\n\n    function __EndpointV2View_init(address _endpoint) internal onlyInitializing {\n        __EndpointV2View_init_unchained(_endpoint);\n    }\n\n    function __EndpointV2View_init_unchained(address _endpoint) internal onlyInitializing {\n        endpoint = ILayerZeroEndpointV2(_endpoint);\n    }\n\n    function initializable(Origin memory _origin, address _receiver) public view returns (bool) {\n        try endpoint.initializable(_origin, _receiver) returns (bool _initializable) {\n            return _initializable;\n        } catch {\n            return false;\n        }\n    }\n\n    /// @dev check if a message is verifiable.\n    function verifiable(\n        Origin memory _origin,\n        address _receiver,\n        address _receiveLib,\n        bytes32 _payloadHash\n    ) public view returns (bool) {\n        if (!endpoint.isValidReceiveLibrary(_receiver, _origin.srcEid, _receiveLib)) return false;\n\n        if (!endpoint.verifiable(_origin, _receiver)) return false;\n\n        // checked in _inbound for verify\n        if (_payloadHash == EMPTY_PAYLOAD_HASH) return false;\n\n        return true;\n    }\n\n    /// @dev check if a message is executable.\n    /// @return ExecutionState of Executed, Executable, or NotExecutable\n    function executable(Origin memory _origin, address _receiver) public view returns (ExecutionState) {\n        bytes32 payloadHash = endpoint.inboundPayloadHash(_receiver, _origin.srcEid, _origin.sender, _origin.nonce);\n\n        // executed if the payload hash has been cleared and the nonce is less than or equal to lazyInboundNonce\n        if (\n            payloadHash == EMPTY_PAYLOAD_HASH &&\n            _origin.nonce <= endpoint.lazyInboundNonce(_receiver, _origin.srcEid, _origin.sender)\n        ) {\n            return ExecutionState.Executed;\n        }\n\n        // executable if nonce has not been executed and has not been nilified and nonce is less than or equal to inboundNonce\n        if (\n            payloadHash != NIL_PAYLOAD_HASH &&\n            _origin.nonce <= endpoint.inboundNonce(_receiver, _origin.srcEid, _origin.sender)\n        ) {\n            return ExecutionState.Executable;\n        }\n\n        // only start active executable polling if payload hash is not empty nor nil\n        if (payloadHash != EMPTY_PAYLOAD_HASH && payloadHash != NIL_PAYLOAD_HASH) {\n            return ExecutionState.VerifiedButNotExecutable;\n        }\n\n        // return NotExecutable as a catch-all\n        return ExecutionState.NotExecutable;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/protocol/contracts/interfaces/ILayerZeroComposer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\n/**\n * @title ILayerZeroComposer\n */\ninterface ILayerZeroComposer {\n    /**\n     * @notice Composes a LayerZero message from an OApp.\n     * @dev To ensure non-reentrancy, implementers of this interface MUST assert msg.sender is the corresponding EndpointV2 contract (i.e., onlyEndpointV2).\n     * @param _from The address initiating the composition, typically the OApp where the lzReceive was called.\n     * @param _guid The unique identifier for the corresponding LayerZero src/dst tx.\n     * @param _message The composed message payload in bytes. NOT necessarily the same payload passed via lzReceive.\n     * @param _executor The address of the executor for the composed message.\n     * @param _extraData Additional arbitrary data in bytes passed by the entity who executes the lzCompose.\n     */\n    function lzCompose(\n        address _from,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor,\n        bytes calldata _extraData\n    ) external payable;\n}\n"
    },
    "contracts/protocol/contracts/interfaces/ILayerZeroEndpointV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport { IMessageLibManager } from \"./IMessageLibManager.sol\";\nimport { IMessagingComposer } from \"./IMessagingComposer.sol\";\nimport { IMessagingChannel } from \"./IMessagingChannel.sol\";\nimport { IMessagingContext } from \"./IMessagingContext.sol\";\n\nstruct MessagingParams {\n    uint32 dstEid;\n    bytes32 receiver;\n    bytes message;\n    bytes options;\n    bool payInLzToken;\n}\n\nstruct MessagingReceipt {\n    bytes32 guid;\n    uint64 nonce;\n    MessagingFee fee;\n}\n\nstruct MessagingFee {\n    uint256 nativeFee;\n    uint256 lzTokenFee;\n}\n\nstruct Origin {\n    uint32 srcEid;\n    bytes32 sender;\n    uint64 nonce;\n}\n\ninterface ILayerZeroEndpointV2 is IMessageLibManager, IMessagingComposer, IMessagingChannel, IMessagingContext {\n    event PacketSent(bytes encodedPayload, bytes options, address sendLibrary);\n\n    event PacketVerified(Origin origin, address receiver, bytes32 payloadHash);\n\n    event PacketDelivered(Origin origin, address receiver);\n\n    event LzReceiveAlert(\n        address indexed receiver,\n        address indexed executor,\n        Origin origin,\n        bytes32 guid,\n        uint256 gas,\n        uint256 value,\n        bytes message,\n        bytes extraData,\n        bytes reason\n    );\n\n    event LzTokenSet(address token);\n\n    event DelegateSet(address sender, address delegate);\n\n    function quote(MessagingParams calldata _params, address _sender) external view returns (MessagingFee memory);\n\n    function send(\n        MessagingParams calldata _params,\n        address _refundAddress\n    ) external payable returns (MessagingReceipt memory);\n\n    function verify(Origin calldata _origin, address _receiver, bytes32 _payloadHash) external;\n\n    function verifiable(Origin calldata _origin, address _receiver) external view returns (bool);\n\n    function initializable(Origin calldata _origin, address _receiver) external view returns (bool);\n\n    function lzReceive(\n        Origin calldata _origin,\n        address _receiver,\n        bytes32 _guid,\n        bytes calldata _message,\n        bytes calldata _extraData\n    ) external payable;\n\n    // oapp can burn messages partially by calling this function with its own business logic if messages are verified in order\n    function clear(address _oapp, Origin calldata _origin, bytes32 _guid, bytes calldata _message) external;\n\n    function setLzToken(address _lzToken) external;\n\n    function lzToken() external view returns (address);\n\n    function nativeToken() external view returns (address);\n\n    function setDelegate(address _delegate) external;\n}\n"
    },
    "contracts/protocol/contracts/interfaces/ILayerZeroReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport { Origin } from \"./ILayerZeroEndpointV2.sol\";\n\ninterface ILayerZeroReceiver {\n    function allowInitializePath(Origin calldata _origin) external view returns (bool);\n\n    function nextNonce(uint32 _eid, bytes32 _sender) external view returns (uint64);\n\n    function lzReceive(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor,\n        bytes calldata _extraData\n    ) external payable;\n}\n"
    },
    "contracts/protocol/contracts/interfaces/IMessageLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport { SetConfigParam } from \"./IMessageLibManager.sol\";\n\nenum MessageLibType {\n    Send,\n    Receive,\n    SendAndReceive\n}\n\ninterface IMessageLib is IERC165 {\n    function setConfig(address _oapp, SetConfigParam[] calldata _config) external;\n\n    function getConfig(uint32 _eid, address _oapp, uint32 _configType) external view returns (bytes memory config);\n\n    function isSupportedEid(uint32 _eid) external view returns (bool);\n\n    // message libs of same major version are compatible\n    function version() external view returns (uint64 major, uint8 minor, uint8 endpointVersion);\n\n    function messageLibType() external view returns (MessageLibType);\n}\n"
    },
    "contracts/protocol/contracts/interfaces/IMessageLibManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nstruct SetConfigParam {\n    uint32 eid;\n    uint32 configType;\n    bytes config;\n}\n\ninterface IMessageLibManager {\n    struct Timeout {\n        address lib;\n        uint256 expiry;\n    }\n\n    event LibraryRegistered(address newLib);\n    event DefaultSendLibrarySet(uint32 eid, address newLib);\n    event DefaultReceiveLibrarySet(uint32 eid, address newLib);\n    event DefaultReceiveLibraryTimeoutSet(uint32 eid, address oldLib, uint256 expiry);\n    event SendLibrarySet(address sender, uint32 eid, address newLib);\n    event ReceiveLibrarySet(address receiver, uint32 eid, address newLib);\n    event ReceiveLibraryTimeoutSet(address receiver, uint32 eid, address oldLib, uint256 timeout);\n\n    function registerLibrary(address _lib) external;\n\n    function isRegisteredLibrary(address _lib) external view returns (bool);\n\n    function getRegisteredLibraries() external view returns (address[] memory);\n\n    function setDefaultSendLibrary(uint32 _eid, address _newLib) external;\n\n    function defaultSendLibrary(uint32 _eid) external view returns (address);\n\n    function setDefaultReceiveLibrary(uint32 _eid, address _newLib, uint256 _gracePeriod) external;\n\n    function defaultReceiveLibrary(uint32 _eid) external view returns (address);\n\n    function setDefaultReceiveLibraryTimeout(uint32 _eid, address _lib, uint256 _expiry) external;\n\n    function defaultReceiveLibraryTimeout(uint32 _eid) external view returns (address lib, uint256 expiry);\n\n    function isSupportedEid(uint32 _eid) external view returns (bool);\n\n    function isValidReceiveLibrary(address _receiver, uint32 _eid, address _lib) external view returns (bool);\n\n    /// ------------------- OApp interfaces -------------------\n    function setSendLibrary(address _oapp, uint32 _eid, address _newLib) external;\n\n    function getSendLibrary(address _sender, uint32 _eid) external view returns (address lib);\n\n    function isDefaultSendLibrary(address _sender, uint32 _eid) external view returns (bool);\n\n    function setReceiveLibrary(address _oapp, uint32 _eid, address _newLib, uint256 _gracePeriod) external;\n\n    function getReceiveLibrary(address _receiver, uint32 _eid) external view returns (address lib, bool isDefault);\n\n    function setReceiveLibraryTimeout(address _oapp, uint32 _eid, address _lib, uint256 _expiry) external;\n\n    function receiveLibraryTimeout(address _receiver, uint32 _eid) external view returns (address lib, uint256 expiry);\n\n    function setConfig(address _oapp, address _lib, SetConfigParam[] calldata _params) external;\n\n    function getConfig(\n        address _oapp,\n        address _lib,\n        uint32 _eid,\n        uint32 _configType\n    ) external view returns (bytes memory config);\n}\n"
    },
    "contracts/protocol/contracts/interfaces/IMessagingChannel.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface IMessagingChannel {\n    event InboundNonceSkipped(uint32 srcEid, bytes32 sender, address receiver, uint64 nonce);\n    event PacketNilified(uint32 srcEid, bytes32 sender, address receiver, uint64 nonce, bytes32 payloadHash);\n    event PacketBurnt(uint32 srcEid, bytes32 sender, address receiver, uint64 nonce, bytes32 payloadHash);\n\n    function eid() external view returns (uint32);\n\n    // this is an emergency function if a message cannot be verified for some reasons\n    // required to provide _nextNonce to avoid race condition\n    function skip(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce) external;\n\n    function nilify(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce, bytes32 _payloadHash) external;\n\n    function burn(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce, bytes32 _payloadHash) external;\n\n    function nextGuid(address _sender, uint32 _dstEid, bytes32 _receiver) external view returns (bytes32);\n\n    function inboundNonce(address _receiver, uint32 _srcEid, bytes32 _sender) external view returns (uint64);\n\n    function outboundNonce(address _sender, uint32 _dstEid, bytes32 _receiver) external view returns (uint64);\n\n    function inboundPayloadHash(\n        address _receiver,\n        uint32 _srcEid,\n        bytes32 _sender,\n        uint64 _nonce\n    ) external view returns (bytes32);\n\n    function lazyInboundNonce(address _receiver, uint32 _srcEid, bytes32 _sender) external view returns (uint64);\n}\n"
    },
    "contracts/protocol/contracts/interfaces/IMessagingComposer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface IMessagingComposer {\n    event ComposeSent(address from, address to, bytes32 guid, uint16 index, bytes message);\n    event ComposeDelivered(address from, address to, bytes32 guid, uint16 index);\n    event LzComposeAlert(\n        address indexed from,\n        address indexed to,\n        address indexed executor,\n        bytes32 guid,\n        uint16 index,\n        uint256 gas,\n        uint256 value,\n        bytes message,\n        bytes extraData,\n        bytes reason\n    );\n\n    function composeQueue(\n        address _from,\n        address _to,\n        bytes32 _guid,\n        uint16 _index\n    ) external view returns (bytes32 messageHash);\n\n    function sendCompose(address _to, bytes32 _guid, uint16 _index, bytes calldata _message) external;\n\n    function lzCompose(\n        address _from,\n        address _to,\n        bytes32 _guid,\n        uint16 _index,\n        bytes calldata _message,\n        bytes calldata _extraData\n    ) external payable;\n}\n"
    },
    "contracts/protocol/contracts/interfaces/IMessagingContext.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface IMessagingContext {\n    function isSendingMessage() external view returns (bool);\n\n    function getSendContext() external view returns (uint32 dstEid, address sender);\n}\n"
    },
    "contracts/protocol/contracts/interfaces/ISendLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport { MessagingFee } from \"./ILayerZeroEndpointV2.sol\";\nimport { IMessageLib } from \"./IMessageLib.sol\";\n\nstruct Packet {\n    uint64 nonce;\n    uint32 srcEid;\n    address sender;\n    uint32 dstEid;\n    bytes32 receiver;\n    bytes32 guid;\n    bytes message;\n}\n\ninterface ISendLib is IMessageLib {\n    function send(\n        Packet calldata _packet,\n        bytes calldata _options,\n        bool _payInLzToken\n    ) external returns (MessagingFee memory, bytes memory encodedPacket);\n\n    function quote(\n        Packet calldata _packet,\n        bytes calldata _options,\n        bool _payInLzToken\n    ) external view returns (MessagingFee memory);\n\n    function setTreasury(address _treasury) external;\n\n    function withdrawFee(address _to, uint256 _amount) external;\n\n    function withdrawLzTokenFee(address _lzToken, address _to, uint256 _amount) external;\n}\n"
    },
    "contracts/protocol/contracts/libs/AddressCast.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nlibrary AddressCast {\n    error AddressCast_InvalidSizeForAddress();\n    error AddressCast_InvalidAddress();\n\n    function toBytes32(bytes calldata _addressBytes) internal pure returns (bytes32 result) {\n        if (_addressBytes.length > 32) revert AddressCast_InvalidAddress();\n        result = bytes32(_addressBytes);\n        unchecked {\n            uint256 offset = 32 - _addressBytes.length;\n            result = result >> (offset * 8);\n        }\n    }\n\n    function toBytes32(address _address) internal pure returns (bytes32 result) {\n        result = bytes32(uint256(uint160(_address)));\n    }\n\n    function toBytes(bytes32 _addressBytes32, uint256 _size) internal pure returns (bytes memory result) {\n        if (_size == 0 || _size > 32) revert AddressCast_InvalidSizeForAddress();\n        result = new bytes(_size);\n        unchecked {\n            uint256 offset = 256 - _size * 8;\n            assembly {\n                mstore(add(result, 32), shl(offset, _addressBytes32))\n            }\n        }\n    }\n\n    function toAddress(bytes32 _addressBytes32) internal pure returns (address result) {\n        result = address(uint160(uint256(_addressBytes32)));\n    }\n\n    function toAddress(bytes calldata _addressBytes) internal pure returns (address result) {\n        if (_addressBytes.length != 20) revert AddressCast_InvalidAddress();\n        result = address(bytes20(_addressBytes));\n    }\n}\n"
    },
    "contracts/protocol/contracts/libs/CalldataBytesLib.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nlibrary CalldataBytesLib {\n    function toU8(bytes calldata _bytes, uint256 _start) internal pure returns (uint8) {\n        return uint8(_bytes[_start]);\n    }\n\n    function toU16(bytes calldata _bytes, uint256 _start) internal pure returns (uint16) {\n        unchecked {\n            uint256 end = _start + 2;\n            return uint16(bytes2(_bytes[_start:end]));\n        }\n    }\n\n    function toU32(bytes calldata _bytes, uint256 _start) internal pure returns (uint32) {\n        unchecked {\n            uint256 end = _start + 4;\n            return uint32(bytes4(_bytes[_start:end]));\n        }\n    }\n\n    function toU64(bytes calldata _bytes, uint256 _start) internal pure returns (uint64) {\n        unchecked {\n            uint256 end = _start + 8;\n            return uint64(bytes8(_bytes[_start:end]));\n        }\n    }\n\n    function toU128(bytes calldata _bytes, uint256 _start) internal pure returns (uint128) {\n        unchecked {\n            uint256 end = _start + 16;\n            return uint128(bytes16(_bytes[_start:end]));\n        }\n    }\n\n    function toU256(bytes calldata _bytes, uint256 _start) internal pure returns (uint256) {\n        unchecked {\n            uint256 end = _start + 32;\n            return uint256(bytes32(_bytes[_start:end]));\n        }\n    }\n\n    function toAddr(bytes calldata _bytes, uint256 _start) internal pure returns (address) {\n        unchecked {\n            uint256 end = _start + 20;\n            return address(bytes20(_bytes[_start:end]));\n        }\n    }\n\n    function toB32(bytes calldata _bytes, uint256 _start) internal pure returns (bytes32) {\n        unchecked {\n            uint256 end = _start + 32;\n            return bytes32(_bytes[_start:end]);\n        }\n    }\n}\n"
    },
    "contracts/protocol/contracts/libs/Errors.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nlibrary Errors {\n    error LZ_LzTokenUnavailable();\n    error LZ_InvalidReceiveLibrary();\n    error LZ_InvalidNonce(uint64 nonce);\n    error LZ_InvalidArgument();\n    error LZ_InvalidExpiry();\n    error LZ_InvalidAmount(uint256 required, uint256 supplied);\n    error LZ_OnlyRegisteredOrDefaultLib();\n    error LZ_OnlyRegisteredLib();\n    error LZ_OnlyNonDefaultLib();\n    error LZ_Unauthorized();\n    error LZ_DefaultSendLibUnavailable();\n    error LZ_DefaultReceiveLibUnavailable();\n    error LZ_PathNotInitializable();\n    error LZ_PathNotVerifiable();\n    error LZ_OnlySendLib();\n    error LZ_OnlyReceiveLib();\n    error LZ_UnsupportedEid();\n    error LZ_UnsupportedInterface();\n    error LZ_AlreadyRegistered();\n    error LZ_SameValue();\n    error LZ_InvalidPayloadHash();\n    error LZ_PayloadHashNotFound(bytes32 expected, bytes32 actual);\n    error LZ_ComposeNotFound(bytes32 expected, bytes32 actual);\n    error LZ_ComposeExists();\n    error LZ_SendReentrancy();\n    error LZ_NotImplemented();\n    error LZ_InsufficientFee(\n        uint256 requiredNative,\n        uint256 suppliedNative,\n        uint256 requiredLzToken,\n        uint256 suppliedLzToken\n    );\n    error LZ_ZeroLzTokenFee();\n}\n"
    },
    "contracts/protocol/contracts/libs/GUID.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { AddressCast } from \"./AddressCast.sol\";\n\nlibrary GUID {\n    using AddressCast for address;\n\n    function generate(\n        uint64 _nonce,\n        uint32 _srcEid,\n        address _sender,\n        uint32 _dstEid,\n        bytes32 _receiver\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_nonce, _srcEid, _sender.toBytes32(), _dstEid, _receiver));\n    }\n}\n"
    },
    "contracts/protocol/contracts/libs/Transfer.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nlibrary Transfer {\n    using SafeERC20 for IERC20;\n\n    address internal constant ADDRESS_ZERO = address(0);\n\n    error Transfer_NativeFailed(address _to, uint256 _value);\n    error Transfer_ToAddressIsZero();\n\n    function native(address _to, uint256 _value) internal {\n        if (_to == ADDRESS_ZERO) revert Transfer_ToAddressIsZero();\n        (bool success, ) = _to.call{ value: _value }(\"\");\n        if (!success) revert Transfer_NativeFailed(_to, _value);\n    }\n\n    function token(address _token, address _to, uint256 _value) internal {\n        if (_to == ADDRESS_ZERO) revert Transfer_ToAddressIsZero();\n        IERC20(_token).safeTransfer(_to, _value);\n    }\n\n    function nativeOrToken(address _token, address _to, uint256 _value) internal {\n        if (_token == ADDRESS_ZERO) {\n            native(_to, _value);\n        } else {\n            token(_token, _to, _value);\n        }\n    }\n}\n"
    },
    "contracts/protocol/contracts/messagelib/BlockedMessageLib.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { ERC165 } from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\nimport { IMessageLib, MessageLibType } from \"../interfaces/IMessageLib.sol\";\nimport { Errors } from \"../libs/Errors.sol\";\n\ncontract BlockedMessageLib is ERC165 {\n    function supportsInterface(bytes4 interfaceId) public view override returns (bool) {\n        return interfaceId == type(IMessageLib).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function version() external pure returns (uint64 major, uint8 minor, uint8 endpointVersion) {\n        return (type(uint64).max, type(uint8).max, 2);\n    }\n\n    function messageLibType() external pure returns (MessageLibType) {\n        return MessageLibType.SendAndReceive;\n    }\n\n    function isSupportedEid(uint32) external pure returns (bool) {\n        return true;\n    }\n\n    fallback() external {\n        revert Errors.LZ_NotImplemented();\n    }\n}\n"
    },
    "contracts/protocol/contracts/messagelib/libs/BitMaps.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// modified from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/structs/BitMaps.sol\npragma solidity ^0.8.20;\n\ntype BitMap256 is uint256;\n\nusing BitMaps for BitMap256 global;\n\nlibrary BitMaps {\n    /**\n     * @dev Returns whether the bit at `index` is set.\n     */\n    function get(BitMap256 bitmap, uint8 index) internal pure returns (bool) {\n        uint256 mask = 1 << index;\n        return BitMap256.unwrap(bitmap) & mask != 0;\n    }\n\n    /**\n     * @dev Sets the bit at `index`.\n     */\n    function set(BitMap256 bitmap, uint8 index) internal pure returns (BitMap256) {\n        uint256 mask = 1 << index;\n        return BitMap256.wrap(BitMap256.unwrap(bitmap) | mask);\n    }\n}\n"
    },
    "contracts/protocol/contracts/messagelib/libs/ExecutorOptions.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { CalldataBytesLib } from \"../../libs/CalldataBytesLib.sol\";\n\nlibrary ExecutorOptions {\n    using CalldataBytesLib for bytes;\n\n    uint8 internal constant WORKER_ID = 1;\n\n    uint8 internal constant OPTION_TYPE_LZRECEIVE = 1;\n    uint8 internal constant OPTION_TYPE_NATIVE_DROP = 2;\n    uint8 internal constant OPTION_TYPE_LZCOMPOSE = 3;\n    uint8 internal constant OPTION_TYPE_ORDERED_EXECUTION = 4;\n\n    error Executor_InvalidLzReceiveOption();\n    error Executor_InvalidNativeDropOption();\n    error Executor_InvalidLzComposeOption();\n\n    /// @dev decode the next executor option from the options starting from the specified cursor\n    /// @param _options [executor_id][executor_option][executor_id][executor_option]...\n    ///        executor_option = [option_size][option_type][option]\n    ///        option_size = len(option_type) + len(option)\n    ///        executor_id: uint8, option_size: uint16, option_type: uint8, option: bytes\n    /// @param _cursor the cursor to start decoding from\n    /// @return optionType the type of the option\n    /// @return option the option of the executor\n    /// @return cursor the cursor to start decoding the next executor option\n    function nextExecutorOption(\n        bytes calldata _options,\n        uint256 _cursor\n    ) internal pure returns (uint8 optionType, bytes calldata option, uint256 cursor) {\n        unchecked {\n            // skip worker id\n            cursor = _cursor + 1;\n\n            // read option size\n            uint16 size = _options.toU16(cursor);\n            cursor += 2;\n\n            // read option type\n            optionType = _options.toU8(cursor);\n\n            // startCursor and endCursor are used to slice the option from _options\n            uint256 startCursor = cursor + 1; // skip option type\n            uint256 endCursor = cursor + size;\n            option = _options[startCursor:endCursor];\n            cursor += size;\n        }\n    }\n\n    function decodeLzReceiveOption(bytes calldata _option) internal pure returns (uint128 gas, uint128 value) {\n        if (_option.length != 16 && _option.length != 32) revert Executor_InvalidLzReceiveOption();\n        gas = _option.toU128(0);\n        value = _option.length == 32 ? _option.toU128(16) : 0;\n    }\n\n    function decodeNativeDropOption(bytes calldata _option) internal pure returns (uint128 amount, bytes32 receiver) {\n        if (_option.length != 48) revert Executor_InvalidNativeDropOption();\n        amount = _option.toU128(0);\n        receiver = _option.toB32(16);\n    }\n\n    function decodeLzComposeOption(\n        bytes calldata _option\n    ) internal pure returns (uint16 index, uint128 gas, uint128 value) {\n        if (_option.length != 18 && _option.length != 34) revert Executor_InvalidLzComposeOption();\n        index = _option.toU16(0);\n        gas = _option.toU128(2);\n        value = _option.length == 34 ? _option.toU128(18) : 0;\n    }\n\n    function encodeLzReceiveOption(uint128 _gas, uint128 _value) internal pure returns (bytes memory) {\n        return _value == 0 ? abi.encodePacked(_gas) : abi.encodePacked(_gas, _value);\n    }\n\n    function encodeNativeDropOption(uint128 _amount, bytes32 _receiver) internal pure returns (bytes memory) {\n        return abi.encodePacked(_amount, _receiver);\n    }\n\n    function encodeLzComposeOption(uint16 _index, uint128 _gas, uint128 _value) internal pure returns (bytes memory) {\n        return _value == 0 ? abi.encodePacked(_index, _gas) : abi.encodePacked(_index, _gas, _value);\n    }\n}\n"
    },
    "contracts/protocol/contracts/messagelib/libs/PacketV1Codec.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { Packet } from \"../../interfaces/ISendLib.sol\";\nimport { AddressCast } from \"../../libs/AddressCast.sol\";\n\nlibrary PacketV1Codec {\n    using AddressCast for address;\n    using AddressCast for bytes32;\n\n    uint8 internal constant PACKET_VERSION = 1;\n\n    // header (version + nonce + path)\n    // version\n    uint256 private constant PACKET_VERSION_OFFSET = 0;\n    //    nonce\n    uint256 private constant NONCE_OFFSET = 1;\n    //    path\n    uint256 private constant SRC_EID_OFFSET = 9;\n    uint256 private constant SENDER_OFFSET = 13;\n    uint256 private constant DST_EID_OFFSET = 45;\n    uint256 private constant RECEIVER_OFFSET = 49;\n    // payload (guid + message)\n    uint256 private constant GUID_OFFSET = 81; // keccak256(nonce + path)\n    uint256 private constant MESSAGE_OFFSET = 113;\n\n    function encode(Packet memory _packet) internal pure returns (bytes memory encodedPacket) {\n        encodedPacket = abi.encodePacked(\n            PACKET_VERSION,\n            _packet.nonce,\n            _packet.srcEid,\n            _packet.sender.toBytes32(),\n            _packet.dstEid,\n            _packet.receiver,\n            _packet.guid,\n            _packet.message\n        );\n    }\n\n    function encodePacketHeader(Packet memory _packet) internal pure returns (bytes memory) {\n        return\n            abi.encodePacked(\n                PACKET_VERSION,\n                _packet.nonce,\n                _packet.srcEid,\n                _packet.sender.toBytes32(),\n                _packet.dstEid,\n                _packet.receiver\n            );\n    }\n\n    function encodePayload(Packet memory _packet) internal pure returns (bytes memory) {\n        return abi.encodePacked(_packet.guid, _packet.message);\n    }\n\n    function header(bytes calldata _packet) internal pure returns (bytes calldata) {\n        return _packet[0:GUID_OFFSET];\n    }\n\n    function version(bytes calldata _packet) internal pure returns (uint8) {\n        return uint8(bytes1(_packet[PACKET_VERSION_OFFSET:NONCE_OFFSET]));\n    }\n\n    function nonce(bytes calldata _packet) internal pure returns (uint64) {\n        return uint64(bytes8(_packet[NONCE_OFFSET:SRC_EID_OFFSET]));\n    }\n\n    function srcEid(bytes calldata _packet) internal pure returns (uint32) {\n        return uint32(bytes4(_packet[SRC_EID_OFFSET:SENDER_OFFSET]));\n    }\n\n    function sender(bytes calldata _packet) internal pure returns (bytes32) {\n        return bytes32(_packet[SENDER_OFFSET:DST_EID_OFFSET]);\n    }\n\n    function senderAddressB20(bytes calldata _packet) internal pure returns (address) {\n        return sender(_packet).toAddress();\n    }\n\n    function dstEid(bytes calldata _packet) internal pure returns (uint32) {\n        return uint32(bytes4(_packet[DST_EID_OFFSET:RECEIVER_OFFSET]));\n    }\n\n    function receiver(bytes calldata _packet) internal pure returns (bytes32) {\n        return bytes32(_packet[RECEIVER_OFFSET:GUID_OFFSET]);\n    }\n\n    function receiverB20(bytes calldata _packet) internal pure returns (address) {\n        return receiver(_packet).toAddress();\n    }\n\n    function guid(bytes calldata _packet) internal pure returns (bytes32) {\n        return bytes32(_packet[GUID_OFFSET:MESSAGE_OFFSET]);\n    }\n\n    function message(bytes calldata _packet) internal pure returns (bytes calldata) {\n        return bytes(_packet[MESSAGE_OFFSET:]);\n    }\n\n    function payload(bytes calldata _packet) internal pure returns (bytes calldata) {\n        return bytes(_packet[GUID_OFFSET:]);\n    }\n\n    function payloadHash(bytes calldata _packet) internal pure returns (bytes32) {\n        return keccak256(payload(_packet));\n    }\n}\n"
    },
    "contracts/protocol/contracts/messagelib/SimpleMessageLib.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ERC165 } from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport { IMessageLib, MessageLibType } from \"../interfaces/IMessageLib.sol\";\nimport { Packet } from \"../interfaces/ISendLib.sol\";\nimport { ILayerZeroEndpointV2, MessagingFee, Origin } from \"../interfaces/ILayerZeroEndpointV2.sol\";\nimport { Errors } from \"../libs/Errors.sol\";\nimport { PacketV1Codec } from \"./libs/PacketV1Codec.sol\";\nimport { Transfer } from \"../libs/Transfer.sol\";\n\ncontract SimpleMessageLib is Ownable, ERC165 {\n    using SafeERC20 for IERC20;\n    using PacketV1Codec for bytes;\n\n    address public immutable endpoint;\n    address public immutable treasury;\n    uint32 public immutable localEid;\n    uint8 public constant PACKET_VERSION = 1;\n\n    address public whitelistCaller;\n\n    uint256 public lzTokenFee;\n    uint256 public nativeFee;\n\n    bytes public defaultOption;\n\n    error OnlyEndpoint();\n    error OnlyWhitelistCaller();\n    error InvalidEndpoint(address expected, address actual);\n    error ToIsAddressZero();\n    error LzTokenIsAddressZero();\n    error TransferFailed();\n\n    // only the endpoint can call SEND() and setConfig()\n    modifier onlyEndpoint() {\n        if (endpoint != msg.sender) {\n            revert OnlyEndpoint();\n        }\n        _;\n    }\n\n    constructor(address _endpoint, address _treasury) {\n        endpoint = _endpoint;\n        treasury = _treasury;\n        localEid = ILayerZeroEndpointV2(_endpoint).eid();\n        lzTokenFee = 99;\n        nativeFee = 100;\n        //        defaultOption = Options.encodeLegacyOptionsType1(200000);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view override returns (bool) {\n        return interfaceId == type(IMessageLib).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    // no validation logic at all\n    function validatePacket(bytes calldata packetBytes) external {\n        if (whitelistCaller != address(0x0) && msg.sender != whitelistCaller) {\n            revert OnlyWhitelistCaller();\n        }\n        Origin memory origin = Origin(packetBytes.srcEid(), packetBytes.sender(), packetBytes.nonce());\n        ILayerZeroEndpointV2(endpoint).verify(origin, packetBytes.receiverB20(), keccak256(packetBytes.payload()));\n    }\n\n    // ------------------ onlyEndpoint ------------------\n    function send(\n        Packet calldata _packet,\n        bytes memory _options,\n        bool _payInLzToken\n    ) external onlyEndpoint returns (MessagingFee memory fee, bytes memory encodedPacket, bytes memory options) {\n        encodedPacket = PacketV1Codec.encode(_packet);\n\n        options = _options.length == 0 ? defaultOption : _options;\n        _handleMessagingParamsHook(encodedPacket, options);\n\n        fee = MessagingFee(nativeFee, _payInLzToken ? lzTokenFee : 0);\n    }\n\n    // ------------------ onlyOwner ------------------\n    function setDefaultOption(bytes memory _defaultOption) external onlyOwner {\n        defaultOption = _defaultOption;\n    }\n\n    function setMessagingFee(uint256 _nativeFee, uint256 _lzTokenFee) external onlyOwner {\n        nativeFee = _nativeFee;\n        lzTokenFee = _lzTokenFee;\n    }\n\n    function setWhitelistCaller(address _whitelistCaller) external onlyOwner {\n        whitelistCaller = _whitelistCaller;\n    }\n\n    function withdrawFee(address _to, uint256 _amount) external onlyOwner {\n        if (_to == address(0x0)) {\n            revert ToIsAddressZero();\n        }\n\n        address altTokenAddr = ILayerZeroEndpointV2(endpoint).nativeToken();\n\n        // transfers native if altTokenAddr == address(0x0)\n        Transfer.nativeOrToken(altTokenAddr, _to, _amount);\n    }\n\n    function withdrawLzTokenFee(address _to, uint256 _amount) external onlyOwner {\n        if (_to == address(0x0)) {\n            revert ToIsAddressZero();\n        }\n        address lzToken = ILayerZeroEndpointV2(endpoint).lzToken();\n        if (lzToken == address(0x0)) {\n            revert LzTokenIsAddressZero();\n        }\n        IERC20(lzToken).safeTransfer(_to, _amount);\n    }\n\n    // ------------------ View ------------------\n    function quote(\n        Packet calldata /*_packet*/,\n        bytes calldata /*_options*/,\n        bool _payInLzToken\n    ) external view returns (MessagingFee memory) {\n        return MessagingFee(nativeFee, _payInLzToken ? lzTokenFee : 0);\n    }\n\n    function isSupportedEid(uint32) external pure returns (bool) {\n        return true;\n    }\n\n    function version() external pure returns (uint64 major, uint8 minor, uint8 endpointVersion) {\n        return (0, 0, 2);\n    }\n\n    function messageLibType() external pure returns (MessageLibType) {\n        return MessageLibType.SendAndReceive;\n    }\n\n    // ------------------ Internal ------------------\n    function _handleMessagingParamsHook(bytes memory _encodedPacket, bytes memory _options) internal virtual {}\n\n    fallback() external payable {\n        revert Errors.LZ_NotImplemented();\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts/protocol/contracts/MessageLibManager.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport { IMessageLib, MessageLibType } from \"./interfaces/IMessageLib.sol\";\nimport { IMessageLibManager, SetConfigParam } from \"./interfaces/IMessageLibManager.sol\";\nimport { Errors } from \"./libs/Errors.sol\";\nimport { BlockedMessageLib } from \"./messagelib/BlockedMessageLib.sol\";\n\nabstract contract MessageLibManager is Ownable, IMessageLibManager {\n    address private constant DEFAULT_LIB = address(0);\n\n    // the library that reverts both on send and quote\n    // must be configured on construction and be immutable\n    address public immutable blockedLibrary;\n\n    // only registered libraries all valid libraries\n    // the blockedLibrary will be registered on construction\n    address[] internal registeredLibraries;\n    mapping(address lib => bool) public isRegisteredLibrary;\n\n    // both sendLibrary and receiveLibrary config can be lazily resolved\n    mapping(address sender => mapping(uint32 dstEid => address lib)) internal sendLibrary;\n    mapping(address receiver => mapping(uint32 srcEid => address lib)) internal receiveLibrary;\n    mapping(address receiver => mapping(uint32 srcEid => Timeout)) public receiveLibraryTimeout;\n\n    mapping(uint32 dstEid => address lib) public defaultSendLibrary;\n    mapping(uint32 srcEid => address lib) public defaultReceiveLibrary;\n    mapping(uint32 srcEid => Timeout) public defaultReceiveLibraryTimeout;\n\n    constructor() {\n        blockedLibrary = address(new BlockedMessageLib());\n        registerLibrary(blockedLibrary);\n    }\n\n    modifier onlyRegistered(address _lib) {\n        if (!isRegisteredLibrary[_lib]) revert Errors.LZ_OnlyRegisteredLib();\n        _;\n    }\n\n    modifier isSendLib(address _lib) {\n        if (_lib != DEFAULT_LIB) {\n            if (IMessageLib(_lib).messageLibType() == MessageLibType.Receive) revert Errors.LZ_OnlySendLib();\n        }\n        _;\n    }\n\n    modifier isReceiveLib(address _lib) {\n        if (_lib != DEFAULT_LIB) {\n            if (IMessageLib(_lib).messageLibType() == MessageLibType.Send) revert Errors.LZ_OnlyReceiveLib();\n        }\n        _;\n    }\n\n    modifier onlyRegisteredOrDefault(address _lib) {\n        if (!isRegisteredLibrary[_lib] && _lib != DEFAULT_LIB) revert Errors.LZ_OnlyRegisteredOrDefaultLib();\n        _;\n    }\n\n    /// @dev check if the library supported the eid.\n    modifier onlySupportedEid(address _lib, uint32 _eid) {\n        /// @dev doesnt need to check for default lib, because when they are initially added they get passed through this modifier\n        if (_lib != DEFAULT_LIB) {\n            if (!IMessageLib(_lib).isSupportedEid(_eid)) revert Errors.LZ_UnsupportedEid();\n        }\n        _;\n    }\n\n    function getRegisteredLibraries() external view returns (address[] memory) {\n        return registeredLibraries;\n    }\n\n    /// @notice The Send Library is the Oapp specified library that will be used to send the message to the destination\n    /// endpoint. If the Oapp does not specify a Send Library, the default Send Library will be used.\n    /// @dev If the Oapp does not have a selected Send Library, this function will resolve to the default library\n    /// configured by LayerZero\n    /// @return lib address of the Send Library\n    /// @param _sender The address of the Oapp that is sending the message\n    /// @param _dstEid The destination endpoint id\n    function getSendLibrary(address _sender, uint32 _dstEid) public view returns (address lib) {\n        lib = sendLibrary[_sender][_dstEid];\n        if (lib == DEFAULT_LIB) {\n            lib = defaultSendLibrary[_dstEid];\n            if (lib == address(0x0)) revert Errors.LZ_DefaultSendLibUnavailable();\n        }\n    }\n\n    function isDefaultSendLibrary(address _sender, uint32 _dstEid) public view returns (bool) {\n        return sendLibrary[_sender][_dstEid] == DEFAULT_LIB;\n    }\n\n    /// @dev the receiveLibrary can be lazily resolved that if not set it will point to the default configured by LayerZero\n    function getReceiveLibrary(address _receiver, uint32 _srcEid) public view returns (address lib, bool isDefault) {\n        lib = receiveLibrary[_receiver][_srcEid];\n        if (lib == DEFAULT_LIB) {\n            lib = defaultReceiveLibrary[_srcEid];\n            if (lib == address(0x0)) revert Errors.LZ_DefaultReceiveLibUnavailable();\n            isDefault = true;\n        }\n    }\n\n    /// @dev called when the endpoint checks if the msgLib attempting to verify the msg is the configured msgLib of the Oapp\n    /// @dev this check provides the ability for Oapp to lock in a trusted msgLib\n    /// @dev it will fist check if the msgLib is the currently configured one. then check if the msgLib is the one in grace period of msgLib versioning upgrade\n    function isValidReceiveLibrary(\n        address _receiver,\n        uint32 _srcEid,\n        address _actualReceiveLib\n    ) public view returns (bool) {\n        // early return true if the _actualReceiveLib is the currently configured one\n        (address expectedReceiveLib, bool isDefault) = getReceiveLibrary(_receiver, _srcEid);\n        if (_actualReceiveLib == expectedReceiveLib) {\n            return true;\n        }\n\n        // check the timeout condition otherwise\n        // if the Oapp is using defaultReceiveLibrary, use the default Timeout config\n        // otherwise, use the Timeout configured by the Oapp\n        Timeout memory timeout = isDefault\n            ? defaultReceiveLibraryTimeout[_srcEid]\n            : receiveLibraryTimeout[_receiver][_srcEid];\n\n        // requires the _actualReceiveLib to be the same as the one in grace period and the grace period has not expired\n        // block.number is uint256 so timeout.expiry must > 0, which implies a non-ZERO value\n        if (timeout.lib == _actualReceiveLib && timeout.expiry > block.number) {\n            // timeout lib set and has not expired\n            return true;\n        }\n\n        // returns false by default\n        return false;\n    }\n\n    //------- Owner interfaces\n    /// @dev all libraries have to implement the erc165 interface to prevent wrong configurations\n    /// @dev only owner\n    function registerLibrary(address _lib) public onlyOwner {\n        // must have the right interface\n        if (!IERC165(_lib).supportsInterface(type(IMessageLib).interfaceId)) revert Errors.LZ_UnsupportedInterface();\n        // must have not been registered\n        if (isRegisteredLibrary[_lib]) revert Errors.LZ_AlreadyRegistered();\n\n        // insert into both the map and the list\n        isRegisteredLibrary[_lib] = true;\n        registeredLibraries.push(_lib);\n\n        emit LibraryRegistered(_lib);\n    }\n\n    /// @dev owner setting the defaultSendLibrary\n    /// @dev can set to the blockedLibrary, which is a registered library\n    /// @dev the msgLib must enable the support before they can be registered to the endpoint as the default\n    /// @dev only owner\n    function setDefaultSendLibrary(\n        uint32 _eid,\n        address _newLib\n    ) external onlyOwner onlyRegistered(_newLib) isSendLib(_newLib) onlySupportedEid(_newLib, _eid) {\n        // must provide a different value\n        if (defaultSendLibrary[_eid] == _newLib) revert Errors.LZ_SameValue();\n        defaultSendLibrary[_eid] = _newLib;\n        emit DefaultSendLibrarySet(_eid, _newLib);\n    }\n\n    /// @dev owner setting the defaultSendLibrary\n    /// @dev must be a registered library (including blockLibrary) with the eid support enabled\n    /// @dev in version migration, it can add a grace period to the old library. if the grace period is 0, it will delete the timeout configuration.\n    /// @dev only owner\n    function setDefaultReceiveLibrary(\n        uint32 _eid,\n        address _newLib,\n        uint256 _gracePeriod\n    ) external onlyOwner onlyRegistered(_newLib) isReceiveLib(_newLib) onlySupportedEid(_newLib, _eid) {\n        address oldLib = defaultReceiveLibrary[_eid];\n        // must provide a different value\n        if (oldLib == _newLib) revert Errors.LZ_SameValue();\n\n        defaultReceiveLibrary[_eid] = _newLib;\n        emit DefaultReceiveLibrarySet(_eid, _newLib);\n\n        if (_gracePeriod > 0) {\n            // override the current default timeout to the [old_lib + new expiry]\n            Timeout storage timeout = defaultReceiveLibraryTimeout[_eid];\n            timeout.lib = oldLib;\n            timeout.expiry = block.number + _gracePeriod;\n            emit DefaultReceiveLibraryTimeoutSet(_eid, oldLib, timeout.expiry);\n        } else {\n            // otherwise, remove the old configuration.\n            delete defaultReceiveLibraryTimeout[_eid];\n            emit DefaultReceiveLibraryTimeoutSet(_eid, oldLib, 0);\n        }\n    }\n\n    /// @dev owner setting the defaultSendLibrary\n    /// @dev must be a registered library (including blockLibrary) with the eid support enabled\n    /// @dev can used to (1) extend the current configuration (2) force remove the current configuration (3) change to a new configuration\n    /// @param _expiry the block number when lib expires\n    function setDefaultReceiveLibraryTimeout(\n        uint32 _eid,\n        address _lib,\n        uint256 _expiry\n    ) external onlyRegistered(_lib) isReceiveLib(_lib) onlySupportedEid(_lib, _eid) onlyOwner {\n        if (_expiry == 0) {\n            // force remove the current configuration\n            delete defaultReceiveLibraryTimeout[_eid];\n        } else {\n            // override it with new configuration\n            if (_expiry <= block.number) revert Errors.LZ_InvalidExpiry();\n            Timeout storage timeout = defaultReceiveLibraryTimeout[_eid];\n            timeout.lib = _lib;\n            timeout.expiry = _expiry;\n        }\n        emit DefaultReceiveLibraryTimeoutSet(_eid, _lib, _expiry);\n    }\n\n    /// @dev returns true only if both the default send/receive libraries are set\n    function isSupportedEid(uint32 _eid) external view returns (bool) {\n        return defaultSendLibrary[_eid] != address(0) && defaultReceiveLibrary[_eid] != address(0);\n    }\n\n    //------- OApp interfaces\n    /// @dev Oapp setting the sendLibrary\n    /// @dev must be a registered library (including blockLibrary) with the eid support enabled\n    /// @dev authenticated by the Oapp\n    function setSendLibrary(\n        address _oapp,\n        uint32 _eid,\n        address _newLib\n    ) external onlyRegisteredOrDefault(_newLib) isSendLib(_newLib) onlySupportedEid(_newLib, _eid) {\n        _assertAuthorized(_oapp);\n\n        // must provide a different value\n        if (sendLibrary[_oapp][_eid] == _newLib) revert Errors.LZ_SameValue();\n        sendLibrary[_oapp][_eid] = _newLib;\n        emit SendLibrarySet(_oapp, _eid, _newLib);\n    }\n\n    /// @dev Oapp setting the receiveLibrary\n    /// @dev must be a registered library (including blockLibrary) with the eid support enabled\n    /// @dev in version migration, it can add a grace period to the old library. if the grace period is 0, it will delete the timeout configuration.\n    /// @dev authenticated by the Oapp\n    /// @param _gracePeriod the number of blocks from now until oldLib expires\n    function setReceiveLibrary(\n        address _oapp,\n        uint32 _eid,\n        address _newLib,\n        uint256 _gracePeriod\n    ) external onlyRegisteredOrDefault(_newLib) isReceiveLib(_newLib) onlySupportedEid(_newLib, _eid) {\n        _assertAuthorized(_oapp);\n\n        address oldLib = receiveLibrary[_oapp][_eid];\n        // must provide new values\n        if (oldLib == _newLib) revert Errors.LZ_SameValue();\n        receiveLibrary[_oapp][_eid] = _newLib;\n        emit ReceiveLibrarySet(_oapp, _eid, _newLib);\n\n        if (_gracePeriod > 0) {\n            // to simplify the logic, we only allow to set timeout if neither the new lib nor old lib is DEFAULT_LIB, which would should read the default timeout configurations\n            // (1) if the Oapp wants to fall back to the DEFAULT, then set the newLib to DEFAULT with grace period == 0\n            // (2) if the Oapp wants to change to a non DEFAULT from DEFAULT, then set the newLib to 'non-default' with _gracePeriod == 0, then use setReceiveLibraryTimeout() interface\n            if (oldLib == DEFAULT_LIB || _newLib == DEFAULT_LIB) revert Errors.LZ_OnlyNonDefaultLib();\n\n            // write to storage\n            Timeout memory timeout = Timeout({ lib: oldLib, expiry: block.number + _gracePeriod });\n            receiveLibraryTimeout[_oapp][_eid] = timeout;\n            emit ReceiveLibraryTimeoutSet(_oapp, _eid, oldLib, timeout.expiry);\n        } else {\n            delete receiveLibraryTimeout[_oapp][_eid];\n            emit ReceiveLibraryTimeoutSet(_oapp, _eid, oldLib, 0);\n        }\n    }\n\n    /// @dev Oapp setting the defaultSendLibrary\n    /// @dev must be a registered library (including blockLibrary) with the eid support enabled\n    /// @dev can used to (1) extend the current configuration (2)  force remove the current configuration (3) change to a new configuration\n    /// @param _expiry the block number when lib expires\n    function setReceiveLibraryTimeout(\n        address _oapp,\n        uint32 _eid,\n        address _lib,\n        uint256 _expiry\n    ) external onlyRegistered(_lib) isReceiveLib(_lib) onlySupportedEid(_lib, _eid) {\n        _assertAuthorized(_oapp);\n\n        (, bool isDefault) = getReceiveLibrary(_oapp, _eid);\n        // if current library is DEFAULT, Oapp cant set the timeout\n        if (isDefault) revert Errors.LZ_OnlyNonDefaultLib();\n\n        if (_expiry == 0) {\n            // force remove the current configuration\n            delete receiveLibraryTimeout[_oapp][_eid];\n        } else {\n            // override it with new configuration\n            if (_expiry <= block.number) revert Errors.LZ_InvalidExpiry();\n            Timeout storage timeout = receiveLibraryTimeout[_oapp][_eid];\n            timeout.lib = _lib;\n            timeout.expiry = _expiry;\n        }\n        emit ReceiveLibraryTimeoutSet(_oapp, _eid, _lib, _expiry);\n    }\n\n    //------- library config setter/getter. all pass-through functions to the msgLib\n\n    /// @dev authenticated by the _oapp\n    function setConfig(address _oapp, address _lib, SetConfigParam[] calldata _params) external onlyRegistered(_lib) {\n        _assertAuthorized(_oapp);\n\n        IMessageLib(_lib).setConfig(_oapp, _params);\n    }\n\n    /// @dev a view function to query the current configuration of the OApp\n    function getConfig(\n        address _oapp,\n        address _lib,\n        uint32 _eid,\n        uint32 _configType\n    ) external view onlyRegistered(_lib) returns (bytes memory config) {\n        return IMessageLib(_lib).getConfig(_eid, _oapp, _configType);\n    }\n\n    function _assertAuthorized(address _oapp) internal virtual;\n}\n"
    },
    "contracts/protocol/contracts/MessagingChannel.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { IMessagingChannel } from \"./interfaces/IMessagingChannel.sol\";\nimport { Errors } from \"./libs/Errors.sol\";\nimport { GUID } from \"./libs/GUID.sol\";\n\nabstract contract MessagingChannel is IMessagingChannel {\n    bytes32 public constant EMPTY_PAYLOAD_HASH = bytes32(0);\n    bytes32 public constant NIL_PAYLOAD_HASH = bytes32(type(uint256).max);\n\n    // The universally unique id (UUID) of this deployed Endpoint\n    uint32 public immutable eid;\n\n    mapping(address receiver => mapping(uint32 srcEid => mapping(bytes32 sender => uint64 nonce)))\n        public lazyInboundNonce;\n    mapping(address receiver => mapping(uint32 srcEid => mapping(bytes32 sender => mapping(uint64 inboundNonce => bytes32 payloadHash))))\n        public inboundPayloadHash;\n    mapping(address sender => mapping(uint32 dstEid => mapping(bytes32 receiver => uint64 nonce))) public outboundNonce;\n\n    /// @param _eid is the universally unique id (UUID) of this deployed Endpoint\n    constructor(uint32 _eid) {\n        eid = _eid;\n    }\n\n    /// @dev increase and return the next outbound nonce\n    function _outbound(address _sender, uint32 _dstEid, bytes32 _receiver) internal returns (uint64 nonce) {\n        unchecked {\n            nonce = ++outboundNonce[_sender][_dstEid][_receiver];\n        }\n    }\n\n    /// @dev inbound won't update the nonce eagerly to allow unordered verification\n    /// @dev instead, it will update the nonce lazily when the message is received\n    /// @dev messages can only be cleared in order to preserve censorship-resistance\n    function _inbound(\n        address _receiver,\n        uint32 _srcEid,\n        bytes32 _sender,\n        uint64 _nonce,\n        bytes32 _payloadHash\n    ) internal {\n        if (_payloadHash == EMPTY_PAYLOAD_HASH) revert Errors.LZ_InvalidPayloadHash();\n        inboundPayloadHash[_receiver][_srcEid][_sender][_nonce] = _payloadHash;\n    }\n\n    /// @dev returns the max index of the longest gapless sequence of verified msg nonces.\n    /// @dev the uninitialized value is 0. the first nonce is always 1\n    /// @dev it starts from the lazyInboundNonce (last checkpoint) and iteratively check if the next nonce has been verified\n    /// @dev this function can OOG if too many backlogs, but it can be trivially fixed by just clearing some prior messages\n    /// @dev NOTE: Oapp explicitly skipped nonces count as \"verified\" for these purposes\n    /// @dev eg. [1,2,3,4,6,7] => 4, [1,2,6,8,10] => 2, [1,3,4,5,6] => 1\n    function inboundNonce(address _receiver, uint32 _srcEid, bytes32 _sender) public view returns (uint64) {\n        uint64 nonceCursor = lazyInboundNonce[_receiver][_srcEid][_sender];\n\n        // find the effective inbound currentNonce\n        unchecked {\n            while (_hasPayloadHash(_receiver, _srcEid, _sender, nonceCursor + 1)) {\n                ++nonceCursor;\n            }\n        }\n        return nonceCursor;\n    }\n\n    /// @dev checks if the storage slot is not initialized. Assumes computationally infeasible that payload can hash to 0\n    function _hasPayloadHash(\n        address _receiver,\n        uint32 _srcEid,\n        bytes32 _sender,\n        uint64 _nonce\n    ) internal view returns (bool) {\n        return inboundPayloadHash[_receiver][_srcEid][_sender][_nonce] != EMPTY_PAYLOAD_HASH;\n    }\n\n    /// @dev the caller must provide _nonce to prevent skipping the unintended nonce\n    /// @dev it could happen in some race conditions, e.g. to skip nonce 3, but nonce 3 was consumed first\n    /// @dev usage: skipping the next nonce to prevent message verification, e.g. skip a message when Precrime throws alerts\n    /// @dev if the Oapp wants to skip a verified message, it should call the clear() function instead\n    /// @dev after skipping, the lazyInboundNonce is set to the provided nonce, which makes the inboundNonce also the provided nonce\n    /// @dev ie. allows the Oapp to increment the lazyInboundNonce without having had that corresponding msg be verified\n    function skip(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce) external {\n        _assertAuthorized(_oapp);\n\n        if (_nonce != inboundNonce(_oapp, _srcEid, _sender) + 1) revert Errors.LZ_InvalidNonce(_nonce);\n        lazyInboundNonce[_oapp][_srcEid][_sender] = _nonce;\n        emit InboundNonceSkipped(_srcEid, _sender, _oapp, _nonce);\n    }\n\n    /// @dev Marks a packet as verified, but disallows execution until it is re-verified.\n    /// @dev Reverts if the provided _payloadHash does not match the currently verified payload hash.\n    /// @dev A non-verified nonce can be nilified by passing EMPTY_PAYLOAD_HASH for _payloadHash.\n    /// @dev Assumes the computational intractability of finding a payload that hashes to bytes32.max.\n    /// @dev Authenticated by the caller\n    function nilify(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce, bytes32 _payloadHash) external {\n        _assertAuthorized(_oapp);\n\n        bytes32 curPayloadHash = inboundPayloadHash[_oapp][_srcEid][_sender][_nonce];\n        if (curPayloadHash != _payloadHash) revert Errors.LZ_PayloadHashNotFound(curPayloadHash, _payloadHash);\n        if (_nonce <= lazyInboundNonce[_oapp][_srcEid][_sender] && curPayloadHash == EMPTY_PAYLOAD_HASH)\n            revert Errors.LZ_InvalidNonce(_nonce);\n        // set it to nil\n        inboundPayloadHash[_oapp][_srcEid][_sender][_nonce] = NIL_PAYLOAD_HASH;\n        emit PacketNilified(_srcEid, _sender, _oapp, _nonce, _payloadHash);\n    }\n\n    /// @dev Marks a nonce as unexecutable and un-verifiable. The nonce can never be re-verified or executed.\n    /// @dev Reverts if the provided _payloadHash does not match the currently verified payload hash.\n    /// @dev Only packets with nonces less than or equal to the lazy inbound nonce can be burned.\n    /// @dev Reverts if the nonce has already been executed.\n    /// @dev Authenticated by the caller\n    function burn(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce, bytes32 _payloadHash) external {\n        _assertAuthorized(_oapp);\n\n        bytes32 curPayloadHash = inboundPayloadHash[_oapp][_srcEid][_sender][_nonce];\n        if (curPayloadHash != _payloadHash) revert Errors.LZ_PayloadHashNotFound(curPayloadHash, _payloadHash);\n        if (curPayloadHash == EMPTY_PAYLOAD_HASH || _nonce > lazyInboundNonce[_oapp][_srcEid][_sender])\n            revert Errors.LZ_InvalidNonce(_nonce);\n        delete inboundPayloadHash[_oapp][_srcEid][_sender][_nonce];\n        emit PacketBurnt(_srcEid, _sender, _oapp, _nonce, _payloadHash);\n    }\n\n    /// @dev calling this function will clear the stored message and increment the lazyInboundNonce to the provided nonce\n    /// @dev if a lot of messages are queued, the messages can be cleared with a smaller step size to prevent OOG\n    /// @dev NOTE: this function does not change inboundNonce, it only changes the lazyInboundNonce up to the provided nonce\n    function _clearPayload(\n        address _receiver,\n        uint32 _srcEid,\n        bytes32 _sender,\n        uint64 _nonce,\n        bytes memory _payload\n    ) internal returns (bytes32 actualHash) {\n        uint64 currentNonce = lazyInboundNonce[_receiver][_srcEid][_sender];\n        if (_nonce > currentNonce) {\n            unchecked {\n                // try to lazily update the inboundNonce till the _nonce\n                for (uint64 i = currentNonce + 1; i <= _nonce; ++i) {\n                    if (!_hasPayloadHash(_receiver, _srcEid, _sender, i)) revert Errors.LZ_InvalidNonce(i);\n                }\n                lazyInboundNonce[_receiver][_srcEid][_sender] = _nonce;\n            }\n        }\n\n        // check the hash of the payload to verify the executor has given the proper payload that has been verified\n        actualHash = keccak256(_payload);\n        bytes32 expectedHash = inboundPayloadHash[_receiver][_srcEid][_sender][_nonce];\n        if (expectedHash != actualHash) revert Errors.LZ_PayloadHashNotFound(expectedHash, actualHash);\n\n        // remove it from the storage\n        delete inboundPayloadHash[_receiver][_srcEid][_sender][_nonce];\n    }\n\n    /// @dev returns the GUID for the next message given the path\n    /// @dev the Oapp might want to include the GUID into the message in some cases\n    function nextGuid(address _sender, uint32 _dstEid, bytes32 _receiver) external view returns (bytes32) {\n        uint64 nextNonce = outboundNonce[_sender][_dstEid][_receiver] + 1;\n        return GUID.generate(nextNonce, eid, _sender, _dstEid, _receiver);\n    }\n\n    function _assertAuthorized(address _oapp) internal virtual;\n}\n"
    },
    "contracts/protocol/contracts/MessagingComposer.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { IMessagingComposer } from \"./interfaces/IMessagingComposer.sol\";\nimport { ILayerZeroComposer } from \"./interfaces/ILayerZeroComposer.sol\";\nimport { Errors } from \"./libs/Errors.sol\";\n\nabstract contract MessagingComposer is IMessagingComposer {\n    bytes32 private constant NO_MESSAGE_HASH = bytes32(0);\n    bytes32 private constant RECEIVED_MESSAGE_HASH = bytes32(uint256(1));\n\n    mapping(address from => mapping(address to => mapping(bytes32 guid => mapping(uint16 index => bytes32 messageHash))))\n        public composeQueue;\n\n    /// @dev the Oapp sends the lzCompose message to the endpoint\n    /// @dev the composer MUST assert the sender because anyone can send compose msg with this function\n    /// @dev with the same GUID, the Oapp can send compose to multiple _composer at the same time\n    /// @dev authenticated by the msg.sender\n    /// @param _to the address which will receive the composed message\n    /// @param _guid the message guid\n    /// @param _message the message\n    function sendCompose(address _to, bytes32 _guid, uint16 _index, bytes calldata _message) external {\n        // must have not been sent before\n        if (composeQueue[msg.sender][_to][_guid][_index] != NO_MESSAGE_HASH) revert Errors.LZ_ComposeExists();\n        composeQueue[msg.sender][_to][_guid][_index] = keccak256(_message);\n        emit ComposeSent(msg.sender, _to, _guid, _index, _message);\n    }\n\n    /// @dev execute a composed messages from the sender to the composer (receiver)\n    /// @dev the execution provides the execution context (caller, extraData) to the receiver.\n    ///      the receiver can optionally assert the caller and validate the untrusted extraData\n    /// @dev can not re-entrant\n    /// @param _from the address which sends the composed message. in most cases, it is the Oapp's address.\n    /// @param _to the address which receives the composed message\n    /// @param _guid the message guid\n    /// @param _message the message\n    /// @param _extraData the extra data provided by the executor. this data is untrusted and should be validated.\n    function lzCompose(\n        address _from,\n        address _to,\n        bytes32 _guid,\n        uint16 _index,\n        bytes calldata _message,\n        bytes calldata _extraData\n    ) external payable {\n        // assert the validity\n        bytes32 expectedHash = composeQueue[_from][_to][_guid][_index];\n        bytes32 actualHash = keccak256(_message);\n        if (expectedHash != actualHash) revert Errors.LZ_ComposeNotFound(expectedHash, actualHash);\n\n        // marks the message as received to prevent reentrancy\n        // cannot just delete the value, otherwise the message can be sent again and could result in some undefined behaviour\n        // even though the sender(composing Oapp) is implicitly fully trusted by the composer.\n        // eg. sender may not even realize it has such a bug\n        composeQueue[_from][_to][_guid][_index] = RECEIVED_MESSAGE_HASH;\n        ILayerZeroComposer(_to).lzCompose{ value: msg.value }(_from, _guid, _message, msg.sender, _extraData);\n        emit ComposeDelivered(_from, _to, _guid, _index);\n    }\n\n    /// @param _from the address which sends the composed message\n    /// @param _to the address which receives the composed message\n    /// @param _guid the message guid\n    /// @param _message the message\n    /// @param _extraData the extra data provided by the executor\n    /// @param _reason the reason why the message is not received\n    function lzComposeAlert(\n        address _from,\n        address _to,\n        bytes32 _guid,\n        uint16 _index,\n        uint256 _gas,\n        uint256 _value,\n        bytes calldata _message,\n        bytes calldata _extraData,\n        bytes calldata _reason\n    ) external {\n        emit LzComposeAlert(_from, _to, msg.sender, _guid, _index, _gas, _value, _message, _extraData, _reason);\n    }\n}\n"
    },
    "contracts/protocol/contracts/MessagingContext.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { IMessagingContext } from \"./interfaces/IMessagingContext.sol\";\nimport { Errors } from \"./libs/Errors.sol\";\n\n/// this contract acts as a non-reentrancy guard and a source of messaging context\n/// the context includes the remote eid and the sender address\n/// it separates the send and receive context to allow messaging receipts (send back on receive())\nabstract contract MessagingContext is IMessagingContext {\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private _sendContext = NOT_ENTERED;\n\n    /// @dev the sendContext is set to 8 bytes 0s + 4 bytes eid + 20 bytes sender\n    modifier sendContext(uint32 _dstEid, address _sender) {\n        if (_sendContext != NOT_ENTERED) revert Errors.LZ_SendReentrancy();\n        _sendContext = (uint256(_dstEid) << 160) | uint160(_sender);\n        _;\n        _sendContext = NOT_ENTERED;\n    }\n\n    /// @dev returns true if sending message\n    function isSendingMessage() public view returns (bool) {\n        return _sendContext != NOT_ENTERED;\n    }\n\n    /// @dev returns (eid, sender) if sending message, (0, 0) otherwise\n    function getSendContext() external view returns (uint32, address) {\n        return isSendingMessage() ? _getSendContext(_sendContext) : (0, address(0));\n    }\n\n    function _getSendContext(uint256 _context) internal pure returns (uint32, address) {\n        return (uint32(_context >> 160), address(uint160(_context)));\n    }\n}\n"
    },
    "contracts/protocol/contracts/proxy/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// OpenZeppelin Contracts v4.4.1 (proxy/transparent/TransparentUpgradeableProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport { ERC1967Proxy } from \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\";\n\n/**\n * @author OpenZeppelin. Modified from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.4/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\n * to support custom errors.\n * @dev This contract implements a proxy that is upgradeable by an admin.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error indicating\n * the proxy admin cannot fallback to the target implementation.\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n */\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\n    /**\n     * @dev The proxy caller is the current admin, and can't fallback to the proxy target.\n     */\n    error AdminAccessDenied();\n\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\n     */\n    constructor(address _logic, address admin_, bytes memory _data) payable ERC1967Proxy(_logic, _data) {\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n        _changeAdmin(admin_);\n    }\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _getAdmin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function admin() external ifAdmin returns (address admin_) {\n        admin_ = _getAdmin();\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function implementation() external ifAdmin returns (address implementation_) {\n        implementation_ = _implementation();\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\n     */\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\n        _changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\n     */\n    function upgradeTo(address newImplementation) external ifAdmin {\n        _upgradeToAndCall(newImplementation, bytes(\"\"), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\n        _upgradeToAndCall(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _admin() internal view virtual returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\n     */\n    function _beforeFallback() internal virtual override {\n        if (msg.sender == _getAdmin()) {\n            revert AdminAccessDenied();\n        }\n        super._beforeFallback();\n    }\n}\n"
    },
    "hardhat-deploy/solc_0.8/proxy/Proxied.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nabstract contract Proxied {\n    /// @notice to be used by initialisation / postUpgrade function so that only the proxy's admin can execute them\n    /// It also allows these functions to be called inside a contructor\n    /// even if the contract is meant to be used without proxy\n    modifier proxied() {\n        address proxyAdminAddress = _proxyAdmin();\n        // With hardhat-deploy proxies\n        // the proxyAdminAddress is zero only for the implementation contract\n        // if the implementation contract want to be used as a standalone/immutable contract\n        // it simply has to execute the `proxied` function\n        // This ensure the proxyAdminAddress is never zero post deployment\n        // And allow you to keep the same code for both proxied contract and immutable contract\n        if (proxyAdminAddress == address(0)) {\n            // ensure can not be called twice when used outside of proxy : no admin\n            // solhint-disable-next-line security/no-inline-assembly\n            assembly {\n                sstore(\n                    0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103,\n                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n                )\n            }\n        } else {\n            require(msg.sender == proxyAdminAddress);\n        }\n        _;\n    }\n\n    modifier onlyProxyAdmin() {\n        require(msg.sender == _proxyAdmin(), \"NOT_AUTHORIZED\");\n        _;\n    }\n\n    function _proxyAdmin() internal view returns (address ownerAddress) {\n        // solhint-disable-next-line security/no-inline-assembly\n        assembly {\n            ownerAddress := sload(0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103)\n        }\n    }\n}\n"
    },
    "solidity-bytes-utils/contracts/BytesLib.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\n/*\n * @title Solidity Bytes Arrays Utils\n * @author Gonalo S <goncalo.sa@consensys.net>\n *\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\n */\npragma solidity >=0.8.0 <0.9.0;\n\n\nlibrary BytesLib {\n    function concat(\n        bytes memory _preBytes,\n        bytes memory _postBytes\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory tempBytes;\n\n        assembly {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n            // Store the length of the first bytes array at the beginning of\n            // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            // Maintain a memory counter for the current write location in the\n            // temp bytes array by adding the 32 bytes for the array length to\n            // the starting location.\n            let mc := add(tempBytes, 0x20)\n            // Stop copying when the memory counter reaches the length of the\n            // first bytes array.\n            let end := add(mc, length)\n\n            for {\n                // Initialize a copy counter to the start of the _preBytes data,\n                // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                // Write the _preBytes data into the tempBytes memory 32 bytes\n                // at a time.\n                mstore(mc, mload(cc))\n            }\n\n            // Add the length of _postBytes to the current length of tempBytes\n            // and store it as the new length in the first 32 bytes of the\n            // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n            // Move the memory counter back from a multiple of 0x20 to the\n            // actual end of the _preBytes data.\n            mc := end\n            // Stop copying when the memory counter reaches the new combined\n            // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n            // Update the free-memory pointer by padding our last write location\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n            // next 32 byte block, then round down to the nearest multiple of\n            // 32. If the sum of the length of the two arrays is zero then add\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(0x40, and(\n              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n              not(31) // Round down to the nearest 32 bytes.\n            ))\n        }\n\n        return tempBytes;\n    }\n\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n        assembly {\n            // Read the first 32 bytes of _preBytes storage, which is the length\n            // of the array. (We don't need to use the offset into the slot\n            // because arrays use the entire slot.)\n            let fslot := sload(_preBytes.slot)\n            // Arrays of 31 bytes or less have an even value in their slot,\n            // while longer arrays have an odd value. The actual length is\n            // the slot divided by two for odd values, and the lowest order\n            // byte divided by two for even values.\n            // If the slot is even, bitwise and the slot with 255 and divide by\n            // two to get the length. If the slot is odd, bitwise and the slot\n            // with -1 and divide by two.\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n            let newlength := add(slength, mlength)\n            // slength can contain both the length and contents of the array\n            // if length < 32 bytes so let's prepare for that\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n            switch add(lt(slength, 32), lt(newlength, 32))\n            case 2 {\n                // Since the new array still fits in the slot, we just need to\n                // update the contents of the slot.\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n                sstore(\n                    _preBytes.slot,\n                    // all the modifications to the slot are inside this\n                    // next block\n                    add(\n                        // we can just add to the slot contents because the\n                        // bytes we want to change are the LSBs\n                        fslot,\n                        add(\n                            mul(\n                                div(\n                                    // load the bytes from memory\n                                    mload(add(_postBytes, 0x20)),\n                                    // zero all bytes to the right\n                                    exp(0x100, sub(32, mlength))\n                                ),\n                                // and now shift left the number of bytes to\n                                // leave space for the length in the slot\n                                exp(0x100, sub(32, newlength))\n                            ),\n                            // increase length by the double of the memory\n                            // bytes length\n                            mul(mlength, 2)\n                        )\n                    )\n                )\n            }\n            case 1 {\n                // The stored value fits in the slot, but the combined value\n                // will exceed it.\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n                // The contents of the _postBytes array start 32 bytes into\n                // the structure. Our first read should obtain the `submod`\n                // bytes that can fit into the unused space in the last word\n                // of the stored array. To get this, we read 32 bytes starting\n                // from `submod`, so the data we read overlaps with the array\n                // contents by `submod` bytes. Masking the lowest-order\n                // `submod` bytes allows us to add that value directly to the\n                // stored value.\n\n                let submod := sub(32, slength)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(\n                    sc,\n                    add(\n                        and(\n                            fslot,\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\n                        ),\n                        and(mload(mc), mask)\n                    )\n                )\n\n                for {\n                    mc := add(mc, 0x20)\n                    sc := add(sc, 1)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n            default {\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                // Start copying to the last used word of the stored array.\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n                // Copy over the first `submod` bytes of the new data as in\n                // case 1 above.\n                let slengthmod := mod(slength, 32)\n                let mlengthmod := mod(mlength, 32)\n                let submod := sub(32, slengthmod)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\n\n                for {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n        }\n    }\n\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        require(_length + 31 >= _length, \"slice_overflow\");\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_bytes.length >= _start + 20, \"toAddress_outOfBounds\");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\n        require(_bytes.length >= _start + 1 , \"toUint8_outOfBounds\");\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\n        require(_bytes.length >= _start + 2, \"toUint16_outOfBounds\");\n        uint16 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x2), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\n        require(_bytes.length >= _start + 4, \"toUint32_outOfBounds\");\n        uint32 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x4), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\n        require(_bytes.length >= _start + 8, \"toUint64_outOfBounds\");\n        uint64 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x8), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\n        require(_bytes.length >= _start + 12, \"toUint96_outOfBounds\");\n        uint96 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0xc), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\n        require(_bytes.length >= _start + 16, \"toUint128_outOfBounds\");\n        uint128 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x10), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\n        require(_bytes.length >= _start + 32, \"toUint256_outOfBounds\");\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\n        require(_bytes.length >= _start + 32, \"toBytes32_outOfBounds\");\n        bytes32 tempBytes32;\n\n        assembly {\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes32;\n    }\n\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n            case 1 {\n                // cb is a circuit breaker in the for loop since there's\n                //  no said feature for inline assembly loops\n                // cb = 1 - don't breaker\n                // cb = 0 - break\n                let cb := 1\n\n                let mc := add(_preBytes, 0x20)\n                let end := add(mc, length)\n\n                for {\n                    let cc := add(_postBytes, 0x20)\n                // the next line is the loop condition:\n                // while(uint256(mc < end) + cb == 2)\n                } eq(add(lt(mc, end), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                        // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function equal_nonAligned(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n            case 1 {\n                // cb is a circuit breaker in the for loop since there's\n                //  no said feature for inline assembly loops\n                // cb = 1 - don't breaker\n                // cb = 0 - break\n                let cb := 1\n\n                let endMinusWord := add(_preBytes, length)\n                let mc := add(_preBytes, 0x20)\n                let cc := add(_postBytes, 0x20)\n\n                for {\n                // the next line is the loop condition:\n                // while(uint256(mc < endWord) + cb == 2)\n                } eq(add(lt(mc, endMinusWord), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                        // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n\n                // Only if still successful\n                // For <1 word tail bytes\n                if gt(success, 0) {\n                    // Get the remainder of length/32\n                    // length % 32 = AND(length, 32 - 1)\n                    let numTailBytes := and(length, 0x1f)\n                    let mcRem := mload(mc)\n                    let ccRem := mload(cc)\n                    for {\n                        let i := 0\n                    // the next line is the loop condition:\n                    // while(uint256(i < numTailBytes) + cb == 2)\n                    } eq(add(lt(i, numTailBytes), cb), 2) {\n                        i := add(i, 1)\n                    } {\n                        if iszero(eq(byte(i, mcRem), byte(i, ccRem))) {\n                            // unsuccess:\n                            success := 0\n                            cb := 0\n                        }\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function equalStorage(\n        bytes storage _preBytes,\n        bytes memory _postBytes\n    )\n        internal\n        view\n        returns (bool)\n    {\n        bool success = true;\n\n        assembly {\n            // we know _preBytes_offset is 0\n            let fslot := sload(_preBytes.slot)\n            // Decode the length of the stored array like in concatStorage().\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(slength, mlength)\n            case 1 {\n                // slength can contain both the length and contents of the array\n                // if length < 32 bytes so let's prepare for that\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n                if iszero(iszero(slength)) {\n                    switch lt(slength, 32)\n                    case 1 {\n                        // blank the last byte which is the length\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n                            // unsuccess:\n                            success := 0\n                        }\n                    }\n                    default {\n                        // cb is a circuit breaker in the for loop since there's\n                        //  no said feature for inline assembly loops\n                        // cb = 1 - don't breaker\n                        // cb = 0 - break\n                        let cb := 1\n\n                        // get the keccak hash to get the contents of the array\n                        mstore(0x0, _preBytes.slot)\n                        let sc := keccak256(0x0, 0x20)\n\n                        let mc := add(_postBytes, 0x20)\n                        let end := add(mc, mlength)\n\n                        // the next line is the loop condition:\n                        // while(uint256(mc < end) + cb == 2)\n                        for {} eq(add(lt(mc, end), cb), 2) {\n                            sc := add(sc, 1)\n                            mc := add(mc, 0x20)\n                        } {\n                            if iszero(eq(sload(sc), mload(mc))) {\n                                // unsuccess:\n                                success := 0\n                                cb := 0\n                            }\n                        }\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}